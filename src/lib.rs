#![no_std]
#![allow(bad_style)]
#![deny(missing_docs)]
#![deny(missing_debug_implementations)]
#![cfg_attr(docs_rs, feature(doc_cfg))]

//! Bindings to Gl 3.3
//!
//! Generated by [phosphorus](https://docs.rs/phosphorus/0.0.23/phosphorus/).
//!
//! Included Extensions (activate via cargo feature):
//! * `GL_ARB_debug_output`
//! * `GL_ARB_texture_filter_anisotropic`
//! * `GL_KHR_debug`
//!
//! Supported Features:
//! * `global_loader`: Include all mechanisms necessary for calling GL using
//!   global functions.
//! * `struct_loader`: Include all mechanisms necessary for calling GL as
//!   methods on a struct.
//! * `debug_trace_calls`: if cfg!(debug_assertions), any call to a GL function
//!   will `trace!` what was called and with what args.
//! * `debug_automatic_glGetError`: If cfg!(debug_assertions), this will
//!   automatically call `glGetError` after every call to any *other* GL
//!   function. If an error code occurs it's shown via `error!` along with the
//!   name of the function that had the error.
//! * `log`: imports `trace!` and `error!` macros from the `log` crate.
//!   Otherwise they just call `println!` and `eprintln!` respectively.
//! * `chlorine`: gets all C types from the `chlorine` crate (which is `no_std`
//!   friendly). Otherwise they will be imported from `std::os::raw`.
//! * `bytemuck`: Adds support for the `bytemuck` crate, mostly in the form of
//!   `bytemuck::Zeroable` on `GlFns`.
//! * `inline`: Tags all GL calls as `#[inline]`.
//! * `inline_always`: Tags all GL calls as `#[inline(always)]`. This will
//!   effectively override the `inline` feature.
//!
//! The crate is `no_std` friendly by default, but features above can end up
//! requiring `std` to be available.
//!
//! # GL Loaders
//! The docs for this crate hosted on docs.rs generate **both** the
//! `global_loader` and `struct_loader` documentation for sake of completeness.
//!
//! However, you are generally expected to use **only one** loader style in any
//! particular project.
//!
//! Each loader style has its own small advantages:
//! * The `global_loader` stores the GL function pointers in static `AtomicPtr`
//!   values.
//!   * Call [`load_global_gl_with`] to initialize the pointers.
//!   * Each GL function is available as a global function under its standard
//!     name, eg `glGetError()`.
//!   * This lets you call GL functions from anywhere at all, and it's how you
//!     might expect to use GL if you have a C background.
//!   * Being able to call GL from anywhere makes it easy to write Drop impls,
//!     among other things.
//! * The `struct_loader` stores all the function pointers in the fields of a
//!   [`GlFns`] struct.
//!   * Call [`GlFns::load_with`] to make a `GlFns` value.
//!   * Each GL function is available as a method on the struct with the `gl`
//!     prefix removed. It's presumed that you'll call the struct itself `gl`,
//!     so calls will look something like `gl.GetError()`.
//!   * This is closer to how WebGL works on WASM targets, and so this is how
//!     the [`glow`](https://docs.rs/glow) crate works to maintain consistency
//!     across desktop and web.
//!   * Also, if you want to do any sort of "live code reloading" you'll have to
//!     use the struct loader. DLLs don't share their static values with the
//!     main program, so if the DLL uses the global loader functions the
//!     pointers won't be loaded and calling any GL function from the DLL will
//!     panic. Instead, if you just pass a `&GlFns` to your DLL it can call the
//!     GL methods just fine.
//!
//! In both styles, if you call a function that isn't loaded you will get a
//! panic. This generally only happens if the context doesn't fully support
//! the GL version. You can check if a GL command is loaded or not before
//! actually calling it by adding `_is_loaded` to the name of the command. In
//! other words, `glGetError_is_loaded` to check if `glGetError` is globally
//! loaded, and `gl.GetError_is_loaded` to check if it's loaded in a `GlFns`.
//! All of the "`_is_loaded`" functions are hidden in the generated docs just
//! to keep things tidy, but they're there.
//!
//! # Safety
//! In general, there's many ways that GL can go wrong.
//!
//! For the purposes of this library, it's important to focus on the fact that:
//! * Initially all functions are null pointers. If a function is called when
//!   it's in a null state then you'll get a panic (reminder: a panic is safe).
//! * You can load pointers from the current GL context (described above).
//!   * These pointers are technically context specific, though in practice
//!     different contexts for the same graphics driver often all share the same
//!     function pointers.
//!   * The loader has no way to verify that pointers it gets are actually
//!     pointers to the correct functions, it just trusts what you tell it.
//! * Since loading a function pointer transitions the world from "it will
//!   definitely (safely) panic to call that GL command" to "it might be UB to
//!   call that GL command (even with the correct arguments)", the act of simply
//!   loading a function pointer is itself considered to be `unsafe`.
//! * Individual GL commands are generally safe to use once they've been
//!   properly loaded for the current context, but this crate doesn't attempt to
//!   sort out what is safe and what's not. All GL commands are blanket marked
//!   as being `unsafe`.
//! It's up to you to try and manage this unsafety! Sorry, but this crate just
//! does what you tell it to.

#[cfg(any(
  all(
    not(feature = "log"),
    any(feature = "debug_trace_calls", feature = "debug_automatic_glGetError")
  ),
  not(feature = "chlorine"),
))]
extern crate std;

#[cfg(feature = "chlorine")]
use chlorine::*;
#[cfg(not(feature = "chlorine"))]
use std::os::raw::*;

#[cfg(feature = "log")]
#[allow(unused)]
use log::{error, trace};
#[cfg(all(not(feature = "log"), feature = "debug_trace_calls"))]
macro_rules! trace { ($($arg:tt)*) => { std::println!($($arg)*) } }
#[cfg(all(not(feature = "log"), feature = "debug_automatic_glGetError"))]
macro_rules! error { ($($arg:tt)*) => { std::eprintln!($($arg)*) } }

use core::{
  mem::transmute,
  ptr::null_mut,
  sync::atomic::{AtomicPtr, Ordering},
};
#[allow(dead_code)]
const RELAX: Ordering = Ordering::Relaxed;
#[allow(dead_code)]
type APcv = AtomicPtr<c_void>;
#[cfg(feature = "global_loader")]
const fn ap_null() -> APcv {
  AtomicPtr::new(null_mut())
}

pub use types::*;
#[allow(missing_docs)]
pub mod types {
  //! Contains all the GL types.
  use super::*;
  pub type GLenum = c_uint;
  pub type GLboolean = c_uchar;
  pub type GLbitfield = c_uint;
  pub type GLvoid = c_void;
  pub type GLbyte = i8;
  pub type GLubyte = u8;
  pub type GLshort = i16;
  pub type GLushort = u16;
  pub type GLint = c_int;
  pub type GLuint = c_uint;
  pub type GLclampx = i32;
  pub type GLsizei = c_int;
  pub type GLfloat = c_float;
  pub type GLclampf = c_float;
  pub type GLdouble = c_double;
  pub type GLclampd = c_double;
  pub type GLeglClientBufferEXT = *mut c_void;
  pub type GLeglImageOES = *mut c_void;
  pub type GLchar = c_char;
  pub type GLcharARB = c_char;
  #[cfg(any(target_os = "macos", target_os = "ios"))]
  pub type GLhandleARB = *mut c_void;
  #[cfg(not(any(target_os = "macos", target_os = "ios")))]
  pub type GLhandleARB = c_uint;
  pub type GLhalf = u16;
  pub type GLhalfARB = u16;
  pub type GLfixed = i32;
  pub type GLintptr = isize;
  pub type GLintptrARB = isize;
  pub type GLsizeiptr = isize;
  pub type GLsizeiptrARB = isize;
  pub type GLint64 = i64;
  pub type GLint64EXT = i64;
  pub type GLuint64 = u64;
  pub type GLuint64EXT = u64;
  #[doc(hidden)]
  pub struct __GLsync {
    _priv: u8,
  }
  impl core::fmt::Debug for __GLsync {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      write!(f, "__GLsync")
    }
  }
  pub type GLsync = *mut __GLsync;
  pub struct _cl_context {
    _priv: u8,
  }
  impl core::fmt::Debug for _cl_context {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      write!(f, "_cl_context")
    }
  }
  pub struct _cl_event {
    _priv: u8,
  }
  impl core::fmt::Debug for _cl_event {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      write!(f, "_cl_event")
    }
  }
  pub type GLDEBUGPROC = Option<
    unsafe extern "system" fn(
      source: GLenum,
      gltype: GLenum,
      id: GLuint,
      severity: GLenum,
      length: GLsizei,
      message: *const GLchar,
      userParam: *mut c_void,
    ),
  >;
  pub type GLDEBUGPROCARB = Option<
    extern "system" fn(
      source: GLenum,
      gltype: GLenum,
      id: GLuint,
      severity: GLenum,
      length: GLsizei,
      message: *const GLchar,
      userParam: *mut c_void,
    ),
  >;
  pub type GLDEBUGPROCKHR = Option<
    extern "system" fn(
      source: GLenum,
      gltype: GLenum,
      id: GLuint,
      severity: GLenum,
      length: GLsizei,
      message: *const GLchar,
      userParam: *mut c_void,
    ),
  >;
  pub type GLDEBUGPROCAMD = Option<
    extern "system" fn(
      id: GLuint,
      category: GLenum,
      severity: GLenum,
      length: GLsizei,
      message: *const GLchar,
      userParam: *mut c_void,
    ),
  >;
  pub type GLhalfNV = c_ushort;
  pub type GLvdpauSurfaceNV = GLintptr;
  pub type GLVULKANPROCNV = Option<extern "system" fn()>;
}

pub use enums::*;
pub mod enums {
  //! Contains all the GL enumerated values.
  //!
  //! In C these are called 'enums', but in Rust we call them a 'const'.
  //! Whatever.
  use super::*;
  #[doc = "`GL_ACTIVE_ATTRIBUTES: GLenum = 0x8B89`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_ATTRIBUTES: GLenum = 0x8B89;
  #[doc = "`GL_ACTIVE_ATTRIBUTE_MAX_LENGTH: GLenum = 0x8B8A`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_ATTRIBUTE_MAX_LENGTH: GLenum = 0x8B8A;
  #[doc = "`GL_ACTIVE_TEXTURE: GLenum = 0x84E0`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_ACTIVE_TEXTURE: GLenum = 0x84E0;
  #[doc = "`GL_ACTIVE_UNIFORMS: GLenum = 0x8B86`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_UNIFORMS: GLenum = 0x8B86;
  #[doc = "`GL_ACTIVE_UNIFORM_BLOCKS: GLenum = 0x8A36`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_UNIFORM_BLOCKS: GLenum = 0x8A36;
  #[doc = "`GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: GLenum = 0x8A35`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: GLenum = 0x8A35;
  #[doc = "`GL_ACTIVE_UNIFORM_MAX_LENGTH: GLenum = 0x8B87`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_UNIFORM_MAX_LENGTH: GLenum = 0x8B87;
  #[doc = "`GL_ALIASED_LINE_WIDTH_RANGE: GLenum = 0x846E`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_ALIASED_LINE_WIDTH_RANGE: GLenum = 0x846E;
  #[doc = "`GL_ALPHA: GLenum = 0x1906`"]
  #[doc = "* **Groups:** TextureSwizzle, CombinerPortionNV, PathColorFormat, CombinerComponentUsageNV, PixelFormat"]
  pub const GL_ALPHA: GLenum = 0x1906;
  #[doc = "`GL_ALREADY_SIGNALED: GLenum = 0x911A`"]
  #[doc = "* **Group:** SyncStatus"]
  pub const GL_ALREADY_SIGNALED: GLenum = 0x911A;
  #[doc = "`GL_ALWAYS: GLenum = 0x0207`"]
  #[doc = "* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_ALWAYS: GLenum = 0x0207;
  #[doc = "`GL_AND: GLenum = 0x1501`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_AND: GLenum = 0x1501;
  #[doc = "`GL_AND_INVERTED: GLenum = 0x1504`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_AND_INVERTED: GLenum = 0x1504;
  #[doc = "`GL_AND_REVERSE: GLenum = 0x1502`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_AND_REVERSE: GLenum = 0x1502;
  #[doc = "`GL_ANY_SAMPLES_PASSED: GLenum = 0x8C2F`"]
  #[doc = "* **Group:** QueryTarget"]
  pub const GL_ANY_SAMPLES_PASSED: GLenum = 0x8C2F;
  #[doc = "`GL_ARRAY_BUFFER: GLenum = 0x8892`"]
  #[doc = "* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_ARRAY_BUFFER: GLenum = 0x8892;
  #[doc = "`GL_ARRAY_BUFFER_BINDING: GLenum = 0x8894`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_ARRAY_BUFFER_BINDING: GLenum = 0x8894;
  #[doc = "`GL_ATTACHED_SHADERS: GLenum = 0x8B85`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_ATTACHED_SHADERS: GLenum = 0x8B85;
  #[doc = "`GL_BACK: GLenum = 0x0405`"]
  #[doc = "* **Groups:** ColorBuffer, ColorMaterialFace, CullFaceMode, DrawBufferMode, ReadBufferMode, StencilFaceDirection, MaterialFace"]
  pub const GL_BACK: GLenum = 0x0405;
  #[doc = "`GL_BACK_LEFT: GLenum = 0x0402`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode"]
  pub const GL_BACK_LEFT: GLenum = 0x0402;
  #[doc = "`GL_BACK_RIGHT: GLenum = 0x0403`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode"]
  pub const GL_BACK_RIGHT: GLenum = 0x0403;
  #[doc = "`GL_BGR: GLenum = 0x80E0`"]
  #[doc = "* **Group:** PixelFormat"]
  pub const GL_BGR: GLenum = 0x80E0;
  #[doc = "`GL_BGRA: GLenum = 0x80E1`"]
  #[doc = "* **Group:** PixelFormat"]
  pub const GL_BGRA: GLenum = 0x80E1;
  #[doc = "`GL_BGRA_INTEGER: GLenum = 0x8D9B`"]
  #[doc = "* **Group:** PixelFormat"]
  pub const GL_BGRA_INTEGER: GLenum = 0x8D9B;
  #[doc = "`GL_BGR_INTEGER: GLenum = 0x8D9A`"]
  #[doc = "* **Group:** PixelFormat"]
  pub const GL_BGR_INTEGER: GLenum = 0x8D9A;
  #[doc = "`GL_BLEND: GLenum = 0x0BE2`"]
  #[doc = "* **Groups:** TextureEnvMode, EnableCap, GetPName"]
  pub const GL_BLEND: GLenum = 0x0BE2;
  #[doc = "`GL_BLEND_COLOR: GLenum = 0x8005`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_BLEND_COLOR: GLenum = 0x8005;
  #[doc = "`GL_BLEND_DST: GLenum = 0x0BE0`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_BLEND_DST: GLenum = 0x0BE0;
  #[doc = "`GL_BLEND_DST_ALPHA: GLenum = 0x80CA`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_BLEND_DST_ALPHA: GLenum = 0x80CA;
  #[doc = "`GL_BLEND_DST_RGB: GLenum = 0x80C8`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_BLEND_DST_RGB: GLenum = 0x80C8;
  #[doc = "`GL_BLEND_EQUATION: GLenum = 0x8009`"]
  pub const GL_BLEND_EQUATION: GLenum = 0x8009;
  #[doc = "`GL_BLEND_EQUATION_ALPHA: GLenum = 0x883D`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_BLEND_EQUATION_ALPHA: GLenum = 0x883D;
  #[doc = "`GL_BLEND_EQUATION_RGB: GLenum = 0x8009`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_BLEND_EQUATION_RGB: GLenum = 0x8009;
  #[doc = "`GL_BLEND_SRC: GLenum = 0x0BE1`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_BLEND_SRC: GLenum = 0x0BE1;
  #[doc = "`GL_BLEND_SRC_ALPHA: GLenum = 0x80CB`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_BLEND_SRC_ALPHA: GLenum = 0x80CB;
  #[doc = "`GL_BLEND_SRC_RGB: GLenum = 0x80C9`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_BLEND_SRC_RGB: GLenum = 0x80C9;
  #[doc = "`GL_BLUE: GLenum = 0x1905`"]
  #[doc = "* **Groups:** TextureSwizzle, CombinerComponentUsageNV, PixelFormat"]
  pub const GL_BLUE: GLenum = 0x1905;
  #[doc = "`GL_BLUE_INTEGER: GLenum = 0x8D96`"]
  #[doc = "* **Group:** PixelFormat"]
  pub const GL_BLUE_INTEGER: GLenum = 0x8D96;
  #[doc = "`GL_BOOL: GLenum = 0x8B56`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_BOOL: GLenum = 0x8B56;
  #[doc = "`GL_BOOL_VEC2: GLenum = 0x8B57`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_BOOL_VEC2: GLenum = 0x8B57;
  #[doc = "`GL_BOOL_VEC3: GLenum = 0x8B58`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_BOOL_VEC3: GLenum = 0x8B58;
  #[doc = "`GL_BOOL_VEC4: GLenum = 0x8B59`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_BOOL_VEC4: GLenum = 0x8B59;
  #[doc = "`GL_BUFFER: GLenum = 0x82E0`"]
  #[doc = "* **Group:** ObjectIdentifier"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_BUFFER: GLenum = 0x82E0;
  #[doc = "`GL_BUFFER_ACCESS: GLenum = 0x88BB`"]
  #[doc = "* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_ACCESS: GLenum = 0x88BB;
  #[doc = "`GL_BUFFER_ACCESS_FLAGS: GLenum = 0x911F`"]
  #[doc = "* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_ACCESS_FLAGS: GLenum = 0x911F;
  #[doc = "`GL_BUFFER_MAPPED: GLenum = 0x88BC`"]
  #[doc = "* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_MAPPED: GLenum = 0x88BC;
  #[doc = "`GL_BUFFER_MAP_LENGTH: GLenum = 0x9120`"]
  #[doc = "* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_MAP_LENGTH: GLenum = 0x9120;
  #[doc = "`GL_BUFFER_MAP_OFFSET: GLenum = 0x9121`"]
  #[doc = "* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_MAP_OFFSET: GLenum = 0x9121;
  #[doc = "`GL_BUFFER_MAP_POINTER: GLenum = 0x88BD`"]
  #[doc = "* **Group:** BufferPointerNameARB"]
  pub const GL_BUFFER_MAP_POINTER: GLenum = 0x88BD;
  #[doc = "`GL_BUFFER_SIZE: GLenum = 0x8764`"]
  #[doc = "* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_SIZE: GLenum = 0x8764;
  #[doc = "`GL_BUFFER_USAGE: GLenum = 0x8765`"]
  #[doc = "* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_USAGE: GLenum = 0x8765;
  #[doc = "`GL_BYTE: GLenum = 0x1400`"]
  #[doc = "* **Groups:** VertexAttribIType, WeightPointerTypeARB, TangentPointerTypeEXT, BinormalPointerTypeEXT, ColorPointerType, ListNameType, NormalPointerType, PixelType, VertexAttribType, VertexAttribPointerType"]
  pub const GL_BYTE: GLenum = 0x1400;
  #[doc = "`GL_CCW: GLenum = 0x0901`"]
  #[doc = "* **Group:** FrontFaceDirection"]
  pub const GL_CCW: GLenum = 0x0901;
  #[doc = "`GL_CLAMP_READ_COLOR: GLenum = 0x891C`"]
  #[doc = "* **Group:** ClampColorTargetARB"]
  pub const GL_CLAMP_READ_COLOR: GLenum = 0x891C;
  #[doc = "`GL_CLAMP_TO_BORDER: GLenum = 0x812D`"]
  #[doc = "* **Group:** TextureWrapMode"]
  pub const GL_CLAMP_TO_BORDER: GLenum = 0x812D;
  #[doc = "`GL_CLAMP_TO_EDGE: GLenum = 0x812F`"]
  #[doc = "* **Group:** TextureWrapMode"]
  pub const GL_CLAMP_TO_EDGE: GLenum = 0x812F;
  #[doc = "`GL_CLEAR: GLenum = 0x1500`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_CLEAR: GLenum = 0x1500;
  #[doc = "`GL_CLIP_DISTANCE0: GLenum = 0x3000`"]
  #[doc = "* **Groups:** EnableCap, ClipPlaneName"]
  #[doc = "* **Alias Of:** `GL_CLIP_PLANE0`"]
  pub const GL_CLIP_DISTANCE0: GLenum = 0x3000;
  #[doc = "`GL_CLIP_DISTANCE1: GLenum = 0x3001`"]
  #[doc = "* **Groups:** EnableCap, ClipPlaneName"]
  #[doc = "* **Alias Of:** `GL_CLIP_PLANE1`"]
  pub const GL_CLIP_DISTANCE1: GLenum = 0x3001;
  #[doc = "`GL_CLIP_DISTANCE2: GLenum = 0x3002`"]
  #[doc = "* **Groups:** EnableCap, ClipPlaneName"]
  #[doc = "* **Alias Of:** `GL_CLIP_PLANE2`"]
  pub const GL_CLIP_DISTANCE2: GLenum = 0x3002;
  #[doc = "`GL_CLIP_DISTANCE3: GLenum = 0x3003`"]
  #[doc = "* **Groups:** EnableCap, ClipPlaneName"]
  #[doc = "* **Alias Of:** `GL_CLIP_PLANE3`"]
  pub const GL_CLIP_DISTANCE3: GLenum = 0x3003;
  #[doc = "`GL_CLIP_DISTANCE4: GLenum = 0x3004`"]
  #[doc = "* **Groups:** EnableCap, ClipPlaneName"]
  #[doc = "* **Alias Of:** `GL_CLIP_PLANE4`"]
  pub const GL_CLIP_DISTANCE4: GLenum = 0x3004;
  #[doc = "`GL_CLIP_DISTANCE5: GLenum = 0x3005`"]
  #[doc = "* **Groups:** EnableCap, ClipPlaneName"]
  #[doc = "* **Alias Of:** `GL_CLIP_PLANE5`"]
  pub const GL_CLIP_DISTANCE5: GLenum = 0x3005;
  #[doc = "`GL_CLIP_DISTANCE6: GLenum = 0x3006`"]
  #[doc = "* **Groups:** EnableCap, ClipPlaneName"]
  pub const GL_CLIP_DISTANCE6: GLenum = 0x3006;
  #[doc = "`GL_CLIP_DISTANCE7: GLenum = 0x3007`"]
  #[doc = "* **Groups:** EnableCap, ClipPlaneName"]
  pub const GL_CLIP_DISTANCE7: GLenum = 0x3007;
  #[doc = "`GL_COLOR: GLenum = 0x1800`"]
  #[doc = "* **Groups:** Buffer, PixelCopyType, InvalidateFramebufferAttachment"]
  pub const GL_COLOR: GLenum = 0x1800;
  #[doc = "`GL_COLOR_ATTACHMENT0: GLenum = 0x8CE0`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT0: GLenum = 0x8CE0;
  #[doc = "`GL_COLOR_ATTACHMENT1: GLenum = 0x8CE1`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT1: GLenum = 0x8CE1;
  #[doc = "`GL_COLOR_ATTACHMENT10: GLenum = 0x8CEA`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT10: GLenum = 0x8CEA;
  #[doc = "`GL_COLOR_ATTACHMENT11: GLenum = 0x8CEB`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT11: GLenum = 0x8CEB;
  #[doc = "`GL_COLOR_ATTACHMENT12: GLenum = 0x8CEC`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT12: GLenum = 0x8CEC;
  #[doc = "`GL_COLOR_ATTACHMENT13: GLenum = 0x8CED`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT13: GLenum = 0x8CED;
  #[doc = "`GL_COLOR_ATTACHMENT14: GLenum = 0x8CEE`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT14: GLenum = 0x8CEE;
  #[doc = "`GL_COLOR_ATTACHMENT15: GLenum = 0x8CEF`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT15: GLenum = 0x8CEF;
  #[doc = "`GL_COLOR_ATTACHMENT16: GLenum = 0x8CF0`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT16: GLenum = 0x8CF0;
  #[doc = "`GL_COLOR_ATTACHMENT17: GLenum = 0x8CF1`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT17: GLenum = 0x8CF1;
  #[doc = "`GL_COLOR_ATTACHMENT18: GLenum = 0x8CF2`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT18: GLenum = 0x8CF2;
  #[doc = "`GL_COLOR_ATTACHMENT19: GLenum = 0x8CF3`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT19: GLenum = 0x8CF3;
  #[doc = "`GL_COLOR_ATTACHMENT2: GLenum = 0x8CE2`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT2: GLenum = 0x8CE2;
  #[doc = "`GL_COLOR_ATTACHMENT20: GLenum = 0x8CF4`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT20: GLenum = 0x8CF4;
  #[doc = "`GL_COLOR_ATTACHMENT21: GLenum = 0x8CF5`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT21: GLenum = 0x8CF5;
  #[doc = "`GL_COLOR_ATTACHMENT22: GLenum = 0x8CF6`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT22: GLenum = 0x8CF6;
  #[doc = "`GL_COLOR_ATTACHMENT23: GLenum = 0x8CF7`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT23: GLenum = 0x8CF7;
  #[doc = "`GL_COLOR_ATTACHMENT24: GLenum = 0x8CF8`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT24: GLenum = 0x8CF8;
  #[doc = "`GL_COLOR_ATTACHMENT25: GLenum = 0x8CF9`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT25: GLenum = 0x8CF9;
  #[doc = "`GL_COLOR_ATTACHMENT26: GLenum = 0x8CFA`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT26: GLenum = 0x8CFA;
  #[doc = "`GL_COLOR_ATTACHMENT27: GLenum = 0x8CFB`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT27: GLenum = 0x8CFB;
  #[doc = "`GL_COLOR_ATTACHMENT28: GLenum = 0x8CFC`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT28: GLenum = 0x8CFC;
  #[doc = "`GL_COLOR_ATTACHMENT29: GLenum = 0x8CFD`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT29: GLenum = 0x8CFD;
  #[doc = "`GL_COLOR_ATTACHMENT3: GLenum = 0x8CE3`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT3: GLenum = 0x8CE3;
  #[doc = "`GL_COLOR_ATTACHMENT30: GLenum = 0x8CFE`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT30: GLenum = 0x8CFE;
  #[doc = "`GL_COLOR_ATTACHMENT31: GLenum = 0x8CFF`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT31: GLenum = 0x8CFF;
  #[doc = "`GL_COLOR_ATTACHMENT4: GLenum = 0x8CE4`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT4: GLenum = 0x8CE4;
  #[doc = "`GL_COLOR_ATTACHMENT5: GLenum = 0x8CE5`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT5: GLenum = 0x8CE5;
  #[doc = "`GL_COLOR_ATTACHMENT6: GLenum = 0x8CE6`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT6: GLenum = 0x8CE6;
  #[doc = "`GL_COLOR_ATTACHMENT7: GLenum = 0x8CE7`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT7: GLenum = 0x8CE7;
  #[doc = "`GL_COLOR_ATTACHMENT8: GLenum = 0x8CE8`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT8: GLenum = 0x8CE8;
  #[doc = "`GL_COLOR_ATTACHMENT9: GLenum = 0x8CE9`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT9: GLenum = 0x8CE9;
  #[doc = "`GL_COLOR_BUFFER_BIT: GLbitfield = 0x00004000`"]
  #[doc = "* **Groups:** ClearBufferMask, AttribMask"]
  pub const GL_COLOR_BUFFER_BIT: GLbitfield = 0x00004000;
  #[doc = "`GL_COLOR_CLEAR_VALUE: GLenum = 0x0C22`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_COLOR_CLEAR_VALUE: GLenum = 0x0C22;
  #[doc = "`GL_COLOR_LOGIC_OP: GLenum = 0x0BF2`"]
  #[doc = "* **Groups:** GetPName, EnableCap"]
  pub const GL_COLOR_LOGIC_OP: GLenum = 0x0BF2;
  #[doc = "`GL_COLOR_WRITEMASK: GLenum = 0x0C23`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_COLOR_WRITEMASK: GLenum = 0x0C23;
  #[doc = "`GL_COMPARE_REF_TO_TEXTURE: GLenum = 0x884E`"]
  #[doc = "* **Group:** TextureCompareMode"]
  #[doc = "* **Alias Of:** `GL_COMPARE_R_TO_TEXTURE`"]
  pub const GL_COMPARE_REF_TO_TEXTURE: GLenum = 0x884E;
  #[doc = "`GL_COMPILE_STATUS: GLenum = 0x8B81`"]
  #[doc = "* **Group:** ShaderParameterName"]
  pub const GL_COMPILE_STATUS: GLenum = 0x8B81;
  #[doc = "`GL_COMPRESSED_RED: GLenum = 0x8225`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RED: GLenum = 0x8225;
  #[doc = "`GL_COMPRESSED_RED_RGTC1: GLenum = 0x8DBB`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RED_RGTC1: GLenum = 0x8DBB;
  #[doc = "`GL_COMPRESSED_RG: GLenum = 0x8226`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RG: GLenum = 0x8226;
  #[doc = "`GL_COMPRESSED_RGB: GLenum = 0x84ED`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RGB: GLenum = 0x84ED;
  #[doc = "`GL_COMPRESSED_RGBA: GLenum = 0x84EE`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RGBA: GLenum = 0x84EE;
  #[doc = "`GL_COMPRESSED_RG_RGTC2: GLenum = 0x8DBD`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RG_RGTC2: GLenum = 0x8DBD;
  #[doc = "`GL_COMPRESSED_SIGNED_RED_RGTC1: GLenum = 0x8DBC`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SIGNED_RED_RGTC1: GLenum = 0x8DBC;
  #[doc = "`GL_COMPRESSED_SIGNED_RG_RGTC2: GLenum = 0x8DBE`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SIGNED_RG_RGTC2: GLenum = 0x8DBE;
  #[doc = "`GL_COMPRESSED_SRGB: GLenum = 0x8C48`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SRGB: GLenum = 0x8C48;
  #[doc = "`GL_COMPRESSED_SRGB_ALPHA: GLenum = 0x8C49`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SRGB_ALPHA: GLenum = 0x8C49;
  #[doc = "`GL_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A3`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A3;
  #[doc = "`GL_CONDITION_SATISFIED: GLenum = 0x911C`"]
  #[doc = "* **Group:** SyncStatus"]
  pub const GL_CONDITION_SATISFIED: GLenum = 0x911C;
  #[doc = "`GL_CONSTANT_ALPHA: GLenum = 0x8003`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_CONSTANT_ALPHA: GLenum = 0x8003;
  #[doc = "`GL_CONSTANT_COLOR: GLenum = 0x8001`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_CONSTANT_COLOR: GLenum = 0x8001;
  #[doc = "`GL_CONTEXT_COMPATIBILITY_PROFILE_BIT: GLbitfield = 0x00000002`"]
  #[doc = "* **Group:** ContextProfileMask"]
  pub const GL_CONTEXT_COMPATIBILITY_PROFILE_BIT: GLbitfield = 0x00000002;
  #[doc = "`GL_CONTEXT_CORE_PROFILE_BIT: GLbitfield = 0x00000001`"]
  #[doc = "* **Group:** ContextProfileMask"]
  pub const GL_CONTEXT_CORE_PROFILE_BIT: GLbitfield = 0x00000001;
  #[doc = "`GL_CONTEXT_FLAGS: GLenum = 0x821E`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_CONTEXT_FLAGS: GLenum = 0x821E;
  #[doc = "`GL_CONTEXT_FLAG_DEBUG_BIT: GLbitfield = 0x00000002`"]
  #[doc = "* **Group:** ContextFlagMask"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_CONTEXT_FLAG_DEBUG_BIT: GLbitfield = 0x00000002;
  #[doc = "`GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: GLbitfield = 0x00000001`"]
  #[doc = "* **Group:** ContextFlagMask"]
  pub const GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: GLbitfield = 0x00000001;
  #[doc = "`GL_CONTEXT_PROFILE_MASK: GLenum = 0x9126`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_CONTEXT_PROFILE_MASK: GLenum = 0x9126;
  #[doc = "`GL_COPY: GLenum = 0x1503`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_COPY: GLenum = 0x1503;
  #[doc = "`GL_COPY_INVERTED: GLenum = 0x150C`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_COPY_INVERTED: GLenum = 0x150C;
  #[doc = "`GL_COPY_READ_BUFFER: GLenum = 0x8F36`"]
  #[doc = "* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_COPY_READ_BUFFER: GLenum = 0x8F36;
  #[doc = "`GL_COPY_WRITE_BUFFER: GLenum = 0x8F37`"]
  #[doc = "* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_COPY_WRITE_BUFFER: GLenum = 0x8F37;
  #[doc = "`GL_CULL_FACE: GLenum = 0x0B44`"]
  #[doc = "* **Groups:** GetPName, EnableCap"]
  pub const GL_CULL_FACE: GLenum = 0x0B44;
  #[doc = "`GL_CULL_FACE_MODE: GLenum = 0x0B45`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_CULL_FACE_MODE: GLenum = 0x0B45;
  #[doc = "`GL_CURRENT_PROGRAM: GLenum = 0x8B8D`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_CURRENT_PROGRAM: GLenum = 0x8B8D;
  #[doc = "`GL_CURRENT_QUERY: GLenum = 0x8865`"]
  #[doc = "* **Group:** QueryParameterName"]
  pub const GL_CURRENT_QUERY: GLenum = 0x8865;
  #[doc = "`GL_CURRENT_VERTEX_ATTRIB: GLenum = 0x8626`"]
  #[doc = "* **Groups:** VertexAttribEnum, VertexAttribPropertyARB"]
  pub const GL_CURRENT_VERTEX_ATTRIB: GLenum = 0x8626;
  #[doc = "`GL_CW: GLenum = 0x0900`"]
  #[doc = "* **Group:** FrontFaceDirection"]
  pub const GL_CW: GLenum = 0x0900;
  #[doc = "`GL_DEBUG_CALLBACK_FUNCTION: GLenum = 0x8244`"]
  #[doc = "* **Group:** GetPointervPName"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_CALLBACK_FUNCTION: GLenum = 0x8244;
  #[doc = "`GL_DEBUG_CALLBACK_FUNCTION_ARB: GLenum = 0x8244`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_CALLBACK_FUNCTION_ARB: GLenum = 0x8244;
  #[doc = "`GL_DEBUG_CALLBACK_USER_PARAM: GLenum = 0x8245`"]
  #[doc = "* **Group:** GetPointervPName"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_CALLBACK_USER_PARAM: GLenum = 0x8245;
  #[doc = "`GL_DEBUG_CALLBACK_USER_PARAM_ARB: GLenum = 0x8245`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_CALLBACK_USER_PARAM_ARB: GLenum = 0x8245;
  #[doc = "`GL_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826D`"]
  #[doc = "* **Group:** GetPName"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826D;
  #[doc = "`GL_DEBUG_LOGGED_MESSAGES: GLenum = 0x9145`"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_LOGGED_MESSAGES: GLenum = 0x9145;
  #[doc = "`GL_DEBUG_LOGGED_MESSAGES_ARB: GLenum = 0x9145`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_LOGGED_MESSAGES_ARB: GLenum = 0x9145;
  #[doc = "`GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: GLenum = 0x8243`"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: GLenum = 0x8243;
  #[doc = "`GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB: GLenum = 0x8243`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB: GLenum = 0x8243;
  #[doc = "`GL_DEBUG_OUTPUT: GLenum = 0x92E0`"]
  #[doc = "* **Group:** EnableCap"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_OUTPUT: GLenum = 0x92E0;
  #[doc = "`GL_DEBUG_OUTPUT_SYNCHRONOUS: GLenum = 0x8242`"]
  #[doc = "* **Group:** EnableCap"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_OUTPUT_SYNCHRONOUS: GLenum = 0x8242;
  #[doc = "`GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB: GLenum = 0x8242`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB: GLenum = 0x8242;
  #[doc = "`GL_DEBUG_SEVERITY_HIGH: GLenum = 0x9146`"]
  #[doc = "* **Group:** DebugSeverity"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_SEVERITY_HIGH: GLenum = 0x9146;
  #[doc = "`GL_DEBUG_SEVERITY_HIGH_ARB: GLenum = 0x9146`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_SEVERITY_HIGH_ARB: GLenum = 0x9146;
  #[doc = "`GL_DEBUG_SEVERITY_LOW: GLenum = 0x9148`"]
  #[doc = "* **Group:** DebugSeverity"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_SEVERITY_LOW: GLenum = 0x9148;
  #[doc = "`GL_DEBUG_SEVERITY_LOW_ARB: GLenum = 0x9148`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_SEVERITY_LOW_ARB: GLenum = 0x9148;
  #[doc = "`GL_DEBUG_SEVERITY_MEDIUM: GLenum = 0x9147`"]
  #[doc = "* **Group:** DebugSeverity"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_SEVERITY_MEDIUM: GLenum = 0x9147;
  #[doc = "`GL_DEBUG_SEVERITY_MEDIUM_ARB: GLenum = 0x9147`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_SEVERITY_MEDIUM_ARB: GLenum = 0x9147;
  #[doc = "`GL_DEBUG_SEVERITY_NOTIFICATION: GLenum = 0x826B`"]
  #[doc = "* **Group:** DebugSeverity"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_SEVERITY_NOTIFICATION: GLenum = 0x826B;
  #[doc = "`GL_DEBUG_SOURCE_API: GLenum = 0x8246`"]
  #[doc = "* **Group:** DebugSource"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_SOURCE_API: GLenum = 0x8246;
  #[doc = "`GL_DEBUG_SOURCE_API_ARB: GLenum = 0x8246`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_SOURCE_API_ARB: GLenum = 0x8246;
  #[doc = "`GL_DEBUG_SOURCE_APPLICATION: GLenum = 0x824A`"]
  #[doc = "* **Group:** DebugSource"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_SOURCE_APPLICATION: GLenum = 0x824A;
  #[doc = "`GL_DEBUG_SOURCE_APPLICATION_ARB: GLenum = 0x824A`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_SOURCE_APPLICATION_ARB: GLenum = 0x824A;
  #[doc = "`GL_DEBUG_SOURCE_OTHER: GLenum = 0x824B`"]
  #[doc = "* **Group:** DebugSource"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_SOURCE_OTHER: GLenum = 0x824B;
  #[doc = "`GL_DEBUG_SOURCE_OTHER_ARB: GLenum = 0x824B`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_SOURCE_OTHER_ARB: GLenum = 0x824B;
  #[doc = "`GL_DEBUG_SOURCE_SHADER_COMPILER: GLenum = 0x8248`"]
  #[doc = "* **Group:** DebugSource"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_SOURCE_SHADER_COMPILER: GLenum = 0x8248;
  #[doc = "`GL_DEBUG_SOURCE_SHADER_COMPILER_ARB: GLenum = 0x8248`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_SOURCE_SHADER_COMPILER_ARB: GLenum = 0x8248;
  #[doc = "`GL_DEBUG_SOURCE_THIRD_PARTY: GLenum = 0x8249`"]
  #[doc = "* **Group:** DebugSource"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_SOURCE_THIRD_PARTY: GLenum = 0x8249;
  #[doc = "`GL_DEBUG_SOURCE_THIRD_PARTY_ARB: GLenum = 0x8249`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_SOURCE_THIRD_PARTY_ARB: GLenum = 0x8249;
  #[doc = "`GL_DEBUG_SOURCE_WINDOW_SYSTEM: GLenum = 0x8247`"]
  #[doc = "* **Group:** DebugSource"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_SOURCE_WINDOW_SYSTEM: GLenum = 0x8247;
  #[doc = "`GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB: GLenum = 0x8247`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB: GLenum = 0x8247;
  #[doc = "`GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: GLenum = 0x824D`"]
  #[doc = "* **Group:** DebugType"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: GLenum = 0x824D;
  #[doc = "`GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB: GLenum = 0x824D`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB: GLenum = 0x824D;
  #[doc = "`GL_DEBUG_TYPE_ERROR: GLenum = 0x824C`"]
  #[doc = "* **Group:** DebugType"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_TYPE_ERROR: GLenum = 0x824C;
  #[doc = "`GL_DEBUG_TYPE_ERROR_ARB: GLenum = 0x824C`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_TYPE_ERROR_ARB: GLenum = 0x824C;
  #[doc = "`GL_DEBUG_TYPE_MARKER: GLenum = 0x8268`"]
  #[doc = "* **Group:** DebugType"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_TYPE_MARKER: GLenum = 0x8268;
  #[doc = "`GL_DEBUG_TYPE_OTHER: GLenum = 0x8251`"]
  #[doc = "* **Group:** DebugType"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_TYPE_OTHER: GLenum = 0x8251;
  #[doc = "`GL_DEBUG_TYPE_OTHER_ARB: GLenum = 0x8251`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_TYPE_OTHER_ARB: GLenum = 0x8251;
  #[doc = "`GL_DEBUG_TYPE_PERFORMANCE: GLenum = 0x8250`"]
  #[doc = "* **Group:** DebugType"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_TYPE_PERFORMANCE: GLenum = 0x8250;
  #[doc = "`GL_DEBUG_TYPE_PERFORMANCE_ARB: GLenum = 0x8250`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_TYPE_PERFORMANCE_ARB: GLenum = 0x8250;
  #[doc = "`GL_DEBUG_TYPE_POP_GROUP: GLenum = 0x826A`"]
  #[doc = "* **Group:** DebugType"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_TYPE_POP_GROUP: GLenum = 0x826A;
  #[doc = "`GL_DEBUG_TYPE_PORTABILITY: GLenum = 0x824F`"]
  #[doc = "* **Group:** DebugType"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_TYPE_PORTABILITY: GLenum = 0x824F;
  #[doc = "`GL_DEBUG_TYPE_PORTABILITY_ARB: GLenum = 0x824F`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_TYPE_PORTABILITY_ARB: GLenum = 0x824F;
  #[doc = "`GL_DEBUG_TYPE_PUSH_GROUP: GLenum = 0x8269`"]
  #[doc = "* **Group:** DebugType"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_TYPE_PUSH_GROUP: GLenum = 0x8269;
  #[doc = "`GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: GLenum = 0x824E`"]
  #[doc = "* **Group:** DebugType"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: GLenum = 0x824E;
  #[doc = "`GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB: GLenum = 0x824E`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB: GLenum = 0x824E;
  #[doc = "`GL_DECR: GLenum = 0x1E03`"]
  #[doc = "* **Group:** StencilOp"]
  pub const GL_DECR: GLenum = 0x1E03;
  #[doc = "`GL_DECR_WRAP: GLenum = 0x8508`"]
  #[doc = "* **Group:** StencilOp"]
  pub const GL_DECR_WRAP: GLenum = 0x8508;
  #[doc = "`GL_DELETE_STATUS: GLenum = 0x8B80`"]
  #[doc = "* **Groups:** ProgramPropertyARB, ShaderParameterName"]
  pub const GL_DELETE_STATUS: GLenum = 0x8B80;
  #[doc = "`GL_DEPTH: GLenum = 0x1801`"]
  #[doc = "* **Groups:** Buffer, PixelCopyType, InvalidateFramebufferAttachment"]
  pub const GL_DEPTH: GLenum = 0x1801;
  #[doc = "`GL_DEPTH24_STENCIL8: GLenum = 0x88F0`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_DEPTH24_STENCIL8: GLenum = 0x88F0;
  #[doc = "`GL_DEPTH32F_STENCIL8: GLenum = 0x8CAD`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_DEPTH32F_STENCIL8: GLenum = 0x8CAD;
  #[doc = "`GL_DEPTH_ATTACHMENT: GLenum = 0x8D00`"]
  #[doc = "* **Group:** InvalidateFramebufferAttachment"]
  pub const GL_DEPTH_ATTACHMENT: GLenum = 0x8D00;
  #[doc = "`GL_DEPTH_BUFFER_BIT: GLbitfield = 0x00000100`"]
  #[doc = "* **Groups:** ClearBufferMask, AttribMask"]
  pub const GL_DEPTH_BUFFER_BIT: GLbitfield = 0x00000100;
  #[doc = "`GL_DEPTH_CLAMP: GLenum = 0x864F`"]
  #[doc = "* **Group:** EnableCap"]
  pub const GL_DEPTH_CLAMP: GLenum = 0x864F;
  #[doc = "`GL_DEPTH_CLEAR_VALUE: GLenum = 0x0B73`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_DEPTH_CLEAR_VALUE: GLenum = 0x0B73;
  #[doc = "`GL_DEPTH_COMPONENT: GLenum = 0x1902`"]
  #[doc = "* **Groups:** InternalFormat, PixelFormat"]
  pub const GL_DEPTH_COMPONENT: GLenum = 0x1902;
  #[doc = "`GL_DEPTH_COMPONENT16: GLenum = 0x81A5`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_DEPTH_COMPONENT16: GLenum = 0x81A5;
  #[doc = "`GL_DEPTH_COMPONENT24: GLenum = 0x81A6`"]
  pub const GL_DEPTH_COMPONENT24: GLenum = 0x81A6;
  #[doc = "`GL_DEPTH_COMPONENT32: GLenum = 0x81A7`"]
  pub const GL_DEPTH_COMPONENT32: GLenum = 0x81A7;
  #[doc = "`GL_DEPTH_COMPONENT32F: GLenum = 0x8CAC`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_DEPTH_COMPONENT32F: GLenum = 0x8CAC;
  #[doc = "`GL_DEPTH_FUNC: GLenum = 0x0B74`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_DEPTH_FUNC: GLenum = 0x0B74;
  #[doc = "`GL_DEPTH_RANGE: GLenum = 0x0B70`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_DEPTH_RANGE: GLenum = 0x0B70;
  #[doc = "`GL_DEPTH_STENCIL: GLenum = 0x84F9`"]
  #[doc = "* **Groups:** InternalFormat, PixelFormat"]
  pub const GL_DEPTH_STENCIL: GLenum = 0x84F9;
  #[doc = "`GL_DEPTH_STENCIL_ATTACHMENT: GLenum = 0x821A`"]
  #[doc = "* **Group:** InvalidateFramebufferAttachment"]
  pub const GL_DEPTH_STENCIL_ATTACHMENT: GLenum = 0x821A;
  #[doc = "`GL_DEPTH_TEST: GLenum = 0x0B71`"]
  #[doc = "* **Groups:** GetPName, EnableCap"]
  pub const GL_DEPTH_TEST: GLenum = 0x0B71;
  #[doc = "`GL_DEPTH_WRITEMASK: GLenum = 0x0B72`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_DEPTH_WRITEMASK: GLenum = 0x0B72;
  #[doc = "`GL_DITHER: GLenum = 0x0BD0`"]
  #[doc = "* **Groups:** GetPName, EnableCap"]
  pub const GL_DITHER: GLenum = 0x0BD0;
  #[doc = "`GL_DONT_CARE: GLenum = 0x1100`"]
  #[doc = "* **Groups:** DebugSeverity, HintMode, DebugSource, DebugType"]
  pub const GL_DONT_CARE: GLenum = 0x1100;
  #[doc = "`GL_DOUBLE: GLenum = 0x140A`"]
  #[doc = "* **Groups:** VertexAttribLType, MapTypeNV, SecondaryColorPointerTypeIBM, WeightPointerTypeARB, TangentPointerTypeEXT, BinormalPointerTypeEXT, FogCoordinatePointerType, FogPointerTypeEXT, FogPointerTypeIBM, IndexPointerType, NormalPointerType, TexCoordPointerType, VertexPointerType, VertexAttribType, AttributeType, UniformType, VertexAttribPointerType, GlslTypeToken"]
  pub const GL_DOUBLE: GLenum = 0x140A;
  #[doc = "`GL_DOUBLEBUFFER: GLenum = 0x0C32`"]
  #[doc = "* **Groups:** GetFramebufferParameter, GetPName"]
  pub const GL_DOUBLEBUFFER: GLenum = 0x0C32;
  #[doc = "`GL_DRAW_BUFFER: GLenum = 0x0C01`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_DRAW_BUFFER: GLenum = 0x0C01;
  #[doc = "`GL_DRAW_BUFFER0: GLenum = 0x8825`"]
  pub const GL_DRAW_BUFFER0: GLenum = 0x8825;
  #[doc = "`GL_DRAW_BUFFER1: GLenum = 0x8826`"]
  pub const GL_DRAW_BUFFER1: GLenum = 0x8826;
  #[doc = "`GL_DRAW_BUFFER10: GLenum = 0x882F`"]
  pub const GL_DRAW_BUFFER10: GLenum = 0x882F;
  #[doc = "`GL_DRAW_BUFFER11: GLenum = 0x8830`"]
  pub const GL_DRAW_BUFFER11: GLenum = 0x8830;
  #[doc = "`GL_DRAW_BUFFER12: GLenum = 0x8831`"]
  pub const GL_DRAW_BUFFER12: GLenum = 0x8831;
  #[doc = "`GL_DRAW_BUFFER13: GLenum = 0x8832`"]
  pub const GL_DRAW_BUFFER13: GLenum = 0x8832;
  #[doc = "`GL_DRAW_BUFFER14: GLenum = 0x8833`"]
  pub const GL_DRAW_BUFFER14: GLenum = 0x8833;
  #[doc = "`GL_DRAW_BUFFER15: GLenum = 0x8834`"]
  pub const GL_DRAW_BUFFER15: GLenum = 0x8834;
  #[doc = "`GL_DRAW_BUFFER2: GLenum = 0x8827`"]
  pub const GL_DRAW_BUFFER2: GLenum = 0x8827;
  #[doc = "`GL_DRAW_BUFFER3: GLenum = 0x8828`"]
  pub const GL_DRAW_BUFFER3: GLenum = 0x8828;
  #[doc = "`GL_DRAW_BUFFER4: GLenum = 0x8829`"]
  pub const GL_DRAW_BUFFER4: GLenum = 0x8829;
  #[doc = "`GL_DRAW_BUFFER5: GLenum = 0x882A`"]
  pub const GL_DRAW_BUFFER5: GLenum = 0x882A;
  #[doc = "`GL_DRAW_BUFFER6: GLenum = 0x882B`"]
  pub const GL_DRAW_BUFFER6: GLenum = 0x882B;
  #[doc = "`GL_DRAW_BUFFER7: GLenum = 0x882C`"]
  pub const GL_DRAW_BUFFER7: GLenum = 0x882C;
  #[doc = "`GL_DRAW_BUFFER8: GLenum = 0x882D`"]
  pub const GL_DRAW_BUFFER8: GLenum = 0x882D;
  #[doc = "`GL_DRAW_BUFFER9: GLenum = 0x882E`"]
  pub const GL_DRAW_BUFFER9: GLenum = 0x882E;
  #[doc = "`GL_DRAW_FRAMEBUFFER: GLenum = 0x8CA9`"]
  #[doc = "* **Groups:** CheckFramebufferStatusTarget, FramebufferTarget"]
  pub const GL_DRAW_FRAMEBUFFER: GLenum = 0x8CA9;
  #[doc = "`GL_DRAW_FRAMEBUFFER_BINDING: GLenum = 0x8CA6`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_DRAW_FRAMEBUFFER_BINDING: GLenum = 0x8CA6;
  #[doc = "`GL_DST_ALPHA: GLenum = 0x0304`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_DST_ALPHA: GLenum = 0x0304;
  #[doc = "`GL_DST_COLOR: GLenum = 0x0306`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_DST_COLOR: GLenum = 0x0306;
  #[doc = "`GL_DYNAMIC_COPY: GLenum = 0x88EA`"]
  #[doc = "* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_DYNAMIC_COPY: GLenum = 0x88EA;
  #[doc = "`GL_DYNAMIC_DRAW: GLenum = 0x88E8`"]
  #[doc = "* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_DYNAMIC_DRAW: GLenum = 0x88E8;
  #[doc = "`GL_DYNAMIC_READ: GLenum = 0x88E9`"]
  #[doc = "* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_DYNAMIC_READ: GLenum = 0x88E9;
  #[doc = "`GL_ELEMENT_ARRAY_BUFFER: GLenum = 0x8893`"]
  #[doc = "* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_ELEMENT_ARRAY_BUFFER: GLenum = 0x8893;
  #[doc = "`GL_ELEMENT_ARRAY_BUFFER_BINDING: GLenum = 0x8895`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_ELEMENT_ARRAY_BUFFER_BINDING: GLenum = 0x8895;
  #[doc = "`GL_EQUAL: GLenum = 0x0202`"]
  #[doc = "* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_EQUAL: GLenum = 0x0202;
  #[doc = "`GL_EQUIV: GLenum = 0x1509`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_EQUIV: GLenum = 0x1509;
  #[doc = "`GL_EXTENSIONS: GLenum = 0x1F03`"]
  #[doc = "* **Group:** StringName"]
  pub const GL_EXTENSIONS: GLenum = 0x1F03;
  #[doc = "`GL_FALSE: GLenum = 0`"]
  #[doc = "* **Groups:** Boolean, VertexShaderWriteMaskEXT, ClampColorModeARB"]
  pub const GL_FALSE: GLenum = 0;
  #[doc = "`GL_FASTEST: GLenum = 0x1101`"]
  #[doc = "* **Group:** HintMode"]
  pub const GL_FASTEST: GLenum = 0x1101;
  #[doc = "`GL_FILL: GLenum = 0x1B02`"]
  #[doc = "* **Groups:** PolygonMode, MeshMode2"]
  pub const GL_FILL: GLenum = 0x1B02;
  #[doc = "`GL_FIRST_VERTEX_CONVENTION: GLenum = 0x8E4D`"]
  #[doc = "* **Group:** VertexProvokingMode"]
  pub const GL_FIRST_VERTEX_CONVENTION: GLenum = 0x8E4D;
  #[doc = "`GL_FIXED_ONLY: GLenum = 0x891D`"]
  #[doc = "* **Group:** ClampColorModeARB"]
  pub const GL_FIXED_ONLY: GLenum = 0x891D;
  #[doc = "`GL_FLOAT: GLenum = 0x1406`"]
  #[doc = "* **Groups:** GlslTypeToken, MapTypeNV, SecondaryColorPointerTypeIBM, WeightPointerTypeARB, VertexWeightPointerTypeEXT, TangentPointerTypeEXT, BinormalPointerTypeEXT, FogCoordinatePointerType, FogPointerTypeEXT, FogPointerTypeIBM, IndexPointerType, ListNameType, NormalPointerType, PixelType, TexCoordPointerType, VertexPointerType, VertexAttribType, AttributeType, UniformType, VertexAttribPointerType"]
  pub const GL_FLOAT: GLenum = 0x1406;
  #[doc = "`GL_FLOAT_32_UNSIGNED_INT_24_8_REV: GLenum = 0x8DAD`"]
  pub const GL_FLOAT_32_UNSIGNED_INT_24_8_REV: GLenum = 0x8DAD;
  #[doc = "`GL_FLOAT_MAT2: GLenum = 0x8B5A`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT2: GLenum = 0x8B5A;
  #[doc = "`GL_FLOAT_MAT2x3: GLenum = 0x8B65`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT2x3: GLenum = 0x8B65;
  #[doc = "`GL_FLOAT_MAT2x4: GLenum = 0x8B66`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT2x4: GLenum = 0x8B66;
  #[doc = "`GL_FLOAT_MAT3: GLenum = 0x8B5B`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT3: GLenum = 0x8B5B;
  #[doc = "`GL_FLOAT_MAT3x2: GLenum = 0x8B67`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT3x2: GLenum = 0x8B67;
  #[doc = "`GL_FLOAT_MAT3x4: GLenum = 0x8B68`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT3x4: GLenum = 0x8B68;
  #[doc = "`GL_FLOAT_MAT4: GLenum = 0x8B5C`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT4: GLenum = 0x8B5C;
  #[doc = "`GL_FLOAT_MAT4x2: GLenum = 0x8B69`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT4x2: GLenum = 0x8B69;
  #[doc = "`GL_FLOAT_MAT4x3: GLenum = 0x8B6A`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT4x3: GLenum = 0x8B6A;
  #[doc = "`GL_FLOAT_VEC2: GLenum = 0x8B50`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_VEC2: GLenum = 0x8B50;
  #[doc = "`GL_FLOAT_VEC3: GLenum = 0x8B51`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_VEC3: GLenum = 0x8B51;
  #[doc = "`GL_FLOAT_VEC4: GLenum = 0x8B52`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_VEC4: GLenum = 0x8B52;
  #[doc = "`GL_FRAGMENT_SHADER: GLenum = 0x8B30`"]
  #[doc = "* **Groups:** PipelineParameterName, ShaderType"]
  pub const GL_FRAGMENT_SHADER: GLenum = 0x8B30;
  #[doc = "`GL_FRAGMENT_SHADER_DERIVATIVE_HINT: GLenum = 0x8B8B`"]
  #[doc = "* **Groups:** HintTarget, GetPName"]
  pub const GL_FRAGMENT_SHADER_DERIVATIVE_HINT: GLenum = 0x8B8B;
  #[doc = "`GL_FRAMEBUFFER: GLenum = 0x8D40`"]
  #[doc = "* **Groups:** ObjectIdentifier, FramebufferTarget, CheckFramebufferStatusTarget"]
  pub const GL_FRAMEBUFFER: GLenum = 0x8D40;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: GLenum = 0x8215`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: GLenum = 0x8215;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: GLenum = 0x8214`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: GLenum = 0x8214;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: GLenum = 0x8210`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: GLenum = 0x8210;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: GLenum = 0x8211`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: GLenum = 0x8211;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: GLenum = 0x8216`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: GLenum = 0x8216;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: GLenum = 0x8213`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: GLenum = 0x8213;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_LAYERED: GLenum = 0x8DA7`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_LAYERED: GLenum = 0x8DA7;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum = 0x8CD1`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum = 0x8CD1;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum = 0x8CD0`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum = 0x8CD0;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE: GLenum = 0x8212`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE: GLenum = 0x8212;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: GLenum = 0x8217`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: GLenum = 0x8217;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum = 0x8CD3`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum = 0x8CD3;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: GLenum = 0x8CD4`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: GLenum = 0x8CD4;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum = 0x8CD2`"]
  #[doc = "* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum = 0x8CD2;
  #[doc = "`GL_FRAMEBUFFER_BINDING: GLenum = 0x8CA6`"]
  pub const GL_FRAMEBUFFER_BINDING: GLenum = 0x8CA6;
  #[doc = "`GL_FRAMEBUFFER_COMPLETE: GLenum = 0x8CD5`"]
  #[doc = "* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_COMPLETE: GLenum = 0x8CD5;
  #[doc = "`GL_FRAMEBUFFER_DEFAULT: GLenum = 0x8218`"]
  pub const GL_FRAMEBUFFER_DEFAULT: GLenum = 0x8218;
  #[doc = "`GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum = 0x8CD6`"]
  #[doc = "* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum = 0x8CD6;
  #[doc = "`GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: GLenum = 0x8CDB`"]
  #[doc = "* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: GLenum = 0x8CDB;
  #[doc = "`GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: GLenum = 0x8DA8`"]
  #[doc = "* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: GLenum = 0x8DA8;
  #[doc = "`GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum = 0x8CD7`"]
  #[doc = "* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum = 0x8CD7;
  #[doc = "`GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: GLenum = 0x8D56`"]
  #[doc = "* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: GLenum = 0x8D56;
  #[doc = "`GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER: GLenum = 0x8CDC`"]
  #[doc = "* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER: GLenum = 0x8CDC;
  #[doc = "`GL_FRAMEBUFFER_SRGB: GLenum = 0x8DB9`"]
  #[doc = "* **Group:** EnableCap"]
  pub const GL_FRAMEBUFFER_SRGB: GLenum = 0x8DB9;
  #[doc = "`GL_FRAMEBUFFER_UNDEFINED: GLenum = 0x8219`"]
  #[doc = "* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_UNDEFINED: GLenum = 0x8219;
  #[doc = "`GL_FRAMEBUFFER_UNSUPPORTED: GLenum = 0x8CDD`"]
  #[doc = "* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_UNSUPPORTED: GLenum = 0x8CDD;
  #[doc = "`GL_FRONT: GLenum = 0x0404`"]
  #[doc = "* **Groups:** ColorBuffer, ColorMaterialFace, CullFaceMode, DrawBufferMode, ReadBufferMode, StencilFaceDirection, MaterialFace"]
  pub const GL_FRONT: GLenum = 0x0404;
  #[doc = "`GL_FRONT_AND_BACK: GLenum = 0x0408`"]
  #[doc = "* **Groups:** ColorBuffer, ColorMaterialFace, CullFaceMode, DrawBufferMode, StencilFaceDirection, MaterialFace"]
  pub const GL_FRONT_AND_BACK: GLenum = 0x0408;
  #[doc = "`GL_FRONT_FACE: GLenum = 0x0B46`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_FRONT_FACE: GLenum = 0x0B46;
  #[doc = "`GL_FRONT_LEFT: GLenum = 0x0400`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode"]
  pub const GL_FRONT_LEFT: GLenum = 0x0400;
  #[doc = "`GL_FRONT_RIGHT: GLenum = 0x0401`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode"]
  pub const GL_FRONT_RIGHT: GLenum = 0x0401;
  #[doc = "`GL_FUNC_ADD: GLenum = 0x8006`"]
  #[doc = "* **Group:** BlendEquationModeEXT"]
  pub const GL_FUNC_ADD: GLenum = 0x8006;
  #[doc = "`GL_FUNC_REVERSE_SUBTRACT: GLenum = 0x800B`"]
  #[doc = "* **Group:** BlendEquationModeEXT"]
  pub const GL_FUNC_REVERSE_SUBTRACT: GLenum = 0x800B;
  #[doc = "`GL_FUNC_SUBTRACT: GLenum = 0x800A`"]
  #[doc = "* **Group:** BlendEquationModeEXT"]
  pub const GL_FUNC_SUBTRACT: GLenum = 0x800A;
  #[doc = "`GL_GEOMETRY_INPUT_TYPE: GLenum = 0x8917`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_GEOMETRY_INPUT_TYPE: GLenum = 0x8917;
  #[doc = "`GL_GEOMETRY_OUTPUT_TYPE: GLenum = 0x8918`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_GEOMETRY_OUTPUT_TYPE: GLenum = 0x8918;
  #[doc = "`GL_GEOMETRY_SHADER: GLenum = 0x8DD9`"]
  #[doc = "* **Groups:** PipelineParameterName, ShaderType"]
  pub const GL_GEOMETRY_SHADER: GLenum = 0x8DD9;
  #[doc = "`GL_GEOMETRY_VERTICES_OUT: GLenum = 0x8916`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_GEOMETRY_VERTICES_OUT: GLenum = 0x8916;
  #[doc = "`GL_GEQUAL: GLenum = 0x0206`"]
  #[doc = "* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_GEQUAL: GLenum = 0x0206;
  #[doc = "`GL_GREATER: GLenum = 0x0204`"]
  #[doc = "* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_GREATER: GLenum = 0x0204;
  #[doc = "`GL_GREEN: GLenum = 0x1904`"]
  #[doc = "* **Groups:** TextureSwizzle, PixelFormat"]
  pub const GL_GREEN: GLenum = 0x1904;
  #[doc = "`GL_GREEN_INTEGER: GLenum = 0x8D95`"]
  #[doc = "* **Group:** PixelFormat"]
  pub const GL_GREEN_INTEGER: GLenum = 0x8D95;
  #[doc = "`GL_HALF_FLOAT: GLenum = 0x140B`"]
  #[doc = "* **Groups:** VertexAttribPointerType, VertexAttribType"]
  pub const GL_HALF_FLOAT: GLenum = 0x140B;
  #[doc = "`GL_INCR: GLenum = 0x1E02`"]
  #[doc = "* **Group:** StencilOp"]
  pub const GL_INCR: GLenum = 0x1E02;
  #[doc = "`GL_INCR_WRAP: GLenum = 0x8507`"]
  #[doc = "* **Group:** StencilOp"]
  pub const GL_INCR_WRAP: GLenum = 0x8507;
  #[doc = "`GL_INFO_LOG_LENGTH: GLenum = 0x8B84`"]
  #[doc = "* **Groups:** ProgramPropertyARB, ShaderParameterName, PipelineParameterName"]
  pub const GL_INFO_LOG_LENGTH: GLenum = 0x8B84;
  #[doc = "`GL_INT: GLenum = 0x1404`"]
  #[doc = "* **Groups:** VertexAttribIType, SecondaryColorPointerTypeIBM, WeightPointerTypeARB, TangentPointerTypeEXT, BinormalPointerTypeEXT, IndexPointerType, ListNameType, NormalPointerType, PixelType, TexCoordPointerType, VertexPointerType, VertexAttribType, AttributeType, UniformType, VertexAttribPointerType, GlslTypeToken"]
  pub const GL_INT: GLenum = 0x1404;
  #[doc = "`GL_INTERLEAVED_ATTRIBS: GLenum = 0x8C8C`"]
  #[doc = "* **Group:** TransformFeedbackBufferMode"]
  pub const GL_INTERLEAVED_ATTRIBS: GLenum = 0x8C8C;
  #[doc = "`GL_INT_2_10_10_10_REV: GLenum = 0x8D9F`"]
  #[doc = "* **Groups:** VertexAttribPointerType, VertexAttribType"]
  pub const GL_INT_2_10_10_10_REV: GLenum = 0x8D9F;
  #[doc = "`GL_INT_SAMPLER_1D: GLenum = 0x8DC9`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_1D: GLenum = 0x8DC9;
  #[doc = "`GL_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DCE`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DCE;
  #[doc = "`GL_INT_SAMPLER_2D: GLenum = 0x8DCA`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_2D: GLenum = 0x8DCA;
  #[doc = "`GL_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DCF`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DCF;
  #[doc = "`GL_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9109`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9109;
  #[doc = "`GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910C`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910C;
  #[doc = "`GL_INT_SAMPLER_2D_RECT: GLenum = 0x8DCD`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_2D_RECT: GLenum = 0x8DCD;
  #[doc = "`GL_INT_SAMPLER_3D: GLenum = 0x8DCB`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_3D: GLenum = 0x8DCB;
  #[doc = "`GL_INT_SAMPLER_BUFFER: GLenum = 0x8DD0`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_BUFFER: GLenum = 0x8DD0;
  #[doc = "`GL_INT_SAMPLER_CUBE: GLenum = 0x8DCC`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_CUBE: GLenum = 0x8DCC;
  #[doc = "`GL_INT_VEC2: GLenum = 0x8B53`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_VEC2: GLenum = 0x8B53;
  #[doc = "`GL_INT_VEC3: GLenum = 0x8B54`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_VEC3: GLenum = 0x8B54;
  #[doc = "`GL_INT_VEC4: GLenum = 0x8B55`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_VEC4: GLenum = 0x8B55;
  #[doc = "`GL_INVALID_ENUM: GLenum = 0x0500`"]
  #[doc = "* **Group:** ErrorCode"]
  pub const GL_INVALID_ENUM: GLenum = 0x0500;
  #[doc = "`GL_INVALID_FRAMEBUFFER_OPERATION: GLenum = 0x0506`"]
  #[doc = "* **Group:** ErrorCode"]
  pub const GL_INVALID_FRAMEBUFFER_OPERATION: GLenum = 0x0506;
  #[doc = "`GL_INVALID_INDEX: GLenum = 0xFFFFFFFF`"]
  pub const GL_INVALID_INDEX: GLenum = 0xFFFFFFFF;
  #[doc = "`GL_INVALID_OPERATION: GLenum = 0x0502`"]
  #[doc = "* **Group:** ErrorCode"]
  pub const GL_INVALID_OPERATION: GLenum = 0x0502;
  #[doc = "`GL_INVALID_VALUE: GLenum = 0x0501`"]
  #[doc = "* **Group:** ErrorCode"]
  pub const GL_INVALID_VALUE: GLenum = 0x0501;
  #[doc = "`GL_INVERT: GLenum = 0x150A`"]
  #[doc = "* **Groups:** PathFillMode, LogicOp, StencilOp"]
  pub const GL_INVERT: GLenum = 0x150A;
  #[doc = "`GL_KEEP: GLenum = 0x1E00`"]
  #[doc = "* **Group:** StencilOp"]
  pub const GL_KEEP: GLenum = 0x1E00;
  #[doc = "`GL_LAST_VERTEX_CONVENTION: GLenum = 0x8E4E`"]
  #[doc = "* **Group:** VertexProvokingMode"]
  pub const GL_LAST_VERTEX_CONVENTION: GLenum = 0x8E4E;
  #[doc = "`GL_LEFT: GLenum = 0x0406`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode"]
  pub const GL_LEFT: GLenum = 0x0406;
  #[doc = "`GL_LEQUAL: GLenum = 0x0203`"]
  #[doc = "* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_LEQUAL: GLenum = 0x0203;
  #[doc = "`GL_LESS: GLenum = 0x0201`"]
  #[doc = "* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_LESS: GLenum = 0x0201;
  #[doc = "`GL_LINE: GLenum = 0x1B01`"]
  #[doc = "* **Groups:** PolygonMode, MeshMode1, MeshMode2"]
  pub const GL_LINE: GLenum = 0x1B01;
  #[doc = "`GL_LINEAR: GLenum = 0x2601`"]
  #[doc = "* **Groups:** BlitFramebufferFilter, FogMode, TextureMagFilter, TextureMinFilter"]
  pub const GL_LINEAR: GLenum = 0x2601;
  #[doc = "`GL_LINEAR_MIPMAP_LINEAR: GLenum = 0x2703`"]
  #[doc = "* **Groups:** TextureWrapMode, TextureMinFilter"]
  pub const GL_LINEAR_MIPMAP_LINEAR: GLenum = 0x2703;
  #[doc = "`GL_LINEAR_MIPMAP_NEAREST: GLenum = 0x2701`"]
  #[doc = "* **Group:** TextureMinFilter"]
  pub const GL_LINEAR_MIPMAP_NEAREST: GLenum = 0x2701;
  #[doc = "`GL_LINES: GLenum = 0x0001`"]
  #[doc = "* **Group:** PrimitiveType"]
  pub const GL_LINES: GLenum = 0x0001;
  #[doc = "`GL_LINES_ADJACENCY: GLenum = 0x000A`"]
  #[doc = "* **Group:** PrimitiveType"]
  pub const GL_LINES_ADJACENCY: GLenum = 0x000A;
  #[doc = "`GL_LINE_LOOP: GLenum = 0x0002`"]
  #[doc = "* **Group:** PrimitiveType"]
  pub const GL_LINE_LOOP: GLenum = 0x0002;
  #[doc = "`GL_LINE_SMOOTH: GLenum = 0x0B20`"]
  #[doc = "* **Groups:** GetPName, EnableCap"]
  pub const GL_LINE_SMOOTH: GLenum = 0x0B20;
  #[doc = "`GL_LINE_SMOOTH_HINT: GLenum = 0x0C52`"]
  #[doc = "* **Groups:** HintTarget, GetPName"]
  pub const GL_LINE_SMOOTH_HINT: GLenum = 0x0C52;
  #[doc = "`GL_LINE_STRIP: GLenum = 0x0003`"]
  #[doc = "* **Group:** PrimitiveType"]
  pub const GL_LINE_STRIP: GLenum = 0x0003;
  #[doc = "`GL_LINE_STRIP_ADJACENCY: GLenum = 0x000B`"]
  #[doc = "* **Group:** PrimitiveType"]
  pub const GL_LINE_STRIP_ADJACENCY: GLenum = 0x000B;
  #[doc = "`GL_LINE_WIDTH: GLenum = 0x0B21`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_LINE_WIDTH: GLenum = 0x0B21;
  #[doc = "`GL_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23;
  #[doc = "`GL_LINE_WIDTH_RANGE: GLenum = 0x0B22`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_LINE_WIDTH_RANGE: GLenum = 0x0B22;
  #[doc = "`GL_LINK_STATUS: GLenum = 0x8B82`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_LINK_STATUS: GLenum = 0x8B82;
  #[doc = "`GL_LOGIC_OP_MODE: GLenum = 0x0BF0`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_LOGIC_OP_MODE: GLenum = 0x0BF0;
  #[doc = "`GL_LOWER_LEFT: GLenum = 0x8CA1`"]
  #[doc = "* **Group:** ClipControlOrigin"]
  pub const GL_LOWER_LEFT: GLenum = 0x8CA1;
  #[doc = "`GL_MAJOR_VERSION: GLenum = 0x821B`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAJOR_VERSION: GLenum = 0x821B;
  #[doc = "`GL_MAP_FLUSH_EXPLICIT_BIT: GLbitfield = 0x0010`"]
  #[doc = "* **Group:** MapBufferAccessMask"]
  pub const GL_MAP_FLUSH_EXPLICIT_BIT: GLbitfield = 0x0010;
  #[doc = "`GL_MAP_INVALIDATE_BUFFER_BIT: GLbitfield = 0x0008`"]
  #[doc = "* **Group:** MapBufferAccessMask"]
  pub const GL_MAP_INVALIDATE_BUFFER_BIT: GLbitfield = 0x0008;
  #[doc = "`GL_MAP_INVALIDATE_RANGE_BIT: GLbitfield = 0x0004`"]
  #[doc = "* **Group:** MapBufferAccessMask"]
  pub const GL_MAP_INVALIDATE_RANGE_BIT: GLbitfield = 0x0004;
  #[doc = "`GL_MAP_READ_BIT: GLbitfield = 0x0001`"]
  #[doc = "* **Groups:** MapBufferAccessMask, BufferStorageMask"]
  pub const GL_MAP_READ_BIT: GLbitfield = 0x0001;
  #[doc = "`GL_MAP_UNSYNCHRONIZED_BIT: GLbitfield = 0x0020`"]
  #[doc = "* **Group:** MapBufferAccessMask"]
  pub const GL_MAP_UNSYNCHRONIZED_BIT: GLbitfield = 0x0020;
  #[doc = "`GL_MAP_WRITE_BIT: GLbitfield = 0x0002`"]
  #[doc = "* **Groups:** MapBufferAccessMask, BufferStorageMask"]
  pub const GL_MAP_WRITE_BIT: GLbitfield = 0x0002;
  #[doc = "`GL_MAX: GLenum = 0x8008`"]
  #[doc = "* **Group:** BlendEquationModeEXT"]
  pub const GL_MAX: GLenum = 0x8008;
  #[doc = "`GL_MAX_3D_TEXTURE_SIZE: GLenum = 0x8073`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_3D_TEXTURE_SIZE: GLenum = 0x8073;
  #[doc = "`GL_MAX_ARRAY_TEXTURE_LAYERS: GLenum = 0x88FF`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_ARRAY_TEXTURE_LAYERS: GLenum = 0x88FF;
  #[doc = "`GL_MAX_CLIP_DISTANCES: GLenum = 0x0D32`"]
  #[doc = "* **Group:** GetPName"]
  #[doc = "* **Alias Of:** `GL_MAX_CLIP_PLANES`"]
  pub const GL_MAX_CLIP_DISTANCES: GLenum = 0x0D32;
  #[doc = "`GL_MAX_COLOR_ATTACHMENTS: GLenum = 0x8CDF`"]
  pub const GL_MAX_COLOR_ATTACHMENTS: GLenum = 0x8CDF;
  #[doc = "`GL_MAX_COLOR_TEXTURE_SAMPLES: GLenum = 0x910E`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_COLOR_TEXTURE_SAMPLES: GLenum = 0x910E;
  #[doc = "`GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8A33`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8A33;
  #[doc = "`GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8A32`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8A32;
  #[doc = "`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4D`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4D;
  #[doc = "`GL_MAX_COMBINED_UNIFORM_BLOCKS: GLenum = 0x8A2E`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_UNIFORM_BLOCKS: GLenum = 0x8A2E;
  #[doc = "`GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8A31`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8A31;
  #[doc = "`GL_MAX_CUBE_MAP_TEXTURE_SIZE: GLenum = 0x851C`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_CUBE_MAP_TEXTURE_SIZE: GLenum = 0x851C;
  #[doc = "`GL_MAX_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826C`"]
  #[doc = "* **Group:** GetPName"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_MAX_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826C;
  #[doc = "`GL_MAX_DEBUG_LOGGED_MESSAGES: GLenum = 0x9144`"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_MAX_DEBUG_LOGGED_MESSAGES: GLenum = 0x9144;
  #[doc = "`GL_MAX_DEBUG_LOGGED_MESSAGES_ARB: GLenum = 0x9144`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_MAX_DEBUG_LOGGED_MESSAGES_ARB: GLenum = 0x9144;
  #[doc = "`GL_MAX_DEBUG_MESSAGE_LENGTH: GLenum = 0x9143`"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_MAX_DEBUG_MESSAGE_LENGTH: GLenum = 0x9143;
  #[doc = "`GL_MAX_DEBUG_MESSAGE_LENGTH_ARB: GLenum = 0x9143`"]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub const GL_MAX_DEBUG_MESSAGE_LENGTH_ARB: GLenum = 0x9143;
  #[doc = "`GL_MAX_DEPTH_TEXTURE_SAMPLES: GLenum = 0x910F`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_DEPTH_TEXTURE_SAMPLES: GLenum = 0x910F;
  #[doc = "`GL_MAX_DRAW_BUFFERS: GLenum = 0x8824`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_DRAW_BUFFERS: GLenum = 0x8824;
  #[doc = "`GL_MAX_DUAL_SOURCE_DRAW_BUFFERS: GLenum = 0x88FC`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_DUAL_SOURCE_DRAW_BUFFERS: GLenum = 0x88FC;
  #[doc = "`GL_MAX_ELEMENTS_INDICES: GLenum = 0x80E9`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_ELEMENTS_INDICES: GLenum = 0x80E9;
  #[doc = "`GL_MAX_ELEMENTS_VERTICES: GLenum = 0x80E8`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_ELEMENTS_VERTICES: GLenum = 0x80E8;
  #[doc = "`GL_MAX_FRAGMENT_INPUT_COMPONENTS: GLenum = 0x9125`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_FRAGMENT_INPUT_COMPONENTS: GLenum = 0x9125;
  #[doc = "`GL_MAX_FRAGMENT_UNIFORM_BLOCKS: GLenum = 0x8A2D`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_FRAGMENT_UNIFORM_BLOCKS: GLenum = 0x8A2D;
  #[doc = "`GL_MAX_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8B49`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8B49;
  #[doc = "`GL_MAX_GEOMETRY_INPUT_COMPONENTS: GLenum = 0x9123`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_GEOMETRY_INPUT_COMPONENTS: GLenum = 0x9123;
  #[doc = "`GL_MAX_GEOMETRY_OUTPUT_COMPONENTS: GLenum = 0x9124`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_GEOMETRY_OUTPUT_COMPONENTS: GLenum = 0x9124;
  #[doc = "`GL_MAX_GEOMETRY_OUTPUT_VERTICES: GLenum = 0x8DE0`"]
  pub const GL_MAX_GEOMETRY_OUTPUT_VERTICES: GLenum = 0x8DE0;
  #[doc = "`GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: GLenum = 0x8C29`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: GLenum = 0x8C29;
  #[doc = "`GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: GLenum = 0x8DE1`"]
  pub const GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: GLenum = 0x8DE1;
  #[doc = "`GL_MAX_GEOMETRY_UNIFORM_BLOCKS: GLenum = 0x8A2C`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_GEOMETRY_UNIFORM_BLOCKS: GLenum = 0x8A2C;
  #[doc = "`GL_MAX_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8DDF`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8DDF;
  #[doc = "`GL_MAX_INTEGER_SAMPLES: GLenum = 0x9110`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_INTEGER_SAMPLES: GLenum = 0x9110;
  #[doc = "`GL_MAX_LABEL_LENGTH: GLenum = 0x82E8`"]
  #[doc = "* **Group:** GetPName"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_MAX_LABEL_LENGTH: GLenum = 0x82E8;
  #[doc = "`GL_MAX_PROGRAM_TEXEL_OFFSET: GLenum = 0x8905`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_PROGRAM_TEXEL_OFFSET: GLenum = 0x8905;
  #[doc = "`GL_MAX_RECTANGLE_TEXTURE_SIZE: GLenum = 0x84F8`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_RECTANGLE_TEXTURE_SIZE: GLenum = 0x84F8;
  #[doc = "`GL_MAX_RENDERBUFFER_SIZE: GLenum = 0x84E8`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_RENDERBUFFER_SIZE: GLenum = 0x84E8;
  #[doc = "`GL_MAX_SAMPLES: GLenum = 0x8D57`"]
  pub const GL_MAX_SAMPLES: GLenum = 0x8D57;
  #[doc = "`GL_MAX_SAMPLE_MASK_WORDS: GLenum = 0x8E59`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_SAMPLE_MASK_WORDS: GLenum = 0x8E59;
  #[doc = "`GL_MAX_SERVER_WAIT_TIMEOUT: GLenum = 0x9111`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_SERVER_WAIT_TIMEOUT: GLenum = 0x9111;
  #[doc = "`GL_MAX_TEXTURE_BUFFER_SIZE: GLenum = 0x8C2B`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_TEXTURE_BUFFER_SIZE: GLenum = 0x8C2B;
  #[doc = "`GL_MAX_TEXTURE_IMAGE_UNITS: GLenum = 0x8872`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_TEXTURE_IMAGE_UNITS: GLenum = 0x8872;
  #[doc = "`GL_MAX_TEXTURE_LOD_BIAS: GLenum = 0x84FD`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_TEXTURE_LOD_BIAS: GLenum = 0x84FD;
  #[doc = "`GL_MAX_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FF`"]
  #[cfg(any(feature = "GL_ARB_texture_filter_anisotropic"))]
  #[cfg_attr(
    docs_rs,
    doc(cfg(any(feature = "GL_ARB_texture_filter_anisotropic")))
  )]
  pub const GL_MAX_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FF;
  #[doc = "`GL_MAX_TEXTURE_SIZE: GLenum = 0x0D33`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_TEXTURE_SIZE: GLenum = 0x0D33;
  #[doc = "`GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: GLenum = 0x8C8A`"]
  pub const GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: GLenum = 0x8C8A;
  #[doc = "`GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: GLenum = 0x8C8B`"]
  pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: GLenum = 0x8C8B;
  #[doc = "`GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: GLenum = 0x8C80`"]
  pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: GLenum = 0x8C80;
  #[doc = "`GL_MAX_UNIFORM_BLOCK_SIZE: GLenum = 0x8A30`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_UNIFORM_BLOCK_SIZE: GLenum = 0x8A30;
  #[doc = "`GL_MAX_UNIFORM_BUFFER_BINDINGS: GLenum = 0x8A2F`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_UNIFORM_BUFFER_BINDINGS: GLenum = 0x8A2F;
  #[doc = "`GL_MAX_VARYING_COMPONENTS: GLenum = 0x8B4B`"]
  #[doc = "* **Group:** GetPName"]
  #[doc = "* **Alias Of:** `MAX_VARYING_FLOATS`"]
  pub const GL_MAX_VARYING_COMPONENTS: GLenum = 0x8B4B;
  #[doc = "`GL_MAX_VARYING_FLOATS: GLenum = 0x8B4B`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_VARYING_FLOATS: GLenum = 0x8B4B;
  #[doc = "`GL_MAX_VERTEX_ATTRIBS: GLenum = 0x8869`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_ATTRIBS: GLenum = 0x8869;
  #[doc = "`GL_MAX_VERTEX_OUTPUT_COMPONENTS: GLenum = 0x9122`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_OUTPUT_COMPONENTS: GLenum = 0x9122;
  #[doc = "`GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4C`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4C;
  #[doc = "`GL_MAX_VERTEX_UNIFORM_BLOCKS: GLenum = 0x8A2B`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_UNIFORM_BLOCKS: GLenum = 0x8A2B;
  #[doc = "`GL_MAX_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8B4A`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8B4A;
  #[doc = "`GL_MAX_VIEWPORT_DIMS: GLenum = 0x0D3A`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MAX_VIEWPORT_DIMS: GLenum = 0x0D3A;
  #[doc = "`GL_MIN: GLenum = 0x8007`"]
  #[doc = "* **Group:** BlendEquationModeEXT"]
  pub const GL_MIN: GLenum = 0x8007;
  #[doc = "`GL_MINOR_VERSION: GLenum = 0x821C`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MINOR_VERSION: GLenum = 0x821C;
  #[doc = "`GL_MIN_PROGRAM_TEXEL_OFFSET: GLenum = 0x8904`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_MIN_PROGRAM_TEXEL_OFFSET: GLenum = 0x8904;
  #[doc = "`GL_MIRRORED_REPEAT: GLenum = 0x8370`"]
  #[doc = "* **Group:** TextureWrapMode"]
  pub const GL_MIRRORED_REPEAT: GLenum = 0x8370;
  #[doc = "`GL_MULTISAMPLE: GLenum = 0x809D`"]
  #[doc = "* **Group:** EnableCap"]
  pub const GL_MULTISAMPLE: GLenum = 0x809D;
  #[doc = "`GL_NAND: GLenum = 0x150E`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_NAND: GLenum = 0x150E;
  #[doc = "`GL_NEAREST: GLenum = 0x2600`"]
  #[doc = "* **Groups:** BlitFramebufferFilter, TextureMagFilter, TextureMinFilter"]
  pub const GL_NEAREST: GLenum = 0x2600;
  #[doc = "`GL_NEAREST_MIPMAP_LINEAR: GLenum = 0x2702`"]
  #[doc = "* **Group:** TextureMinFilter"]
  pub const GL_NEAREST_MIPMAP_LINEAR: GLenum = 0x2702;
  #[doc = "`GL_NEAREST_MIPMAP_NEAREST: GLenum = 0x2700`"]
  #[doc = "* **Group:** TextureMinFilter"]
  pub const GL_NEAREST_MIPMAP_NEAREST: GLenum = 0x2700;
  #[doc = "`GL_NEVER: GLenum = 0x0200`"]
  #[doc = "* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_NEVER: GLenum = 0x0200;
  #[doc = "`GL_NICEST: GLenum = 0x1102`"]
  #[doc = "* **Group:** HintMode"]
  pub const GL_NICEST: GLenum = 0x1102;
  #[doc = "`GL_NONE: GLenum = 0`"]
  #[doc = "* **Groups:** TextureCompareMode, PathColorFormat, CombinerBiasNV, CombinerScaleNV, DrawBufferMode, PixelTexGenMode, ReadBufferMode, ColorBuffer, PathGenMode, PathTransformType, PathFontStyle"]
  pub const GL_NONE: GLenum = 0;
  #[doc = "`GL_NOOP: GLenum = 0x1505`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_NOOP: GLenum = 0x1505;
  #[doc = "`GL_NOR: GLenum = 0x1508`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_NOR: GLenum = 0x1508;
  #[doc = "`GL_NOTEQUAL: GLenum = 0x0205`"]
  #[doc = "* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_NOTEQUAL: GLenum = 0x0205;
  #[doc = "`GL_NO_ERROR: GLenum = 0`"]
  #[doc = "* **Groups:** GraphicsResetStatus, ErrorCode"]
  pub const GL_NO_ERROR: GLenum = 0;
  #[doc = "`GL_NUM_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A2`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_NUM_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A2;
  #[doc = "`GL_NUM_EXTENSIONS: GLenum = 0x821D`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_NUM_EXTENSIONS: GLenum = 0x821D;
  #[doc = "`GL_OBJECT_TYPE: GLenum = 0x9112`"]
  #[doc = "* **Group:** SyncParameterName"]
  pub const GL_OBJECT_TYPE: GLenum = 0x9112;
  #[doc = "`GL_ONE: GLenum = 1`"]
  #[doc = "* **Groups:** TextureSwizzle, BlendingFactor"]
  pub const GL_ONE: GLenum = 1;
  #[doc = "`GL_ONE_MINUS_CONSTANT_ALPHA: GLenum = 0x8004`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_CONSTANT_ALPHA: GLenum = 0x8004;
  #[doc = "`GL_ONE_MINUS_CONSTANT_COLOR: GLenum = 0x8002`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_CONSTANT_COLOR: GLenum = 0x8002;
  #[doc = "`GL_ONE_MINUS_DST_ALPHA: GLenum = 0x0305`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_DST_ALPHA: GLenum = 0x0305;
  #[doc = "`GL_ONE_MINUS_DST_COLOR: GLenum = 0x0307`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_DST_COLOR: GLenum = 0x0307;
  #[doc = "`GL_ONE_MINUS_SRC1_ALPHA: GLenum = 0x88FB`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_SRC1_ALPHA: GLenum = 0x88FB;
  #[doc = "`GL_ONE_MINUS_SRC1_COLOR: GLenum = 0x88FA`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_SRC1_COLOR: GLenum = 0x88FA;
  #[doc = "`GL_ONE_MINUS_SRC_ALPHA: GLenum = 0x0303`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_SRC_ALPHA: GLenum = 0x0303;
  #[doc = "`GL_ONE_MINUS_SRC_COLOR: GLenum = 0x0301`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_SRC_COLOR: GLenum = 0x0301;
  #[doc = "`GL_OR: GLenum = 0x1507`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_OR: GLenum = 0x1507;
  #[doc = "`GL_OR_INVERTED: GLenum = 0x150D`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_OR_INVERTED: GLenum = 0x150D;
  #[doc = "`GL_OR_REVERSE: GLenum = 0x150B`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_OR_REVERSE: GLenum = 0x150B;
  #[doc = "`GL_OUT_OF_MEMORY: GLenum = 0x0505`"]
  #[doc = "* **Group:** ErrorCode"]
  pub const GL_OUT_OF_MEMORY: GLenum = 0x0505;
  #[doc = "`GL_PACK_ALIGNMENT: GLenum = 0x0D05`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_ALIGNMENT: GLenum = 0x0D05;
  #[doc = "`GL_PACK_IMAGE_HEIGHT: GLenum = 0x806C`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_IMAGE_HEIGHT: GLenum = 0x806C;
  #[doc = "`GL_PACK_LSB_FIRST: GLenum = 0x0D01`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_LSB_FIRST: GLenum = 0x0D01;
  #[doc = "`GL_PACK_ROW_LENGTH: GLenum = 0x0D02`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_ROW_LENGTH: GLenum = 0x0D02;
  #[doc = "`GL_PACK_SKIP_IMAGES: GLenum = 0x806B`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_SKIP_IMAGES: GLenum = 0x806B;
  #[doc = "`GL_PACK_SKIP_PIXELS: GLenum = 0x0D04`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_SKIP_PIXELS: GLenum = 0x0D04;
  #[doc = "`GL_PACK_SKIP_ROWS: GLenum = 0x0D03`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_SKIP_ROWS: GLenum = 0x0D03;
  #[doc = "`GL_PACK_SWAP_BYTES: GLenum = 0x0D00`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_SWAP_BYTES: GLenum = 0x0D00;
  #[doc = "`GL_PIXEL_PACK_BUFFER: GLenum = 0x88EB`"]
  #[doc = "* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_PIXEL_PACK_BUFFER: GLenum = 0x88EB;
  #[doc = "`GL_PIXEL_PACK_BUFFER_BINDING: GLenum = 0x88ED`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_PIXEL_PACK_BUFFER_BINDING: GLenum = 0x88ED;
  #[doc = "`GL_PIXEL_UNPACK_BUFFER: GLenum = 0x88EC`"]
  #[doc = "* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_PIXEL_UNPACK_BUFFER: GLenum = 0x88EC;
  #[doc = "`GL_PIXEL_UNPACK_BUFFER_BINDING: GLenum = 0x88EF`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_PIXEL_UNPACK_BUFFER_BINDING: GLenum = 0x88EF;
  #[doc = "`GL_POINT: GLenum = 0x1B00`"]
  #[doc = "* **Groups:** PolygonMode, MeshMode1, MeshMode2"]
  pub const GL_POINT: GLenum = 0x1B00;
  #[doc = "`GL_POINTS: GLenum = 0x0000`"]
  #[doc = "* **Group:** PrimitiveType"]
  pub const GL_POINTS: GLenum = 0x0000;
  #[doc = "`GL_POINT_FADE_THRESHOLD_SIZE: GLenum = 0x8128`"]
  #[doc = "* **Groups:** PointParameterNameSGIS, PointParameterNameARB, GetPName"]
  pub const GL_POINT_FADE_THRESHOLD_SIZE: GLenum = 0x8128;
  #[doc = "`GL_POINT_SIZE: GLenum = 0x0B11`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_POINT_SIZE: GLenum = 0x0B11;
  #[doc = "`GL_POINT_SIZE_GRANULARITY: GLenum = 0x0B13`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_POINT_SIZE_GRANULARITY: GLenum = 0x0B13;
  #[doc = "`GL_POINT_SIZE_RANGE: GLenum = 0x0B12`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_POINT_SIZE_RANGE: GLenum = 0x0B12;
  #[doc = "`GL_POINT_SPRITE_COORD_ORIGIN: GLenum = 0x8CA0`"]
  pub const GL_POINT_SPRITE_COORD_ORIGIN: GLenum = 0x8CA0;
  #[doc = "`GL_POLYGON_MODE: GLenum = 0x0B40`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_POLYGON_MODE: GLenum = 0x0B40;
  #[doc = "`GL_POLYGON_OFFSET_FACTOR: GLenum = 0x8038`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_POLYGON_OFFSET_FACTOR: GLenum = 0x8038;
  #[doc = "`GL_POLYGON_OFFSET_FILL: GLenum = 0x8037`"]
  #[doc = "* **Groups:** GetPName, EnableCap"]
  pub const GL_POLYGON_OFFSET_FILL: GLenum = 0x8037;
  #[doc = "`GL_POLYGON_OFFSET_LINE: GLenum = 0x2A02`"]
  #[doc = "* **Groups:** GetPName, EnableCap"]
  pub const GL_POLYGON_OFFSET_LINE: GLenum = 0x2A02;
  #[doc = "`GL_POLYGON_OFFSET_POINT: GLenum = 0x2A01`"]
  #[doc = "* **Groups:** GetPName, EnableCap"]
  pub const GL_POLYGON_OFFSET_POINT: GLenum = 0x2A01;
  #[doc = "`GL_POLYGON_OFFSET_UNITS: GLenum = 0x2A00`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_POLYGON_OFFSET_UNITS: GLenum = 0x2A00;
  #[doc = "`GL_POLYGON_SMOOTH: GLenum = 0x0B41`"]
  #[doc = "* **Groups:** GetPName, EnableCap"]
  pub const GL_POLYGON_SMOOTH: GLenum = 0x0B41;
  #[doc = "`GL_POLYGON_SMOOTH_HINT: GLenum = 0x0C53`"]
  #[doc = "* **Groups:** HintTarget, GetPName"]
  pub const GL_POLYGON_SMOOTH_HINT: GLenum = 0x0C53;
  #[doc = "`GL_PRIMITIVES_GENERATED: GLenum = 0x8C87`"]
  #[doc = "* **Group:** QueryTarget"]
  pub const GL_PRIMITIVES_GENERATED: GLenum = 0x8C87;
  #[doc = "`GL_PRIMITIVE_RESTART: GLenum = 0x8F9D`"]
  #[doc = "* **Group:** EnableCap"]
  pub const GL_PRIMITIVE_RESTART: GLenum = 0x8F9D;
  #[doc = "`GL_PRIMITIVE_RESTART_INDEX: GLenum = 0x8F9E`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_PRIMITIVE_RESTART_INDEX: GLenum = 0x8F9E;
  #[doc = "`GL_PROGRAM: GLenum = 0x82E2`"]
  #[doc = "* **Group:** ObjectIdentifier"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_PROGRAM: GLenum = 0x82E2;
  #[doc = "`GL_PROGRAM_PIPELINE: GLenum = 0x82E4`"]
  #[doc = "* **Group:** ObjectIdentifier"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_PROGRAM_PIPELINE: GLenum = 0x82E4;
  #[doc = "`GL_PROGRAM_POINT_SIZE: GLenum = 0x8642`"]
  #[doc = "* **Groups:** GetPName, EnableCap"]
  #[doc = "* **Alias Of:** `GL_VERTEX_PROGRAM_POINT_SIZE`"]
  pub const GL_PROGRAM_POINT_SIZE: GLenum = 0x8642;
  #[doc = "`GL_PROVOKING_VERTEX: GLenum = 0x8E4F`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_PROVOKING_VERTEX: GLenum = 0x8E4F;
  #[doc = "`GL_PROXY_TEXTURE_1D: GLenum = 0x8063`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_1D: GLenum = 0x8063;
  #[doc = "`GL_PROXY_TEXTURE_1D_ARRAY: GLenum = 0x8C19`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_1D_ARRAY: GLenum = 0x8C19;
  #[doc = "`GL_PROXY_TEXTURE_2D: GLenum = 0x8064`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_2D: GLenum = 0x8064;
  #[doc = "`GL_PROXY_TEXTURE_2D_ARRAY: GLenum = 0x8C1B`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_2D_ARRAY: GLenum = 0x8C1B;
  #[doc = "`GL_PROXY_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9101`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9101;
  #[doc = "`GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9103`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9103;
  #[doc = "`GL_PROXY_TEXTURE_3D: GLenum = 0x8070`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_3D: GLenum = 0x8070;
  #[doc = "`GL_PROXY_TEXTURE_CUBE_MAP: GLenum = 0x851B`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_CUBE_MAP: GLenum = 0x851B;
  #[doc = "`GL_PROXY_TEXTURE_RECTANGLE: GLenum = 0x84F7`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_RECTANGLE: GLenum = 0x84F7;
  #[doc = "`GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: GLenum = 0x8E4C`"]
  pub const GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: GLenum = 0x8E4C;
  #[doc = "`GL_QUERY: GLenum = 0x82E3`"]
  #[doc = "* **Group:** ObjectIdentifier"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_QUERY: GLenum = 0x82E3;
  #[doc = "`GL_QUERY_BY_REGION_NO_WAIT: GLenum = 0x8E16`"]
  #[doc = "* **Group:** ConditionalRenderMode"]
  pub const GL_QUERY_BY_REGION_NO_WAIT: GLenum = 0x8E16;
  #[doc = "`GL_QUERY_BY_REGION_WAIT: GLenum = 0x8E15`"]
  #[doc = "* **Group:** ConditionalRenderMode"]
  pub const GL_QUERY_BY_REGION_WAIT: GLenum = 0x8E15;
  #[doc = "`GL_QUERY_COUNTER_BITS: GLenum = 0x8864`"]
  #[doc = "* **Group:** QueryParameterName"]
  pub const GL_QUERY_COUNTER_BITS: GLenum = 0x8864;
  #[doc = "`GL_QUERY_NO_WAIT: GLenum = 0x8E14`"]
  #[doc = "* **Group:** ConditionalRenderMode"]
  pub const GL_QUERY_NO_WAIT: GLenum = 0x8E14;
  #[doc = "`GL_QUERY_RESULT: GLenum = 0x8866`"]
  #[doc = "* **Group:** QueryObjectParameterName"]
  pub const GL_QUERY_RESULT: GLenum = 0x8866;
  #[doc = "`GL_QUERY_RESULT_AVAILABLE: GLenum = 0x8867`"]
  #[doc = "* **Group:** QueryObjectParameterName"]
  pub const GL_QUERY_RESULT_AVAILABLE: GLenum = 0x8867;
  #[doc = "`GL_QUERY_WAIT: GLenum = 0x8E13`"]
  #[doc = "* **Group:** ConditionalRenderMode"]
  pub const GL_QUERY_WAIT: GLenum = 0x8E13;
  #[doc = "`GL_R11F_G11F_B10F: GLenum = 0x8C3A`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R11F_G11F_B10F: GLenum = 0x8C3A;
  #[doc = "`GL_R16: GLenum = 0x822A`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R16: GLenum = 0x822A;
  #[doc = "`GL_R16F: GLenum = 0x822D`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R16F: GLenum = 0x822D;
  #[doc = "`GL_R16I: GLenum = 0x8233`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R16I: GLenum = 0x8233;
  #[doc = "`GL_R16UI: GLenum = 0x8234`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R16UI: GLenum = 0x8234;
  #[doc = "`GL_R16_SNORM: GLenum = 0x8F98`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R16_SNORM: GLenum = 0x8F98;
  #[doc = "`GL_R32F: GLenum = 0x822E`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R32F: GLenum = 0x822E;
  #[doc = "`GL_R32I: GLenum = 0x8235`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R32I: GLenum = 0x8235;
  #[doc = "`GL_R32UI: GLenum = 0x8236`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R32UI: GLenum = 0x8236;
  #[doc = "`GL_R3_G3_B2: GLenum = 0x2A10`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R3_G3_B2: GLenum = 0x2A10;
  #[doc = "`GL_R8: GLenum = 0x8229`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R8: GLenum = 0x8229;
  #[doc = "`GL_R8I: GLenum = 0x8231`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R8I: GLenum = 0x8231;
  #[doc = "`GL_R8UI: GLenum = 0x8232`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R8UI: GLenum = 0x8232;
  #[doc = "`GL_R8_SNORM: GLenum = 0x8F94`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_R8_SNORM: GLenum = 0x8F94;
  #[doc = "`GL_RASTERIZER_DISCARD: GLenum = 0x8C89`"]
  #[doc = "* **Group:** EnableCap"]
  pub const GL_RASTERIZER_DISCARD: GLenum = 0x8C89;
  #[doc = "`GL_READ_BUFFER: GLenum = 0x0C02`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_READ_BUFFER: GLenum = 0x0C02;
  #[doc = "`GL_READ_FRAMEBUFFER: GLenum = 0x8CA8`"]
  #[doc = "* **Groups:** CheckFramebufferStatusTarget, FramebufferTarget"]
  pub const GL_READ_FRAMEBUFFER: GLenum = 0x8CA8;
  #[doc = "`GL_READ_FRAMEBUFFER_BINDING: GLenum = 0x8CAA`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_READ_FRAMEBUFFER_BINDING: GLenum = 0x8CAA;
  #[doc = "`GL_READ_ONLY: GLenum = 0x88B8`"]
  #[doc = "* **Group:** BufferAccessARB"]
  pub const GL_READ_ONLY: GLenum = 0x88B8;
  #[doc = "`GL_READ_WRITE: GLenum = 0x88BA`"]
  #[doc = "* **Group:** BufferAccessARB"]
  pub const GL_READ_WRITE: GLenum = 0x88BA;
  #[doc = "`GL_RED: GLenum = 0x1903`"]
  #[doc = "* **Groups:** TextureSwizzle, PixelFormat, InternalFormat"]
  pub const GL_RED: GLenum = 0x1903;
  #[doc = "`GL_RED_INTEGER: GLenum = 0x8D94`"]
  #[doc = "* **Group:** PixelFormat"]
  pub const GL_RED_INTEGER: GLenum = 0x8D94;
  #[doc = "`GL_RENDERBUFFER: GLenum = 0x8D41`"]
  #[doc = "* **Groups:** ObjectIdentifier, RenderbufferTarget, CopyImageSubDataTarget"]
  pub const GL_RENDERBUFFER: GLenum = 0x8D41;
  #[doc = "`GL_RENDERBUFFER_ALPHA_SIZE: GLenum = 0x8D53`"]
  #[doc = "* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_ALPHA_SIZE: GLenum = 0x8D53;
  #[doc = "`GL_RENDERBUFFER_BINDING: GLenum = 0x8CA7`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_RENDERBUFFER_BINDING: GLenum = 0x8CA7;
  #[doc = "`GL_RENDERBUFFER_BLUE_SIZE: GLenum = 0x8D52`"]
  #[doc = "* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_BLUE_SIZE: GLenum = 0x8D52;
  #[doc = "`GL_RENDERBUFFER_DEPTH_SIZE: GLenum = 0x8D54`"]
  #[doc = "* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_DEPTH_SIZE: GLenum = 0x8D54;
  #[doc = "`GL_RENDERBUFFER_GREEN_SIZE: GLenum = 0x8D51`"]
  #[doc = "* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_GREEN_SIZE: GLenum = 0x8D51;
  #[doc = "`GL_RENDERBUFFER_HEIGHT: GLenum = 0x8D43`"]
  #[doc = "* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_HEIGHT: GLenum = 0x8D43;
  #[doc = "`GL_RENDERBUFFER_INTERNAL_FORMAT: GLenum = 0x8D44`"]
  #[doc = "* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_INTERNAL_FORMAT: GLenum = 0x8D44;
  #[doc = "`GL_RENDERBUFFER_RED_SIZE: GLenum = 0x8D50`"]
  #[doc = "* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_RED_SIZE: GLenum = 0x8D50;
  #[doc = "`GL_RENDERBUFFER_SAMPLES: GLenum = 0x8CAB`"]
  #[doc = "* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_SAMPLES: GLenum = 0x8CAB;
  #[doc = "`GL_RENDERBUFFER_STENCIL_SIZE: GLenum = 0x8D55`"]
  #[doc = "* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_STENCIL_SIZE: GLenum = 0x8D55;
  #[doc = "`GL_RENDERBUFFER_WIDTH: GLenum = 0x8D42`"]
  #[doc = "* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_WIDTH: GLenum = 0x8D42;
  #[doc = "`GL_RENDERER: GLenum = 0x1F01`"]
  #[doc = "* **Group:** StringName"]
  pub const GL_RENDERER: GLenum = 0x1F01;
  #[doc = "`GL_REPEAT: GLenum = 0x2901`"]
  #[doc = "* **Group:** TextureWrapMode"]
  pub const GL_REPEAT: GLenum = 0x2901;
  #[doc = "`GL_REPLACE: GLenum = 0x1E01`"]
  #[doc = "* **Groups:** StencilOp, LightEnvModeSGIX"]
  pub const GL_REPLACE: GLenum = 0x1E01;
  #[doc = "`GL_RG: GLenum = 0x8227`"]
  #[doc = "* **Groups:** InternalFormat, PixelFormat"]
  pub const GL_RG: GLenum = 0x8227;
  #[doc = "`GL_RG16: GLenum = 0x822C`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RG16: GLenum = 0x822C;
  #[doc = "`GL_RG16F: GLenum = 0x822F`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RG16F: GLenum = 0x822F;
  #[doc = "`GL_RG16I: GLenum = 0x8239`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RG16I: GLenum = 0x8239;
  #[doc = "`GL_RG16UI: GLenum = 0x823A`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RG16UI: GLenum = 0x823A;
  #[doc = "`GL_RG16_SNORM: GLenum = 0x8F99`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RG16_SNORM: GLenum = 0x8F99;
  #[doc = "`GL_RG32F: GLenum = 0x8230`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RG32F: GLenum = 0x8230;
  #[doc = "`GL_RG32I: GLenum = 0x823B`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RG32I: GLenum = 0x823B;
  #[doc = "`GL_RG32UI: GLenum = 0x823C`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RG32UI: GLenum = 0x823C;
  #[doc = "`GL_RG8: GLenum = 0x822B`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RG8: GLenum = 0x822B;
  #[doc = "`GL_RG8I: GLenum = 0x8237`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RG8I: GLenum = 0x8237;
  #[doc = "`GL_RG8UI: GLenum = 0x8238`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RG8UI: GLenum = 0x8238;
  #[doc = "`GL_RG8_SNORM: GLenum = 0x8F95`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RG8_SNORM: GLenum = 0x8F95;
  #[doc = "`GL_RGB: GLenum = 0x1907`"]
  #[doc = "* **Groups:** PixelTexGenMode, CombinerPortionNV, PathColorFormat, CombinerComponentUsageNV, PixelFormat, InternalFormat"]
  pub const GL_RGB: GLenum = 0x1907;
  #[doc = "`GL_RGB10: GLenum = 0x8052`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB10: GLenum = 0x8052;
  #[doc = "`GL_RGB10_A2: GLenum = 0x8059`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB10_A2: GLenum = 0x8059;
  #[doc = "`GL_RGB10_A2UI: GLenum = 0x906F`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB10_A2UI: GLenum = 0x906F;
  #[doc = "`GL_RGB12: GLenum = 0x8053`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB12: GLenum = 0x8053;
  #[doc = "`GL_RGB16: GLenum = 0x8054`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB16: GLenum = 0x8054;
  #[doc = "`GL_RGB16F: GLenum = 0x881B`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB16F: GLenum = 0x881B;
  #[doc = "`GL_RGB16I: GLenum = 0x8D89`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB16I: GLenum = 0x8D89;
  #[doc = "`GL_RGB16UI: GLenum = 0x8D77`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB16UI: GLenum = 0x8D77;
  #[doc = "`GL_RGB16_SNORM: GLenum = 0x8F9A`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB16_SNORM: GLenum = 0x8F9A;
  #[doc = "`GL_RGB32F: GLenum = 0x8815`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB32F: GLenum = 0x8815;
  #[doc = "`GL_RGB32I: GLenum = 0x8D83`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB32I: GLenum = 0x8D83;
  #[doc = "`GL_RGB32UI: GLenum = 0x8D71`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB32UI: GLenum = 0x8D71;
  #[doc = "`GL_RGB4: GLenum = 0x804F`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB4: GLenum = 0x804F;
  #[doc = "`GL_RGB5: GLenum = 0x8050`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB5: GLenum = 0x8050;
  #[doc = "`GL_RGB5_A1: GLenum = 0x8057`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB5_A1: GLenum = 0x8057;
  #[doc = "`GL_RGB8: GLenum = 0x8051`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB8: GLenum = 0x8051;
  #[doc = "`GL_RGB8I: GLenum = 0x8D8F`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB8I: GLenum = 0x8D8F;
  #[doc = "`GL_RGB8UI: GLenum = 0x8D7D`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB8UI: GLenum = 0x8D7D;
  #[doc = "`GL_RGB8_SNORM: GLenum = 0x8F96`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB8_SNORM: GLenum = 0x8F96;
  #[doc = "`GL_RGB9_E5: GLenum = 0x8C3D`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGB9_E5: GLenum = 0x8C3D;
  #[doc = "`GL_RGBA: GLenum = 0x1908`"]
  #[doc = "* **Groups:** PixelTexGenMode, PathColorFormat, PixelFormat, InternalFormat"]
  pub const GL_RGBA: GLenum = 0x1908;
  #[doc = "`GL_RGBA12: GLenum = 0x805A`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA12: GLenum = 0x805A;
  #[doc = "`GL_RGBA16: GLenum = 0x805B`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA16: GLenum = 0x805B;
  #[doc = "`GL_RGBA16F: GLenum = 0x881A`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA16F: GLenum = 0x881A;
  #[doc = "`GL_RGBA16I: GLenum = 0x8D88`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA16I: GLenum = 0x8D88;
  #[doc = "`GL_RGBA16UI: GLenum = 0x8D76`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA16UI: GLenum = 0x8D76;
  #[doc = "`GL_RGBA16_SNORM: GLenum = 0x8F9B`"]
  pub const GL_RGBA16_SNORM: GLenum = 0x8F9B;
  #[doc = "`GL_RGBA2: GLenum = 0x8055`"]
  pub const GL_RGBA2: GLenum = 0x8055;
  #[doc = "`GL_RGBA32F: GLenum = 0x8814`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA32F: GLenum = 0x8814;
  #[doc = "`GL_RGBA32I: GLenum = 0x8D82`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA32I: GLenum = 0x8D82;
  #[doc = "`GL_RGBA32UI: GLenum = 0x8D70`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA32UI: GLenum = 0x8D70;
  #[doc = "`GL_RGBA4: GLenum = 0x8056`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA4: GLenum = 0x8056;
  #[doc = "`GL_RGBA8: GLenum = 0x8058`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA8: GLenum = 0x8058;
  #[doc = "`GL_RGBA8I: GLenum = 0x8D8E`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA8I: GLenum = 0x8D8E;
  #[doc = "`GL_RGBA8UI: GLenum = 0x8D7C`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA8UI: GLenum = 0x8D7C;
  #[doc = "`GL_RGBA8_SNORM: GLenum = 0x8F97`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_RGBA8_SNORM: GLenum = 0x8F97;
  #[doc = "`GL_RGBA_INTEGER: GLenum = 0x8D99`"]
  #[doc = "* **Group:** PixelFormat"]
  pub const GL_RGBA_INTEGER: GLenum = 0x8D99;
  #[doc = "`GL_RGB_INTEGER: GLenum = 0x8D98`"]
  #[doc = "* **Group:** PixelFormat"]
  pub const GL_RGB_INTEGER: GLenum = 0x8D98;
  #[doc = "`GL_RG_INTEGER: GLenum = 0x8228`"]
  #[doc = "* **Group:** PixelFormat"]
  pub const GL_RG_INTEGER: GLenum = 0x8228;
  #[doc = "`GL_RIGHT: GLenum = 0x0407`"]
  #[doc = "* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode"]
  pub const GL_RIGHT: GLenum = 0x0407;
  #[doc = "`GL_SAMPLER: GLenum = 0x82E6`"]
  #[doc = "* **Group:** ObjectIdentifier"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_SAMPLER: GLenum = 0x82E6;
  #[doc = "`GL_SAMPLER_1D: GLenum = 0x8B5D`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_1D: GLenum = 0x8B5D;
  #[doc = "`GL_SAMPLER_1D_ARRAY: GLenum = 0x8DC0`"]
  #[doc = "* **Groups:** GlslTypeToken, UniformType"]
  pub const GL_SAMPLER_1D_ARRAY: GLenum = 0x8DC0;
  #[doc = "`GL_SAMPLER_1D_ARRAY_SHADOW: GLenum = 0x8DC3`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_1D_ARRAY_SHADOW: GLenum = 0x8DC3;
  #[doc = "`GL_SAMPLER_1D_SHADOW: GLenum = 0x8B61`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_1D_SHADOW: GLenum = 0x8B61;
  #[doc = "`GL_SAMPLER_2D: GLenum = 0x8B5E`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D: GLenum = 0x8B5E;
  #[doc = "`GL_SAMPLER_2D_ARRAY: GLenum = 0x8DC1`"]
  #[doc = "* **Groups:** GlslTypeToken, UniformType"]
  pub const GL_SAMPLER_2D_ARRAY: GLenum = 0x8DC1;
  #[doc = "`GL_SAMPLER_2D_ARRAY_SHADOW: GLenum = 0x8DC4`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D_ARRAY_SHADOW: GLenum = 0x8DC4;
  #[doc = "`GL_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9108`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9108;
  #[doc = "`GL_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910B`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910B;
  #[doc = "`GL_SAMPLER_2D_RECT: GLenum = 0x8B63`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D_RECT: GLenum = 0x8B63;
  #[doc = "`GL_SAMPLER_2D_RECT_SHADOW: GLenum = 0x8B64`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D_RECT_SHADOW: GLenum = 0x8B64;
  #[doc = "`GL_SAMPLER_2D_SHADOW: GLenum = 0x8B62`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D_SHADOW: GLenum = 0x8B62;
  #[doc = "`GL_SAMPLER_3D: GLenum = 0x8B5F`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_3D: GLenum = 0x8B5F;
  #[doc = "`GL_SAMPLER_BINDING: GLenum = 0x8919`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_SAMPLER_BINDING: GLenum = 0x8919;
  #[doc = "`GL_SAMPLER_BUFFER: GLenum = 0x8DC2`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_BUFFER: GLenum = 0x8DC2;
  #[doc = "`GL_SAMPLER_CUBE: GLenum = 0x8B60`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_CUBE: GLenum = 0x8B60;
  #[doc = "`GL_SAMPLER_CUBE_SHADOW: GLenum = 0x8DC5`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_CUBE_SHADOW: GLenum = 0x8DC5;
  #[doc = "`GL_SAMPLES: GLenum = 0x80A9`"]
  #[doc = "* **Groups:** GetFramebufferParameter, GetPName, InternalFormatPName"]
  pub const GL_SAMPLES: GLenum = 0x80A9;
  #[doc = "`GL_SAMPLES_PASSED: GLenum = 0x8914`"]
  #[doc = "* **Group:** QueryTarget"]
  pub const GL_SAMPLES_PASSED: GLenum = 0x8914;
  #[doc = "`GL_SAMPLE_ALPHA_TO_COVERAGE: GLenum = 0x809E`"]
  #[doc = "* **Group:** EnableCap"]
  pub const GL_SAMPLE_ALPHA_TO_COVERAGE: GLenum = 0x809E;
  #[doc = "`GL_SAMPLE_ALPHA_TO_ONE: GLenum = 0x809F`"]
  #[doc = "* **Group:** EnableCap"]
  pub const GL_SAMPLE_ALPHA_TO_ONE: GLenum = 0x809F;
  #[doc = "`GL_SAMPLE_BUFFERS: GLenum = 0x80A8`"]
  #[doc = "* **Groups:** GetFramebufferParameter, GetPName"]
  pub const GL_SAMPLE_BUFFERS: GLenum = 0x80A8;
  #[doc = "`GL_SAMPLE_COVERAGE: GLenum = 0x80A0`"]
  #[doc = "* **Group:** EnableCap"]
  pub const GL_SAMPLE_COVERAGE: GLenum = 0x80A0;
  #[doc = "`GL_SAMPLE_COVERAGE_INVERT: GLenum = 0x80AB`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_SAMPLE_COVERAGE_INVERT: GLenum = 0x80AB;
  #[doc = "`GL_SAMPLE_COVERAGE_VALUE: GLenum = 0x80AA`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_SAMPLE_COVERAGE_VALUE: GLenum = 0x80AA;
  #[doc = "`GL_SAMPLE_MASK: GLenum = 0x8E51`"]
  #[doc = "* **Group:** EnableCap"]
  pub const GL_SAMPLE_MASK: GLenum = 0x8E51;
  #[doc = "`GL_SAMPLE_MASK_VALUE: GLenum = 0x8E52`"]
  pub const GL_SAMPLE_MASK_VALUE: GLenum = 0x8E52;
  #[doc = "`GL_SAMPLE_POSITION: GLenum = 0x8E50`"]
  #[doc = "* **Group:** GetMultisamplePNameNV"]
  pub const GL_SAMPLE_POSITION: GLenum = 0x8E50;
  #[doc = "`GL_SCISSOR_BOX: GLenum = 0x0C10`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_SCISSOR_BOX: GLenum = 0x0C10;
  #[doc = "`GL_SCISSOR_TEST: GLenum = 0x0C11`"]
  #[doc = "* **Groups:** GetPName, EnableCap"]
  pub const GL_SCISSOR_TEST: GLenum = 0x0C11;
  #[doc = "`GL_SEPARATE_ATTRIBS: GLenum = 0x8C8D`"]
  #[doc = "* **Group:** TransformFeedbackBufferMode"]
  pub const GL_SEPARATE_ATTRIBS: GLenum = 0x8C8D;
  #[doc = "`GL_SET: GLenum = 0x150F`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_SET: GLenum = 0x150F;
  #[doc = "`GL_SHADER: GLenum = 0x82E1`"]
  #[doc = "* **Group:** ObjectIdentifier"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_SHADER: GLenum = 0x82E1;
  #[doc = "`GL_SHADER_SOURCE_LENGTH: GLenum = 0x8B88`"]
  #[doc = "* **Group:** ShaderParameterName"]
  pub const GL_SHADER_SOURCE_LENGTH: GLenum = 0x8B88;
  #[doc = "`GL_SHADER_TYPE: GLenum = 0x8B4F`"]
  #[doc = "* **Group:** ShaderParameterName"]
  pub const GL_SHADER_TYPE: GLenum = 0x8B4F;
  #[doc = "`GL_SHADING_LANGUAGE_VERSION: GLenum = 0x8B8C`"]
  #[doc = "* **Group:** StringName"]
  pub const GL_SHADING_LANGUAGE_VERSION: GLenum = 0x8B8C;
  #[doc = "`GL_SHORT: GLenum = 0x1402`"]
  #[doc = "* **Groups:** VertexAttribIType, SecondaryColorPointerTypeIBM, WeightPointerTypeARB, TangentPointerTypeEXT, BinormalPointerTypeEXT, IndexPointerType, ListNameType, NormalPointerType, PixelType, TexCoordPointerType, VertexPointerType, VertexAttribType, VertexAttribPointerType"]
  pub const GL_SHORT: GLenum = 0x1402;
  #[doc = "`GL_SIGNALED: GLenum = 0x9119`"]
  pub const GL_SIGNALED: GLenum = 0x9119;
  #[doc = "`GL_SIGNED_NORMALIZED: GLenum = 0x8F9C`"]
  pub const GL_SIGNED_NORMALIZED: GLenum = 0x8F9C;
  #[doc = "`GL_SMOOTH_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23`"]
  #[doc = "* **Group:** GetPName"]
  #[doc = "* **Alias Of:** `GL_LINE_WIDTH_GRANULARITY`"]
  pub const GL_SMOOTH_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23;
  #[doc = "`GL_SMOOTH_LINE_WIDTH_RANGE: GLenum = 0x0B22`"]
  #[doc = "* **Group:** GetPName"]
  #[doc = "* **Alias Of:** `GL_LINE_WIDTH_RANGE`"]
  pub const GL_SMOOTH_LINE_WIDTH_RANGE: GLenum = 0x0B22;
  #[doc = "`GL_SMOOTH_POINT_SIZE_GRANULARITY: GLenum = 0x0B13`"]
  #[doc = "* **Group:** GetPName"]
  #[doc = "* **Alias Of:** `GL_POINT_SIZE_GRANULARITY`"]
  pub const GL_SMOOTH_POINT_SIZE_GRANULARITY: GLenum = 0x0B13;
  #[doc = "`GL_SMOOTH_POINT_SIZE_RANGE: GLenum = 0x0B12`"]
  #[doc = "* **Group:** GetPName"]
  #[doc = "* **Alias Of:** `GL_POINT_SIZE_RANGE`"]
  pub const GL_SMOOTH_POINT_SIZE_RANGE: GLenum = 0x0B12;
  #[doc = "`GL_SRC1_ALPHA: GLenum = 0x8589`"]
  #[doc = "* **Group:** BlendingFactor"]
  #[doc = "* **Alias Of:** `GL_SOURCE1_ALPHA`"]
  pub const GL_SRC1_ALPHA: GLenum = 0x8589;
  #[doc = "`GL_SRC1_COLOR: GLenum = 0x88F9`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_SRC1_COLOR: GLenum = 0x88F9;
  #[doc = "`GL_SRC_ALPHA: GLenum = 0x0302`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_SRC_ALPHA: GLenum = 0x0302;
  #[doc = "`GL_SRC_ALPHA_SATURATE: GLenum = 0x0308`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_SRC_ALPHA_SATURATE: GLenum = 0x0308;
  #[doc = "`GL_SRC_COLOR: GLenum = 0x0300`"]
  #[doc = "* **Group:** BlendingFactor"]
  pub const GL_SRC_COLOR: GLenum = 0x0300;
  #[doc = "`GL_SRGB: GLenum = 0x8C40`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_SRGB: GLenum = 0x8C40;
  #[doc = "`GL_SRGB8: GLenum = 0x8C41`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_SRGB8: GLenum = 0x8C41;
  #[doc = "`GL_SRGB8_ALPHA8: GLenum = 0x8C43`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_SRGB8_ALPHA8: GLenum = 0x8C43;
  #[doc = "`GL_SRGB_ALPHA: GLenum = 0x8C42`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_SRGB_ALPHA: GLenum = 0x8C42;
  #[doc = "`GL_STACK_OVERFLOW: GLenum = 0x0503`"]
  #[doc = "* **Group:** ErrorCode"]
  pub const GL_STACK_OVERFLOW: GLenum = 0x0503;
  #[doc = "`GL_STACK_UNDERFLOW: GLenum = 0x0504`"]
  #[doc = "* **Group:** ErrorCode"]
  pub const GL_STACK_UNDERFLOW: GLenum = 0x0504;
  #[doc = "`GL_STATIC_COPY: GLenum = 0x88E6`"]
  #[doc = "* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_STATIC_COPY: GLenum = 0x88E6;
  #[doc = "`GL_STATIC_DRAW: GLenum = 0x88E4`"]
  #[doc = "* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_STATIC_DRAW: GLenum = 0x88E4;
  #[doc = "`GL_STATIC_READ: GLenum = 0x88E5`"]
  #[doc = "* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_STATIC_READ: GLenum = 0x88E5;
  #[doc = "`GL_STENCIL: GLenum = 0x1802`"]
  #[doc = "* **Groups:** Buffer, PixelCopyType, InvalidateFramebufferAttachment"]
  pub const GL_STENCIL: GLenum = 0x1802;
  #[doc = "`GL_STENCIL_ATTACHMENT: GLenum = 0x8D20`"]
  #[doc = "* **Group:** FramebufferAttachment"]
  pub const GL_STENCIL_ATTACHMENT: GLenum = 0x8D20;
  #[doc = "`GL_STENCIL_BACK_FAIL: GLenum = 0x8801`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_FAIL: GLenum = 0x8801;
  #[doc = "`GL_STENCIL_BACK_FUNC: GLenum = 0x8800`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_FUNC: GLenum = 0x8800;
  #[doc = "`GL_STENCIL_BACK_PASS_DEPTH_FAIL: GLenum = 0x8802`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_PASS_DEPTH_FAIL: GLenum = 0x8802;
  #[doc = "`GL_STENCIL_BACK_PASS_DEPTH_PASS: GLenum = 0x8803`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_PASS_DEPTH_PASS: GLenum = 0x8803;
  #[doc = "`GL_STENCIL_BACK_REF: GLenum = 0x8CA3`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_REF: GLenum = 0x8CA3;
  #[doc = "`GL_STENCIL_BACK_VALUE_MASK: GLenum = 0x8CA4`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_VALUE_MASK: GLenum = 0x8CA4;
  #[doc = "`GL_STENCIL_BACK_WRITEMASK: GLenum = 0x8CA5`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_WRITEMASK: GLenum = 0x8CA5;
  #[doc = "`GL_STENCIL_BUFFER_BIT: GLbitfield = 0x00000400`"]
  #[doc = "* **Groups:** ClearBufferMask, AttribMask"]
  pub const GL_STENCIL_BUFFER_BIT: GLbitfield = 0x00000400;
  #[doc = "`GL_STENCIL_CLEAR_VALUE: GLenum = 0x0B91`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_CLEAR_VALUE: GLenum = 0x0B91;
  #[doc = "`GL_STENCIL_FAIL: GLenum = 0x0B94`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_FAIL: GLenum = 0x0B94;
  #[doc = "`GL_STENCIL_FUNC: GLenum = 0x0B92`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_FUNC: GLenum = 0x0B92;
  #[doc = "`GL_STENCIL_INDEX: GLenum = 0x1901`"]
  #[doc = "* **Groups:** InternalFormat, PixelFormat"]
  pub const GL_STENCIL_INDEX: GLenum = 0x1901;
  #[doc = "`GL_STENCIL_INDEX1: GLenum = 0x8D46`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_STENCIL_INDEX1: GLenum = 0x8D46;
  #[doc = "`GL_STENCIL_INDEX16: GLenum = 0x8D49`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_STENCIL_INDEX16: GLenum = 0x8D49;
  #[doc = "`GL_STENCIL_INDEX4: GLenum = 0x8D47`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_STENCIL_INDEX4: GLenum = 0x8D47;
  #[doc = "`GL_STENCIL_INDEX8: GLenum = 0x8D48`"]
  #[doc = "* **Group:** InternalFormat"]
  pub const GL_STENCIL_INDEX8: GLenum = 0x8D48;
  #[doc = "`GL_STENCIL_PASS_DEPTH_FAIL: GLenum = 0x0B95`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_PASS_DEPTH_FAIL: GLenum = 0x0B95;
  #[doc = "`GL_STENCIL_PASS_DEPTH_PASS: GLenum = 0x0B96`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_PASS_DEPTH_PASS: GLenum = 0x0B96;
  #[doc = "`GL_STENCIL_REF: GLenum = 0x0B97`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_REF: GLenum = 0x0B97;
  #[doc = "`GL_STENCIL_TEST: GLenum = 0x0B90`"]
  #[doc = "* **Groups:** GetPName, EnableCap"]
  pub const GL_STENCIL_TEST: GLenum = 0x0B90;
  #[doc = "`GL_STENCIL_VALUE_MASK: GLenum = 0x0B93`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_VALUE_MASK: GLenum = 0x0B93;
  #[doc = "`GL_STENCIL_WRITEMASK: GLenum = 0x0B98`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_STENCIL_WRITEMASK: GLenum = 0x0B98;
  #[doc = "`GL_STEREO: GLenum = 0x0C33`"]
  #[doc = "* **Groups:** GetFramebufferParameter, GetPName"]
  pub const GL_STEREO: GLenum = 0x0C33;
  #[doc = "`GL_STREAM_COPY: GLenum = 0x88E2`"]
  #[doc = "* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_STREAM_COPY: GLenum = 0x88E2;
  #[doc = "`GL_STREAM_DRAW: GLenum = 0x88E0`"]
  #[doc = "* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_STREAM_DRAW: GLenum = 0x88E0;
  #[doc = "`GL_STREAM_READ: GLenum = 0x88E1`"]
  #[doc = "* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_STREAM_READ: GLenum = 0x88E1;
  #[doc = "`GL_SUBPIXEL_BITS: GLenum = 0x0D50`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_SUBPIXEL_BITS: GLenum = 0x0D50;
  #[doc = "`GL_SYNC_CONDITION: GLenum = 0x9113`"]
  #[doc = "* **Group:** SyncParameterName"]
  pub const GL_SYNC_CONDITION: GLenum = 0x9113;
  #[doc = "`GL_SYNC_FENCE: GLenum = 0x9116`"]
  pub const GL_SYNC_FENCE: GLenum = 0x9116;
  #[doc = "`GL_SYNC_FLAGS: GLenum = 0x9115`"]
  #[doc = "* **Group:** SyncParameterName"]
  pub const GL_SYNC_FLAGS: GLenum = 0x9115;
  #[doc = "`GL_SYNC_FLUSH_COMMANDS_BIT: GLbitfield = 0x00000001`"]
  #[doc = "* **Group:** SyncObjectMask"]
  pub const GL_SYNC_FLUSH_COMMANDS_BIT: GLbitfield = 0x00000001;
  #[doc = "`GL_SYNC_GPU_COMMANDS_COMPLETE: GLenum = 0x9117`"]
  #[doc = "* **Group:** SyncCondition"]
  pub const GL_SYNC_GPU_COMMANDS_COMPLETE: GLenum = 0x9117;
  #[doc = "`GL_SYNC_STATUS: GLenum = 0x9114`"]
  #[doc = "* **Group:** SyncParameterName"]
  pub const GL_SYNC_STATUS: GLenum = 0x9114;
  #[doc = "`GL_TEXTURE: GLenum = 0x1702`"]
  #[doc = "* **Groups:** ObjectIdentifier, MatrixMode"]
  pub const GL_TEXTURE: GLenum = 0x1702;
  #[doc = "`GL_TEXTURE0: GLenum = 0x84C0`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE0: GLenum = 0x84C0;
  #[doc = "`GL_TEXTURE1: GLenum = 0x84C1`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE1: GLenum = 0x84C1;
  #[doc = "`GL_TEXTURE10: GLenum = 0x84CA`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE10: GLenum = 0x84CA;
  #[doc = "`GL_TEXTURE11: GLenum = 0x84CB`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE11: GLenum = 0x84CB;
  #[doc = "`GL_TEXTURE12: GLenum = 0x84CC`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE12: GLenum = 0x84CC;
  #[doc = "`GL_TEXTURE13: GLenum = 0x84CD`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE13: GLenum = 0x84CD;
  #[doc = "`GL_TEXTURE14: GLenum = 0x84CE`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE14: GLenum = 0x84CE;
  #[doc = "`GL_TEXTURE15: GLenum = 0x84CF`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE15: GLenum = 0x84CF;
  #[doc = "`GL_TEXTURE16: GLenum = 0x84D0`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE16: GLenum = 0x84D0;
  #[doc = "`GL_TEXTURE17: GLenum = 0x84D1`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE17: GLenum = 0x84D1;
  #[doc = "`GL_TEXTURE18: GLenum = 0x84D2`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE18: GLenum = 0x84D2;
  #[doc = "`GL_TEXTURE19: GLenum = 0x84D3`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE19: GLenum = 0x84D3;
  #[doc = "`GL_TEXTURE2: GLenum = 0x84C2`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE2: GLenum = 0x84C2;
  #[doc = "`GL_TEXTURE20: GLenum = 0x84D4`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE20: GLenum = 0x84D4;
  #[doc = "`GL_TEXTURE21: GLenum = 0x84D5`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE21: GLenum = 0x84D5;
  #[doc = "`GL_TEXTURE22: GLenum = 0x84D6`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE22: GLenum = 0x84D6;
  #[doc = "`GL_TEXTURE23: GLenum = 0x84D7`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE23: GLenum = 0x84D7;
  #[doc = "`GL_TEXTURE24: GLenum = 0x84D8`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE24: GLenum = 0x84D8;
  #[doc = "`GL_TEXTURE25: GLenum = 0x84D9`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE25: GLenum = 0x84D9;
  #[doc = "`GL_TEXTURE26: GLenum = 0x84DA`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE26: GLenum = 0x84DA;
  #[doc = "`GL_TEXTURE27: GLenum = 0x84DB`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE27: GLenum = 0x84DB;
  #[doc = "`GL_TEXTURE28: GLenum = 0x84DC`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE28: GLenum = 0x84DC;
  #[doc = "`GL_TEXTURE29: GLenum = 0x84DD`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE29: GLenum = 0x84DD;
  #[doc = "`GL_TEXTURE3: GLenum = 0x84C3`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE3: GLenum = 0x84C3;
  #[doc = "`GL_TEXTURE30: GLenum = 0x84DE`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE30: GLenum = 0x84DE;
  #[doc = "`GL_TEXTURE31: GLenum = 0x84DF`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE31: GLenum = 0x84DF;
  #[doc = "`GL_TEXTURE4: GLenum = 0x84C4`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE4: GLenum = 0x84C4;
  #[doc = "`GL_TEXTURE5: GLenum = 0x84C5`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE5: GLenum = 0x84C5;
  #[doc = "`GL_TEXTURE6: GLenum = 0x84C6`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE6: GLenum = 0x84C6;
  #[doc = "`GL_TEXTURE7: GLenum = 0x84C7`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE7: GLenum = 0x84C7;
  #[doc = "`GL_TEXTURE8: GLenum = 0x84C8`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE8: GLenum = 0x84C8;
  #[doc = "`GL_TEXTURE9: GLenum = 0x84C9`"]
  #[doc = "* **Group:** TextureUnit"]
  pub const GL_TEXTURE9: GLenum = 0x84C9;
  #[doc = "`GL_TEXTURE_1D: GLenum = 0x0DE0`"]
  #[doc = "* **Groups:** CopyImageSubDataTarget, EnableCap, GetPName, TextureTarget"]
  pub const GL_TEXTURE_1D: GLenum = 0x0DE0;
  #[doc = "`GL_TEXTURE_1D_ARRAY: GLenum = 0x8C18`"]
  #[doc = "* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_1D_ARRAY: GLenum = 0x8C18;
  #[doc = "`GL_TEXTURE_2D: GLenum = 0x0DE1`"]
  #[doc = "* **Groups:** CopyImageSubDataTarget, EnableCap, GetPName, TextureTarget"]
  pub const GL_TEXTURE_2D: GLenum = 0x0DE1;
  #[doc = "`GL_TEXTURE_2D_ARRAY: GLenum = 0x8C1A`"]
  #[doc = "* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_2D_ARRAY: GLenum = 0x8C1A;
  #[doc = "`GL_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9100`"]
  #[doc = "* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9100;
  #[doc = "`GL_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9102`"]
  #[doc = "* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9102;
  #[doc = "`GL_TEXTURE_3D: GLenum = 0x806F`"]
  #[doc = "* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_3D: GLenum = 0x806F;
  #[doc = "`GL_TEXTURE_ALPHA_SIZE: GLenum = 0x805F`"]
  #[doc = "* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_ALPHA_SIZE: GLenum = 0x805F;
  #[doc = "`GL_TEXTURE_ALPHA_TYPE: GLenum = 0x8C13`"]
  pub const GL_TEXTURE_ALPHA_TYPE: GLenum = 0x8C13;
  #[doc = "`GL_TEXTURE_BASE_LEVEL: GLenum = 0x813C`"]
  #[doc = "* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_BASE_LEVEL: GLenum = 0x813C;
  #[doc = "`GL_TEXTURE_BINDING_1D: GLenum = 0x8068`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_1D: GLenum = 0x8068;
  #[doc = "`GL_TEXTURE_BINDING_1D_ARRAY: GLenum = 0x8C1C`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_1D_ARRAY: GLenum = 0x8C1C;
  #[doc = "`GL_TEXTURE_BINDING_2D: GLenum = 0x8069`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_2D: GLenum = 0x8069;
  #[doc = "`GL_TEXTURE_BINDING_2D_ARRAY: GLenum = 0x8C1D`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_2D_ARRAY: GLenum = 0x8C1D;
  #[doc = "`GL_TEXTURE_BINDING_2D_MULTISAMPLE: GLenum = 0x9104`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE: GLenum = 0x9104;
  #[doc = "`GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: GLenum = 0x9105`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: GLenum = 0x9105;
  #[doc = "`GL_TEXTURE_BINDING_3D: GLenum = 0x806A`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_3D: GLenum = 0x806A;
  #[doc = "`GL_TEXTURE_BINDING_BUFFER: GLenum = 0x8C2C`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_BUFFER: GLenum = 0x8C2C;
  #[doc = "`GL_TEXTURE_BINDING_CUBE_MAP: GLenum = 0x8514`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_CUBE_MAP: GLenum = 0x8514;
  #[doc = "`GL_TEXTURE_BINDING_RECTANGLE: GLenum = 0x84F6`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_RECTANGLE: GLenum = 0x84F6;
  #[doc = "`GL_TEXTURE_BLUE_SIZE: GLenum = 0x805E`"]
  #[doc = "* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_BLUE_SIZE: GLenum = 0x805E;
  #[doc = "`GL_TEXTURE_BLUE_TYPE: GLenum = 0x8C12`"]
  pub const GL_TEXTURE_BLUE_TYPE: GLenum = 0x8C12;
  #[doc = "`GL_TEXTURE_BORDER_COLOR: GLenum = 0x1004`"]
  #[doc = "* **Groups:** SamplerParameterF, GetTextureParameter, TextureParameterName"]
  pub const GL_TEXTURE_BORDER_COLOR: GLenum = 0x1004;
  #[doc = "`GL_TEXTURE_BUFFER: GLenum = 0x8C2A`"]
  #[doc = "* **Groups:** TextureTarget, CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_TEXTURE_BUFFER: GLenum = 0x8C2A;
  #[doc = "`GL_TEXTURE_BUFFER_DATA_STORE_BINDING: GLenum = 0x8C2D`"]
  pub const GL_TEXTURE_BUFFER_DATA_STORE_BINDING: GLenum = 0x8C2D;
  #[doc = "`GL_TEXTURE_COMPARE_FUNC: GLenum = 0x884D`"]
  #[doc = "* **Groups:** SamplerParameterI, TextureParameterName"]
  pub const GL_TEXTURE_COMPARE_FUNC: GLenum = 0x884D;
  #[doc = "`GL_TEXTURE_COMPARE_MODE: GLenum = 0x884C`"]
  #[doc = "* **Groups:** SamplerParameterI, TextureParameterName"]
  pub const GL_TEXTURE_COMPARE_MODE: GLenum = 0x884C;
  #[doc = "`GL_TEXTURE_COMPRESSED: GLenum = 0x86A1`"]
  #[doc = "* **Group:** InternalFormatPName"]
  pub const GL_TEXTURE_COMPRESSED: GLenum = 0x86A1;
  #[doc = "`GL_TEXTURE_COMPRESSED_IMAGE_SIZE: GLenum = 0x86A0`"]
  pub const GL_TEXTURE_COMPRESSED_IMAGE_SIZE: GLenum = 0x86A0;
  #[doc = "`GL_TEXTURE_COMPRESSION_HINT: GLenum = 0x84EF`"]
  #[doc = "* **Groups:** HintTarget, GetPName"]
  pub const GL_TEXTURE_COMPRESSION_HINT: GLenum = 0x84EF;
  #[doc = "`GL_TEXTURE_CUBE_MAP: GLenum = 0x8513`"]
  #[doc = "* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP: GLenum = 0x8513;
  #[doc = "`GL_TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum = 0x8516`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum = 0x8516;
  #[doc = "`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum = 0x8518`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum = 0x8518;
  #[doc = "`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum = 0x851A`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum = 0x851A;
  #[doc = "`GL_TEXTURE_CUBE_MAP_POSITIVE_X: GLenum = 0x8515`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_POSITIVE_X: GLenum = 0x8515;
  #[doc = "`GL_TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum = 0x8517`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum = 0x8517;
  #[doc = "`GL_TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum = 0x8519`"]
  #[doc = "* **Group:** TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum = 0x8519;
  #[doc = "`GL_TEXTURE_CUBE_MAP_SEAMLESS: GLenum = 0x884F`"]
  #[doc = "* **Group:** EnableCap"]
  pub const GL_TEXTURE_CUBE_MAP_SEAMLESS: GLenum = 0x884F;
  #[doc = "`GL_TEXTURE_DEPTH: GLenum = 0x8071`"]
  pub const GL_TEXTURE_DEPTH: GLenum = 0x8071;
  #[doc = "`GL_TEXTURE_DEPTH_SIZE: GLenum = 0x884A`"]
  pub const GL_TEXTURE_DEPTH_SIZE: GLenum = 0x884A;
  #[doc = "`GL_TEXTURE_DEPTH_TYPE: GLenum = 0x8C16`"]
  pub const GL_TEXTURE_DEPTH_TYPE: GLenum = 0x8C16;
  #[doc = "`GL_TEXTURE_FIXED_SAMPLE_LOCATIONS: GLenum = 0x9107`"]
  pub const GL_TEXTURE_FIXED_SAMPLE_LOCATIONS: GLenum = 0x9107;
  #[doc = "`GL_TEXTURE_GREEN_SIZE: GLenum = 0x805D`"]
  #[doc = "* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_GREEN_SIZE: GLenum = 0x805D;
  #[doc = "`GL_TEXTURE_GREEN_TYPE: GLenum = 0x8C11`"]
  pub const GL_TEXTURE_GREEN_TYPE: GLenum = 0x8C11;
  #[doc = "`GL_TEXTURE_HEIGHT: GLenum = 0x1001`"]
  #[doc = "* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_HEIGHT: GLenum = 0x1001;
  #[doc = "`GL_TEXTURE_INTERNAL_FORMAT: GLenum = 0x1003`"]
  #[doc = "* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_INTERNAL_FORMAT: GLenum = 0x1003;
  #[doc = "`GL_TEXTURE_LOD_BIAS: GLenum = 0x8501`"]
  #[doc = "* **Groups:** TextureParameterName, SamplerParameterF"]
  pub const GL_TEXTURE_LOD_BIAS: GLenum = 0x8501;
  #[doc = "`GL_TEXTURE_MAG_FILTER: GLenum = 0x2800`"]
  #[doc = "* **Groups:** SamplerParameterI, GetTextureParameter, TextureParameterName"]
  pub const GL_TEXTURE_MAG_FILTER: GLenum = 0x2800;
  #[doc = "`GL_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FE`"]
  #[doc = "* **Group:** SamplerParameterF"]
  #[cfg(any(feature = "GL_ARB_texture_filter_anisotropic"))]
  #[cfg_attr(
    docs_rs,
    doc(cfg(any(feature = "GL_ARB_texture_filter_anisotropic")))
  )]
  pub const GL_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FE;
  #[doc = "`GL_TEXTURE_MAX_LEVEL: GLenum = 0x813D`"]
  #[doc = "* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_MAX_LEVEL: GLenum = 0x813D;
  #[doc = "`GL_TEXTURE_MAX_LOD: GLenum = 0x813B`"]
  #[doc = "* **Groups:** SamplerParameterF, TextureParameterName"]
  pub const GL_TEXTURE_MAX_LOD: GLenum = 0x813B;
  #[doc = "`GL_TEXTURE_MIN_FILTER: GLenum = 0x2801`"]
  #[doc = "* **Groups:** SamplerParameterI, GetTextureParameter, TextureParameterName"]
  pub const GL_TEXTURE_MIN_FILTER: GLenum = 0x2801;
  #[doc = "`GL_TEXTURE_MIN_LOD: GLenum = 0x813A`"]
  #[doc = "* **Groups:** SamplerParameterF, TextureParameterName"]
  pub const GL_TEXTURE_MIN_LOD: GLenum = 0x813A;
  #[doc = "`GL_TEXTURE_RECTANGLE: GLenum = 0x84F5`"]
  #[doc = "* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_RECTANGLE: GLenum = 0x84F5;
  #[doc = "`GL_TEXTURE_RED_SIZE: GLenum = 0x805C`"]
  #[doc = "* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_RED_SIZE: GLenum = 0x805C;
  #[doc = "`GL_TEXTURE_RED_TYPE: GLenum = 0x8C10`"]
  pub const GL_TEXTURE_RED_TYPE: GLenum = 0x8C10;
  #[doc = "`GL_TEXTURE_SAMPLES: GLenum = 0x9106`"]
  pub const GL_TEXTURE_SAMPLES: GLenum = 0x9106;
  #[doc = "`GL_TEXTURE_SHARED_SIZE: GLenum = 0x8C3F`"]
  pub const GL_TEXTURE_SHARED_SIZE: GLenum = 0x8C3F;
  #[doc = "`GL_TEXTURE_STENCIL_SIZE: GLenum = 0x88F1`"]
  pub const GL_TEXTURE_STENCIL_SIZE: GLenum = 0x88F1;
  #[doc = "`GL_TEXTURE_SWIZZLE_A: GLenum = 0x8E45`"]
  #[doc = "* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_SWIZZLE_A: GLenum = 0x8E45;
  #[doc = "`GL_TEXTURE_SWIZZLE_B: GLenum = 0x8E44`"]
  #[doc = "* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_SWIZZLE_B: GLenum = 0x8E44;
  #[doc = "`GL_TEXTURE_SWIZZLE_G: GLenum = 0x8E43`"]
  #[doc = "* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_SWIZZLE_G: GLenum = 0x8E43;
  #[doc = "`GL_TEXTURE_SWIZZLE_R: GLenum = 0x8E42`"]
  #[doc = "* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_SWIZZLE_R: GLenum = 0x8E42;
  #[doc = "`GL_TEXTURE_SWIZZLE_RGBA: GLenum = 0x8E46`"]
  #[doc = "* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_SWIZZLE_RGBA: GLenum = 0x8E46;
  #[doc = "`GL_TEXTURE_WIDTH: GLenum = 0x1000`"]
  #[doc = "* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_WIDTH: GLenum = 0x1000;
  #[doc = "`GL_TEXTURE_WRAP_R: GLenum = 0x8072`"]
  #[doc = "* **Groups:** SamplerParameterI, TextureParameterName"]
  pub const GL_TEXTURE_WRAP_R: GLenum = 0x8072;
  #[doc = "`GL_TEXTURE_WRAP_S: GLenum = 0x2802`"]
  #[doc = "* **Groups:** SamplerParameterI, GetTextureParameter, TextureParameterName"]
  pub const GL_TEXTURE_WRAP_S: GLenum = 0x2802;
  #[doc = "`GL_TEXTURE_WRAP_T: GLenum = 0x2803`"]
  #[doc = "* **Groups:** SamplerParameterI, GetTextureParameter, TextureParameterName"]
  pub const GL_TEXTURE_WRAP_T: GLenum = 0x2803;
  #[doc = "`GL_TIMEOUT_EXPIRED: GLenum = 0x911B`"]
  #[doc = "* **Group:** SyncStatus"]
  pub const GL_TIMEOUT_EXPIRED: GLenum = 0x911B;
  #[doc = "`GL_TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF`"]
  pub const GL_TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF;
  #[doc = "`GL_TIMESTAMP: GLenum = 0x8E28`"]
  #[doc = "* **Groups:** QueryCounterTarget, GetPName"]
  pub const GL_TIMESTAMP: GLenum = 0x8E28;
  #[doc = "`GL_TIME_ELAPSED: GLenum = 0x88BF`"]
  #[doc = "* **Group:** QueryTarget"]
  pub const GL_TIME_ELAPSED: GLenum = 0x88BF;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER: GLenum = 0x8C8E`"]
  #[doc = "* **Groups:** ProgramInterface, BufferTargetARB, BufferStorageTarget, CopyBufferSubDataTarget"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER: GLenum = 0x8C8E;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING: GLenum = 0x8C8F`"]
  #[doc = "* **Groups:** TransformFeedbackPName, GetPName"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER_BINDING: GLenum = 0x8C8F;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER_MODE: GLenum = 0x8C7F`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER_MODE: GLenum = 0x8C7F;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER_SIZE: GLenum = 0x8C85`"]
  #[doc = "* **Groups:** TransformFeedbackPName, GetPName"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER_SIZE: GLenum = 0x8C85;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER_START: GLenum = 0x8C84`"]
  #[doc = "* **Groups:** TransformFeedbackPName, GetPName"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER_START: GLenum = 0x8C84;
  #[doc = "`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: GLenum = 0x8C88`"]
  #[doc = "* **Group:** QueryTarget"]
  pub const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: GLenum = 0x8C88;
  #[doc = "`GL_TRANSFORM_FEEDBACK_VARYINGS: GLenum = 0x8C83`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_TRANSFORM_FEEDBACK_VARYINGS: GLenum = 0x8C83;
  #[doc = "`GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: GLenum = 0x8C76`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: GLenum = 0x8C76;
  #[doc = "`GL_TRIANGLES: GLenum = 0x0004`"]
  #[doc = "* **Group:** PrimitiveType"]
  pub const GL_TRIANGLES: GLenum = 0x0004;
  #[doc = "`GL_TRIANGLES_ADJACENCY: GLenum = 0x000C`"]
  #[doc = "* **Group:** PrimitiveType"]
  pub const GL_TRIANGLES_ADJACENCY: GLenum = 0x000C;
  #[doc = "`GL_TRIANGLE_FAN: GLenum = 0x0006`"]
  #[doc = "* **Group:** PrimitiveType"]
  pub const GL_TRIANGLE_FAN: GLenum = 0x0006;
  #[doc = "`GL_TRIANGLE_STRIP: GLenum = 0x0005`"]
  #[doc = "* **Group:** PrimitiveType"]
  pub const GL_TRIANGLE_STRIP: GLenum = 0x0005;
  #[doc = "`GL_TRIANGLE_STRIP_ADJACENCY: GLenum = 0x000D`"]
  #[doc = "* **Group:** PrimitiveType"]
  pub const GL_TRIANGLE_STRIP_ADJACENCY: GLenum = 0x000D;
  #[doc = "`GL_TRUE: GLenum = 1`"]
  #[doc = "* **Groups:** Boolean, VertexShaderWriteMaskEXT, ClampColorModeARB"]
  pub const GL_TRUE: GLenum = 1;
  #[doc = "`GL_UNIFORM_ARRAY_STRIDE: GLenum = 0x8A3C`"]
  #[doc = "* **Group:** UniformPName"]
  pub const GL_UNIFORM_ARRAY_STRIDE: GLenum = 0x8A3C;
  #[doc = "`GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS: GLenum = 0x8A42`"]
  #[doc = "* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS: GLenum = 0x8A42;
  #[doc = "`GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: GLenum = 0x8A43`"]
  #[doc = "* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: GLenum = 0x8A43;
  #[doc = "`GL_UNIFORM_BLOCK_BINDING: GLenum = 0x8A3F`"]
  #[doc = "* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_BINDING: GLenum = 0x8A3F;
  #[doc = "`GL_UNIFORM_BLOCK_DATA_SIZE: GLenum = 0x8A40`"]
  #[doc = "* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_DATA_SIZE: GLenum = 0x8A40;
  #[doc = "`GL_UNIFORM_BLOCK_INDEX: GLenum = 0x8A3A`"]
  #[doc = "* **Group:** UniformPName"]
  pub const GL_UNIFORM_BLOCK_INDEX: GLenum = 0x8A3A;
  #[doc = "`GL_UNIFORM_BLOCK_NAME_LENGTH: GLenum = 0x8A41`"]
  #[doc = "* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_NAME_LENGTH: GLenum = 0x8A41;
  #[doc = "`GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x8A46`"]
  #[doc = "* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x8A46;
  #[doc = "`GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x8A45`"]
  #[doc = "* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x8A45;
  #[doc = "`GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x8A44`"]
  #[doc = "* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x8A44;
  #[doc = "`GL_UNIFORM_BUFFER: GLenum = 0x8A11`"]
  #[doc = "* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_UNIFORM_BUFFER: GLenum = 0x8A11;
  #[doc = "`GL_UNIFORM_BUFFER_BINDING: GLenum = 0x8A28`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_UNIFORM_BUFFER_BINDING: GLenum = 0x8A28;
  #[doc = "`GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x8A34`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x8A34;
  #[doc = "`GL_UNIFORM_BUFFER_SIZE: GLenum = 0x8A2A`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_UNIFORM_BUFFER_SIZE: GLenum = 0x8A2A;
  #[doc = "`GL_UNIFORM_BUFFER_START: GLenum = 0x8A29`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_UNIFORM_BUFFER_START: GLenum = 0x8A29;
  #[doc = "`GL_UNIFORM_IS_ROW_MAJOR: GLenum = 0x8A3E`"]
  #[doc = "* **Group:** UniformPName"]
  pub const GL_UNIFORM_IS_ROW_MAJOR: GLenum = 0x8A3E;
  #[doc = "`GL_UNIFORM_MATRIX_STRIDE: GLenum = 0x8A3D`"]
  #[doc = "* **Group:** UniformPName"]
  pub const GL_UNIFORM_MATRIX_STRIDE: GLenum = 0x8A3D;
  #[doc = "`GL_UNIFORM_NAME_LENGTH: GLenum = 0x8A39`"]
  #[doc = "* **Groups:** SubroutineParameterName, UniformPName"]
  pub const GL_UNIFORM_NAME_LENGTH: GLenum = 0x8A39;
  #[doc = "`GL_UNIFORM_OFFSET: GLenum = 0x8A3B`"]
  #[doc = "* **Group:** UniformPName"]
  pub const GL_UNIFORM_OFFSET: GLenum = 0x8A3B;
  #[doc = "`GL_UNIFORM_SIZE: GLenum = 0x8A38`"]
  #[doc = "* **Groups:** SubroutineParameterName, UniformPName"]
  pub const GL_UNIFORM_SIZE: GLenum = 0x8A38;
  #[doc = "`GL_UNIFORM_TYPE: GLenum = 0x8A37`"]
  #[doc = "* **Group:** UniformPName"]
  pub const GL_UNIFORM_TYPE: GLenum = 0x8A37;
  #[doc = "`GL_UNPACK_ALIGNMENT: GLenum = 0x0CF5`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_ALIGNMENT: GLenum = 0x0CF5;
  #[doc = "`GL_UNPACK_IMAGE_HEIGHT: GLenum = 0x806E`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_IMAGE_HEIGHT: GLenum = 0x806E;
  #[doc = "`GL_UNPACK_LSB_FIRST: GLenum = 0x0CF1`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_LSB_FIRST: GLenum = 0x0CF1;
  #[doc = "`GL_UNPACK_ROW_LENGTH: GLenum = 0x0CF2`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_ROW_LENGTH: GLenum = 0x0CF2;
  #[doc = "`GL_UNPACK_SKIP_IMAGES: GLenum = 0x806D`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_SKIP_IMAGES: GLenum = 0x806D;
  #[doc = "`GL_UNPACK_SKIP_PIXELS: GLenum = 0x0CF4`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_SKIP_PIXELS: GLenum = 0x0CF4;
  #[doc = "`GL_UNPACK_SKIP_ROWS: GLenum = 0x0CF3`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_SKIP_ROWS: GLenum = 0x0CF3;
  #[doc = "`GL_UNPACK_SWAP_BYTES: GLenum = 0x0CF0`"]
  #[doc = "* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_SWAP_BYTES: GLenum = 0x0CF0;
  #[doc = "`GL_UNSIGNALED: GLenum = 0x9118`"]
  pub const GL_UNSIGNALED: GLenum = 0x9118;
  #[doc = "`GL_UNSIGNED_BYTE: GLenum = 0x1401`"]
  #[doc = "* **Groups:** VertexAttribIType, ScalarType, ReplacementCodeTypeSUN, ElementPointerTypeATI, MatrixIndexPointerTypeARB, WeightPointerTypeARB, ColorPointerType, DrawElementsType, ListNameType, PixelType, VertexAttribType, VertexAttribPointerType"]
  pub const GL_UNSIGNED_BYTE: GLenum = 0x1401;
  #[doc = "`GL_UNSIGNED_BYTE_2_3_3_REV: GLenum = 0x8362`"]
  pub const GL_UNSIGNED_BYTE_2_3_3_REV: GLenum = 0x8362;
  #[doc = "`GL_UNSIGNED_BYTE_3_3_2: GLenum = 0x8032`"]
  #[doc = "* **Group:** PixelType"]
  pub const GL_UNSIGNED_BYTE_3_3_2: GLenum = 0x8032;
  #[doc = "`GL_UNSIGNED_INT: GLenum = 0x1405`"]
  #[doc = "* **Groups:** VertexAttribIType, ScalarType, ReplacementCodeTypeSUN, ElementPointerTypeATI, MatrixIndexPointerTypeARB, WeightPointerTypeARB, ColorPointerType, DrawElementsType, ListNameType, PixelFormat, PixelType, VertexAttribType, AttributeType, UniformType, VertexAttribPointerType, GlslTypeToken"]
  pub const GL_UNSIGNED_INT: GLenum = 0x1405;
  #[doc = "`GL_UNSIGNED_INT_10F_11F_11F_REV: GLenum = 0x8C3B`"]
  #[doc = "* **Groups:** VertexAttribPointerType, VertexAttribType"]
  pub const GL_UNSIGNED_INT_10F_11F_11F_REV: GLenum = 0x8C3B;
  #[doc = "`GL_UNSIGNED_INT_10_10_10_2: GLenum = 0x8036`"]
  #[doc = "* **Group:** PixelType"]
  pub const GL_UNSIGNED_INT_10_10_10_2: GLenum = 0x8036;
  #[doc = "`GL_UNSIGNED_INT_24_8: GLenum = 0x84FA`"]
  pub const GL_UNSIGNED_INT_24_8: GLenum = 0x84FA;
  #[doc = "`GL_UNSIGNED_INT_2_10_10_10_REV: GLenum = 0x8368`"]
  #[doc = "* **Groups:** VertexAttribPointerType, VertexAttribType"]
  pub const GL_UNSIGNED_INT_2_10_10_10_REV: GLenum = 0x8368;
  #[doc = "`GL_UNSIGNED_INT_5_9_9_9_REV: GLenum = 0x8C3E`"]
  pub const GL_UNSIGNED_INT_5_9_9_9_REV: GLenum = 0x8C3E;
  #[doc = "`GL_UNSIGNED_INT_8_8_8_8: GLenum = 0x8035`"]
  #[doc = "* **Group:** PixelType"]
  pub const GL_UNSIGNED_INT_8_8_8_8: GLenum = 0x8035;
  #[doc = "`GL_UNSIGNED_INT_8_8_8_8_REV: GLenum = 0x8367`"]
  pub const GL_UNSIGNED_INT_8_8_8_8_REV: GLenum = 0x8367;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_1D: GLenum = 0x8DD1`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_1D: GLenum = 0x8DD1;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DD6`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DD6;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_2D: GLenum = 0x8DD2`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_2D: GLenum = 0x8DD2;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DD7`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DD7;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x910A`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x910A;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910D`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910D;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_2D_RECT: GLenum = 0x8DD5`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_2D_RECT: GLenum = 0x8DD5;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_3D: GLenum = 0x8DD3`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_3D: GLenum = 0x8DD3;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_BUFFER: GLenum = 0x8DD8`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_BUFFER: GLenum = 0x8DD8;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_CUBE: GLenum = 0x8DD4`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_CUBE: GLenum = 0x8DD4;
  #[doc = "`GL_UNSIGNED_INT_VEC2: GLenum = 0x8DC6`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_VEC2: GLenum = 0x8DC6;
  #[doc = "`GL_UNSIGNED_INT_VEC3: GLenum = 0x8DC7`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_VEC3: GLenum = 0x8DC7;
  #[doc = "`GL_UNSIGNED_INT_VEC4: GLenum = 0x8DC8`"]
  #[doc = "* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_VEC4: GLenum = 0x8DC8;
  #[doc = "`GL_UNSIGNED_NORMALIZED: GLenum = 0x8C17`"]
  pub const GL_UNSIGNED_NORMALIZED: GLenum = 0x8C17;
  #[doc = "`GL_UNSIGNED_SHORT: GLenum = 0x1403`"]
  #[doc = "* **Groups:** VertexAttribIType, ScalarType, ReplacementCodeTypeSUN, ElementPointerTypeATI, MatrixIndexPointerTypeARB, WeightPointerTypeARB, ColorPointerType, DrawElementsType, ListNameType, PixelFormat, PixelType, VertexAttribType, VertexAttribPointerType"]
  pub const GL_UNSIGNED_SHORT: GLenum = 0x1403;
  #[doc = "`GL_UNSIGNED_SHORT_1_5_5_5_REV: GLenum = 0x8366`"]
  pub const GL_UNSIGNED_SHORT_1_5_5_5_REV: GLenum = 0x8366;
  #[doc = "`GL_UNSIGNED_SHORT_4_4_4_4: GLenum = 0x8033`"]
  #[doc = "* **Group:** PixelType"]
  pub const GL_UNSIGNED_SHORT_4_4_4_4: GLenum = 0x8033;
  #[doc = "`GL_UNSIGNED_SHORT_4_4_4_4_REV: GLenum = 0x8365`"]
  pub const GL_UNSIGNED_SHORT_4_4_4_4_REV: GLenum = 0x8365;
  #[doc = "`GL_UNSIGNED_SHORT_5_5_5_1: GLenum = 0x8034`"]
  #[doc = "* **Group:** PixelType"]
  pub const GL_UNSIGNED_SHORT_5_5_5_1: GLenum = 0x8034;
  #[doc = "`GL_UNSIGNED_SHORT_5_6_5: GLenum = 0x8363`"]
  pub const GL_UNSIGNED_SHORT_5_6_5: GLenum = 0x8363;
  #[doc = "`GL_UNSIGNED_SHORT_5_6_5_REV: GLenum = 0x8364`"]
  pub const GL_UNSIGNED_SHORT_5_6_5_REV: GLenum = 0x8364;
  #[doc = "`GL_UPPER_LEFT: GLenum = 0x8CA2`"]
  #[doc = "* **Group:** ClipControlOrigin"]
  pub const GL_UPPER_LEFT: GLenum = 0x8CA2;
  #[doc = "`GL_VALIDATE_STATUS: GLenum = 0x8B83`"]
  #[doc = "* **Group:** ProgramPropertyARB"]
  pub const GL_VALIDATE_STATUS: GLenum = 0x8B83;
  #[doc = "`GL_VENDOR: GLenum = 0x1F00`"]
  #[doc = "* **Group:** StringName"]
  pub const GL_VENDOR: GLenum = 0x1F00;
  #[doc = "`GL_VERSION: GLenum = 0x1F02`"]
  #[doc = "* **Group:** StringName"]
  pub const GL_VERSION: GLenum = 0x1F02;
  #[doc = "`GL_VERTEX_ARRAY: GLenum = 0x8074`"]
  #[doc = "* **Groups:** ObjectIdentifier, EnableCap, GetPName"]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub const GL_VERTEX_ARRAY: GLenum = 0x8074;
  #[doc = "`GL_VERTEX_ARRAY_BINDING: GLenum = 0x85B5`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_VERTEX_ARRAY_BINDING: GLenum = 0x85B5;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum = 0x889F`"]
  #[doc = "* **Groups:** VertexAttribEnum, VertexAttribPropertyARB"]
  pub const GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum = 0x889F;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_DIVISOR: GLenum = 0x88FE`"]
  #[doc = "* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_DIVISOR: GLenum = 0x88FE;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_ENABLED: GLenum = 0x8622`"]
  #[doc = "* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_ENABLED: GLenum = 0x8622;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_INTEGER: GLenum = 0x88FD`"]
  #[doc = "* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_INTEGER: GLenum = 0x88FD;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum = 0x886A`"]
  #[doc = "* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum = 0x886A;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_POINTER: GLenum = 0x8645`"]
  #[doc = "* **Group:** VertexAttribPointerPropertyARB"]
  pub const GL_VERTEX_ATTRIB_ARRAY_POINTER: GLenum = 0x8645;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_SIZE: GLenum = 0x8623`"]
  #[doc = "* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_SIZE: GLenum = 0x8623;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_STRIDE: GLenum = 0x8624`"]
  #[doc = "* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_STRIDE: GLenum = 0x8624;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_TYPE: GLenum = 0x8625`"]
  #[doc = "* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_TYPE: GLenum = 0x8625;
  #[doc = "`GL_VERTEX_PROGRAM_POINT_SIZE: GLenum = 0x8642`"]
  pub const GL_VERTEX_PROGRAM_POINT_SIZE: GLenum = 0x8642;
  #[doc = "`GL_VERTEX_SHADER: GLenum = 0x8B31`"]
  #[doc = "* **Groups:** PipelineParameterName, ShaderType"]
  pub const GL_VERTEX_SHADER: GLenum = 0x8B31;
  #[doc = "`GL_VIEWPORT: GLenum = 0x0BA2`"]
  #[doc = "* **Group:** GetPName"]
  pub const GL_VIEWPORT: GLenum = 0x0BA2;
  #[doc = "`GL_WAIT_FAILED: GLenum = 0x911D`"]
  #[doc = "* **Group:** SyncStatus"]
  pub const GL_WAIT_FAILED: GLenum = 0x911D;
  #[doc = "`GL_WRITE_ONLY: GLenum = 0x88B9`"]
  #[doc = "* **Group:** BufferAccessARB"]
  pub const GL_WRITE_ONLY: GLenum = 0x88B9;
  #[doc = "`GL_XOR: GLenum = 0x1506`"]
  #[doc = "* **Group:** LogicOp"]
  pub const GL_XOR: GLenum = 0x1506;
  #[doc = "`GL_ZERO: GLenum = 0`"]
  #[doc = "* **Groups:** TextureSwizzle, StencilOp, BlendingFactor"]
  pub const GL_ZERO: GLenum = 0;
}

/// This is called to panic when a not-loaded function is attempted.
///
/// Placing the panic mechanism in this cold function generally helps code
/// generation for the hot path. Or so the sages say, at least.
#[cold]
#[inline(never)]
#[allow(dead_code)]
fn go_panic_because_fn_not_loaded(name: &str) -> ! {
  panic!("called {name} but it was not loaded.", name = name)
}

/// Loads a function pointer.
/// Rejects suggested pointer addresses which are likely to be lies.
/// This function is used by both the global loader and struct loader.
/// We mark it as `inline(never)` to favor a small binary over initialization
/// speed. Returns if there's now a non-null value in the atomic pointer.
#[inline(never)]
#[allow(dead_code)]
fn load_dyn_name_atomic_ptr(
  get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  fn_name: &[u8], ptr: &APcv,
) -> bool {
  // if this fails the code generator itself royally screwed up somehow,
  // and so it's only a debug assert.
  debug_assert_eq!(*fn_name.last().unwrap(), 0);
  let p: *mut c_void = get_proc_address(fn_name.as_ptr() as *const c_char);
  let p_usize = p as usize;
  // You *should* get null for failed lookups, but some systems have been
  // reported to give "error code" values such as -1 or small non-null values.
  // To help guard against this silliness, we consider these values to also
  // just be a result of null.
  if p_usize == core::usize::MAX || p_usize < 8 {
    ptr.store(null_mut(), RELAX);
    false
  } else {
    ptr.store(p, RELAX);
    true
  }
}

/// Returns if an error was printed.
#[cfg(feature = "debug_automatic_glGetError")]
#[inline(never)]
fn report_error_code_from(name: &str, err: GLenum) {
  match err {
    GL_NO_ERROR => return,
    GL_INVALID_ENUM => error!("Invalid Enum to {name}.", name = name),
    GL_INVALID_VALUE => error!("Invalid Value to {name}.", name = name),
    GL_INVALID_OPERATION => error!("Invalid Operation to {name}.", name = name),
    GL_INVALID_FRAMEBUFFER_OPERATION => {
      error!("Invalid Framebuffer Operation to {name}.", name = name)
    }
    GL_OUT_OF_MEMORY => error!("Out of Memory in {name}.", name = name),
    GL_STACK_UNDERFLOW => error!("Stack Underflow in {name}.", name = name),
    GL_STACK_OVERFLOW => error!("Stack Overflow in {name}.", name = name),
    unknown => error!(
      "Unknown error code {unknown} to {name}.",
      name = name,
      unknown = unknown
    ),
  }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_0arg<Ret>(name: &str, ptr: &APcv) -> Ret {
  let p = ptr.load(RELAX);
  match transmute::<*mut c_void, Option<extern "system" fn() -> Ret>>(p) {
    Some(fn_p) => fn_p(),
    None => go_panic_because_fn_not_loaded(name),
  }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_1arg<Ret, A>(name: &str, ptr: &APcv, a: A) -> Ret {
  let p = ptr.load(RELAX);
  match transmute::<*mut c_void, Option<extern "system" fn(A) -> Ret>>(p) {
    Some(fn_p) => fn_p(a),
    None => go_panic_because_fn_not_loaded(name),
  }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_2arg<Ret, A, B>(
  name: &str, ptr: &APcv, a: A, b: B,
) -> Ret {
  let p = ptr.load(RELAX);
  match transmute::<*mut c_void, Option<extern "system" fn(A, B) -> Ret>>(p) {
    Some(fn_p) => fn_p(a, b),
    None => go_panic_because_fn_not_loaded(name),
  }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_3arg<Ret, A, B, C>(
  name: &str, ptr: &APcv, a: A, b: B, c: C,
) -> Ret {
  let p = ptr.load(RELAX);
  match transmute::<*mut c_void, Option<extern "system" fn(A, B, C) -> Ret>>(p)
  {
    Some(fn_p) => fn_p(a, b, c),
    None => go_panic_because_fn_not_loaded(name),
  }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_4arg<Ret, A, B, C, D>(
  name: &str, ptr: &APcv, a: A, b: B, c: C, d: D,
) -> Ret {
  let p = ptr.load(RELAX);
  match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D) -> Ret>>(
    p,
  ) {
    Some(fn_p) => fn_p(a, b, c, d),
    None => go_panic_because_fn_not_loaded(name),
  }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_5arg<Ret, A, B, C, D, E>(
  name: &str, ptr: &APcv, a: A, b: B, c: C, d: D, e: E,
) -> Ret {
  let p = ptr.load(RELAX);
  match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E) -> Ret>>(
    p,
  ) {
    Some(fn_p) => fn_p(a, b, c, d, e),
    None => go_panic_because_fn_not_loaded(name),
  }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_6arg<Ret, A, B, C, D, E, F>(
  name: &str, ptr: &APcv, a: A, b: B, c: C, d: D, e: E, f: F,
) -> Ret {
  let p = ptr.load(RELAX);
  match transmute::<
    *mut c_void,
    Option<extern "system" fn(A, B, C, D, E, F) -> Ret>,
  >(p)
  {
    Some(fn_p) => fn_p(a, b, c, d, e, f),
    None => go_panic_because_fn_not_loaded(name),
  }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_7arg<Ret, A, B, C, D, E, F, G>(
  name: &str, ptr: &APcv, a: A, b: B, c: C, d: D, e: E, f: F, g: G,
) -> Ret {
  let p = ptr.load(RELAX);
  match transmute::<
    *mut c_void,
    Option<extern "system" fn(A, B, C, D, E, F, G) -> Ret>,
  >(p)
  {
    Some(fn_p) => fn_p(a, b, c, d, e, f, g),
    None => go_panic_because_fn_not_loaded(name),
  }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_8arg<Ret, A, B, C, D, E, F, G, H>(
  name: &str, ptr: &APcv, a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H,
) -> Ret {
  let p = ptr.load(RELAX);
  match transmute::<
    *mut c_void,
    Option<extern "system" fn(A, B, C, D, E, F, G, H) -> Ret>,
  >(p)
  {
    Some(fn_p) => fn_p(a, b, c, d, e, f, g, h),
    None => go_panic_because_fn_not_loaded(name),
  }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_9arg<Ret, A, B, C, D, E, F, G, H, I>(
  name: &str, ptr: &APcv, a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I,
) -> Ret {
  let p = ptr.load(RELAX);
  match transmute::<
    *mut c_void,
    Option<extern "system" fn(A, B, C, D, E, F, G, H, I) -> Ret>,
  >(p)
  {
    Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i),
    None => go_panic_because_fn_not_loaded(name),
  }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_10arg<Ret, A, B, C, D, E, F, G, H, I, J>(
  name: &str, ptr: &APcv, a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I,
  j: J,
) -> Ret {
  let p = ptr.load(RELAX);
  match transmute::<
    *mut c_void,
    Option<extern "system" fn(A, B, C, D, E, F, G, H, I, J) -> Ret>,
  >(p)
  {
    Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i, j),
    None => go_panic_because_fn_not_loaded(name),
  }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_11arg<Ret, A, B, C, D, E, F, G, H, I, J, K>(
  name: &str, ptr: &APcv, a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I,
  j: J, k: K,
) -> Ret {
  let p = ptr.load(RELAX);
  match transmute::<
    *mut c_void,
    Option<extern "system" fn(A, B, C, D, E, F, G, H, I, J, K) -> Ret>,
  >(p)
  {
    Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i, j, k),
    None => go_panic_because_fn_not_loaded(name),
  }
}

#[cfg(feature = "global_loader")]
pub use global_commands::*;
#[cfg(feature = "global_loader")]
pub mod global_commands {
  //! Contains functions for using the global GL loader.
  use super::*;
  #[cfg(feature = "debug_automatic_glGetError")]
  #[inline(never)]
  unsafe fn global_automatic_glGetError(name: &str) {
    let mut err = glGetError();
    while err != GL_NO_ERROR {
      report_error_code_from(name, err);
      err = glGetError();
    }
  }

  /// Loads all global functions using the `get_proc_address` given.
  ///
  /// The closure should, when given a null-terminated name of a function,
  /// return a pointer to that function. If the function isn't available, then
  /// a null pointer should be returned instead.
  ///
  /// This allows you to call [SDL_GL_GetProcAddress](https://wiki.libsdl.org/SDL_GL_GetProcAddress),
  /// [wglGetProcAddress](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-wglgetprocaddress),
  /// or some similar function, depending on your OS.
  pub unsafe fn load_global_gl_with<F>(mut get_proc_address: F)
  where
    F: FnMut(*const c_char) -> *mut c_void,
  {
    glActiveTexture_load_with_dyn(&mut get_proc_address) as usize;
    glAttachShader_load_with_dyn(&mut get_proc_address) as usize;
    glBeginConditionalRender_load_with_dyn(&mut get_proc_address) as usize;
    glBeginQuery_load_with_dyn(&mut get_proc_address) as usize;
    glBeginTransformFeedback_load_with_dyn(&mut get_proc_address) as usize;
    glBindAttribLocation_load_with_dyn(&mut get_proc_address) as usize;
    glBindBuffer_load_with_dyn(&mut get_proc_address) as usize;
    glBindBufferBase_load_with_dyn(&mut get_proc_address) as usize;
    glBindBufferRange_load_with_dyn(&mut get_proc_address) as usize;
    glBindFragDataLocation_load_with_dyn(&mut get_proc_address) as usize;
    glBindFragDataLocationIndexed_load_with_dyn(&mut get_proc_address) as usize;
    glBindFramebuffer_load_with_dyn(&mut get_proc_address) as usize;
    glBindRenderbuffer_load_with_dyn(&mut get_proc_address) as usize;
    glBindSampler_load_with_dyn(&mut get_proc_address) as usize;
    glBindTexture_load_with_dyn(&mut get_proc_address) as usize;
    glBindVertexArray_load_with_dyn(&mut get_proc_address) as usize;
    glBlendColor_load_with_dyn(&mut get_proc_address) as usize;
    glBlendEquation_load_with_dyn(&mut get_proc_address) as usize;
    glBlendEquationSeparate_load_with_dyn(&mut get_proc_address) as usize;
    glBlendFunc_load_with_dyn(&mut get_proc_address) as usize;
    glBlendFuncSeparate_load_with_dyn(&mut get_proc_address) as usize;
    glBlitFramebuffer_load_with_dyn(&mut get_proc_address) as usize;
    glBufferData_load_with_dyn(&mut get_proc_address) as usize;
    glBufferSubData_load_with_dyn(&mut get_proc_address) as usize;
    glCheckFramebufferStatus_load_with_dyn(&mut get_proc_address) as usize;
    glClampColor_load_with_dyn(&mut get_proc_address) as usize;
    glClear_load_with_dyn(&mut get_proc_address) as usize;
    glClearBufferfi_load_with_dyn(&mut get_proc_address) as usize;
    glClearBufferfv_load_with_dyn(&mut get_proc_address) as usize;
    glClearBufferiv_load_with_dyn(&mut get_proc_address) as usize;
    glClearBufferuiv_load_with_dyn(&mut get_proc_address) as usize;
    glClearColor_load_with_dyn(&mut get_proc_address) as usize;
    glClearDepth_load_with_dyn(&mut get_proc_address) as usize;
    glClearStencil_load_with_dyn(&mut get_proc_address) as usize;
    glClientWaitSync_load_with_dyn(&mut get_proc_address) as usize;
    glColorMask_load_with_dyn(&mut get_proc_address) as usize;
    glColorMaski_load_with_dyn(&mut get_proc_address) as usize;
    glCompileShader_load_with_dyn(&mut get_proc_address) as usize;
    glCompressedTexImage1D_load_with_dyn(&mut get_proc_address) as usize;
    glCompressedTexImage2D_load_with_dyn(&mut get_proc_address) as usize;
    glCompressedTexImage3D_load_with_dyn(&mut get_proc_address) as usize;
    glCompressedTexSubImage1D_load_with_dyn(&mut get_proc_address) as usize;
    glCompressedTexSubImage2D_load_with_dyn(&mut get_proc_address) as usize;
    glCompressedTexSubImage3D_load_with_dyn(&mut get_proc_address) as usize;
    glCopyBufferSubData_load_with_dyn(&mut get_proc_address) as usize;
    glCopyTexImage1D_load_with_dyn(&mut get_proc_address) as usize;
    glCopyTexImage2D_load_with_dyn(&mut get_proc_address) as usize;
    glCopyTexSubImage1D_load_with_dyn(&mut get_proc_address) as usize;
    glCopyTexSubImage2D_load_with_dyn(&mut get_proc_address) as usize;
    glCopyTexSubImage3D_load_with_dyn(&mut get_proc_address) as usize;
    glCreateProgram_load_with_dyn(&mut get_proc_address) as usize;
    glCreateShader_load_with_dyn(&mut get_proc_address) as usize;
    glCullFace_load_with_dyn(&mut get_proc_address) as usize;
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    {
      glDebugMessageCallback_load_with_dyn(&mut get_proc_address) as usize;
    }
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    {
      glDebugMessageCallbackARB_load_with_dyn(&mut get_proc_address) as usize;
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    {
      glDebugMessageControl_load_with_dyn(&mut get_proc_address) as usize;
    }
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    {
      glDebugMessageControlARB_load_with_dyn(&mut get_proc_address) as usize;
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    {
      glDebugMessageInsert_load_with_dyn(&mut get_proc_address) as usize;
    }
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    {
      glDebugMessageInsertARB_load_with_dyn(&mut get_proc_address) as usize;
    }
    glDeleteBuffers_load_with_dyn(&mut get_proc_address) as usize;
    glDeleteFramebuffers_load_with_dyn(&mut get_proc_address) as usize;
    glDeleteProgram_load_with_dyn(&mut get_proc_address) as usize;
    glDeleteQueries_load_with_dyn(&mut get_proc_address) as usize;
    glDeleteRenderbuffers_load_with_dyn(&mut get_proc_address) as usize;
    glDeleteSamplers_load_with_dyn(&mut get_proc_address) as usize;
    glDeleteShader_load_with_dyn(&mut get_proc_address) as usize;
    glDeleteSync_load_with_dyn(&mut get_proc_address) as usize;
    glDeleteTextures_load_with_dyn(&mut get_proc_address) as usize;
    glDeleteVertexArrays_load_with_dyn(&mut get_proc_address) as usize;
    glDepthFunc_load_with_dyn(&mut get_proc_address) as usize;
    glDepthMask_load_with_dyn(&mut get_proc_address) as usize;
    glDepthRange_load_with_dyn(&mut get_proc_address) as usize;
    glDetachShader_load_with_dyn(&mut get_proc_address) as usize;
    glDisable_load_with_dyn(&mut get_proc_address) as usize;
    glDisableVertexAttribArray_load_with_dyn(&mut get_proc_address) as usize;
    glDisablei_load_with_dyn(&mut get_proc_address) as usize;
    glDrawArrays_load_with_dyn(&mut get_proc_address) as usize;
    glDrawArraysInstanced_load_with_dyn(&mut get_proc_address) as usize;
    glDrawBuffer_load_with_dyn(&mut get_proc_address) as usize;
    glDrawBuffers_load_with_dyn(&mut get_proc_address) as usize;
    glDrawElements_load_with_dyn(&mut get_proc_address) as usize;
    glDrawElementsBaseVertex_load_with_dyn(&mut get_proc_address) as usize;
    glDrawElementsInstanced_load_with_dyn(&mut get_proc_address) as usize;
    glDrawElementsInstancedBaseVertex_load_with_dyn(&mut get_proc_address)
      as usize;
    glDrawRangeElements_load_with_dyn(&mut get_proc_address) as usize;
    glDrawRangeElementsBaseVertex_load_with_dyn(&mut get_proc_address) as usize;
    glEnable_load_with_dyn(&mut get_proc_address) as usize;
    glEnableVertexAttribArray_load_with_dyn(&mut get_proc_address) as usize;
    glEnablei_load_with_dyn(&mut get_proc_address) as usize;
    glEndConditionalRender_load_with_dyn(&mut get_proc_address) as usize;
    glEndQuery_load_with_dyn(&mut get_proc_address) as usize;
    glEndTransformFeedback_load_with_dyn(&mut get_proc_address) as usize;
    glFenceSync_load_with_dyn(&mut get_proc_address) as usize;
    glFinish_load_with_dyn(&mut get_proc_address) as usize;
    glFlush_load_with_dyn(&mut get_proc_address) as usize;
    glFlushMappedBufferRange_load_with_dyn(&mut get_proc_address) as usize;
    glFramebufferRenderbuffer_load_with_dyn(&mut get_proc_address) as usize;
    glFramebufferTexture_load_with_dyn(&mut get_proc_address) as usize;
    glFramebufferTexture1D_load_with_dyn(&mut get_proc_address) as usize;
    glFramebufferTexture2D_load_with_dyn(&mut get_proc_address) as usize;
    glFramebufferTexture3D_load_with_dyn(&mut get_proc_address) as usize;
    glFramebufferTextureLayer_load_with_dyn(&mut get_proc_address) as usize;
    glFrontFace_load_with_dyn(&mut get_proc_address) as usize;
    glGenBuffers_load_with_dyn(&mut get_proc_address) as usize;
    glGenFramebuffers_load_with_dyn(&mut get_proc_address) as usize;
    glGenQueries_load_with_dyn(&mut get_proc_address) as usize;
    glGenRenderbuffers_load_with_dyn(&mut get_proc_address) as usize;
    glGenSamplers_load_with_dyn(&mut get_proc_address) as usize;
    glGenTextures_load_with_dyn(&mut get_proc_address) as usize;
    glGenVertexArrays_load_with_dyn(&mut get_proc_address) as usize;
    glGenerateMipmap_load_with_dyn(&mut get_proc_address) as usize;
    glGetActiveAttrib_load_with_dyn(&mut get_proc_address) as usize;
    glGetActiveUniform_load_with_dyn(&mut get_proc_address) as usize;
    glGetActiveUniformBlockName_load_with_dyn(&mut get_proc_address) as usize;
    glGetActiveUniformBlockiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetActiveUniformName_load_with_dyn(&mut get_proc_address) as usize;
    glGetActiveUniformsiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetAttachedShaders_load_with_dyn(&mut get_proc_address) as usize;
    glGetAttribLocation_load_with_dyn(&mut get_proc_address) as usize;
    glGetBooleani_v_load_with_dyn(&mut get_proc_address) as usize;
    glGetBooleanv_load_with_dyn(&mut get_proc_address) as usize;
    glGetBufferParameteri64v_load_with_dyn(&mut get_proc_address) as usize;
    glGetBufferParameteriv_load_with_dyn(&mut get_proc_address) as usize;
    glGetBufferPointerv_load_with_dyn(&mut get_proc_address) as usize;
    glGetBufferSubData_load_with_dyn(&mut get_proc_address) as usize;
    glGetCompressedTexImage_load_with_dyn(&mut get_proc_address) as usize;
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    {
      glGetDebugMessageLog_load_with_dyn(&mut get_proc_address) as usize;
    }
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    {
      glGetDebugMessageLogARB_load_with_dyn(&mut get_proc_address) as usize;
    }
    glGetDoublev_load_with_dyn(&mut get_proc_address) as usize;
    glGetError_load_with_dyn(&mut get_proc_address) as usize;
    glGetFloatv_load_with_dyn(&mut get_proc_address) as usize;
    glGetFragDataIndex_load_with_dyn(&mut get_proc_address) as usize;
    glGetFragDataLocation_load_with_dyn(&mut get_proc_address) as usize;
    glGetFramebufferAttachmentParameteriv_load_with_dyn(&mut get_proc_address)
      as usize;
    glGetInteger64i_v_load_with_dyn(&mut get_proc_address) as usize;
    glGetInteger64v_load_with_dyn(&mut get_proc_address) as usize;
    glGetIntegeri_v_load_with_dyn(&mut get_proc_address) as usize;
    glGetIntegerv_load_with_dyn(&mut get_proc_address) as usize;
    glGetMultisamplefv_load_with_dyn(&mut get_proc_address) as usize;
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    {
      glGetObjectLabel_load_with_dyn(&mut get_proc_address) as usize;
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    {
      glGetObjectPtrLabel_load_with_dyn(&mut get_proc_address) as usize;
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    {
      glGetPointerv_load_with_dyn(&mut get_proc_address) as usize;
    }
    glGetProgramInfoLog_load_with_dyn(&mut get_proc_address) as usize;
    glGetProgramiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetQueryObjecti64v_load_with_dyn(&mut get_proc_address) as usize;
    glGetQueryObjectiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetQueryObjectui64v_load_with_dyn(&mut get_proc_address) as usize;
    glGetQueryObjectuiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetQueryiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetRenderbufferParameteriv_load_with_dyn(&mut get_proc_address) as usize;
    glGetSamplerParameterIiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetSamplerParameterIuiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetSamplerParameterfv_load_with_dyn(&mut get_proc_address) as usize;
    glGetSamplerParameteriv_load_with_dyn(&mut get_proc_address) as usize;
    glGetShaderInfoLog_load_with_dyn(&mut get_proc_address) as usize;
    glGetShaderSource_load_with_dyn(&mut get_proc_address) as usize;
    glGetShaderiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetString_load_with_dyn(&mut get_proc_address) as usize;
    glGetStringi_load_with_dyn(&mut get_proc_address) as usize;
    glGetSynciv_load_with_dyn(&mut get_proc_address) as usize;
    glGetTexImage_load_with_dyn(&mut get_proc_address) as usize;
    glGetTexLevelParameterfv_load_with_dyn(&mut get_proc_address) as usize;
    glGetTexLevelParameteriv_load_with_dyn(&mut get_proc_address) as usize;
    glGetTexParameterIiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetTexParameterIuiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetTexParameterfv_load_with_dyn(&mut get_proc_address) as usize;
    glGetTexParameteriv_load_with_dyn(&mut get_proc_address) as usize;
    glGetTransformFeedbackVarying_load_with_dyn(&mut get_proc_address) as usize;
    glGetUniformBlockIndex_load_with_dyn(&mut get_proc_address) as usize;
    glGetUniformIndices_load_with_dyn(&mut get_proc_address) as usize;
    glGetUniformLocation_load_with_dyn(&mut get_proc_address) as usize;
    glGetUniformfv_load_with_dyn(&mut get_proc_address) as usize;
    glGetUniformiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetUniformuiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetVertexAttribIiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetVertexAttribIuiv_load_with_dyn(&mut get_proc_address) as usize;
    glGetVertexAttribPointerv_load_with_dyn(&mut get_proc_address) as usize;
    glGetVertexAttribdv_load_with_dyn(&mut get_proc_address) as usize;
    glGetVertexAttribfv_load_with_dyn(&mut get_proc_address) as usize;
    glGetVertexAttribiv_load_with_dyn(&mut get_proc_address) as usize;
    glHint_load_with_dyn(&mut get_proc_address) as usize;
    glIsBuffer_load_with_dyn(&mut get_proc_address) as usize;
    glIsEnabled_load_with_dyn(&mut get_proc_address) as usize;
    glIsEnabledi_load_with_dyn(&mut get_proc_address) as usize;
    glIsFramebuffer_load_with_dyn(&mut get_proc_address) as usize;
    glIsProgram_load_with_dyn(&mut get_proc_address) as usize;
    glIsQuery_load_with_dyn(&mut get_proc_address) as usize;
    glIsRenderbuffer_load_with_dyn(&mut get_proc_address) as usize;
    glIsSampler_load_with_dyn(&mut get_proc_address) as usize;
    glIsShader_load_with_dyn(&mut get_proc_address) as usize;
    glIsSync_load_with_dyn(&mut get_proc_address) as usize;
    glIsTexture_load_with_dyn(&mut get_proc_address) as usize;
    glIsVertexArray_load_with_dyn(&mut get_proc_address) as usize;
    glLineWidth_load_with_dyn(&mut get_proc_address) as usize;
    glLinkProgram_load_with_dyn(&mut get_proc_address) as usize;
    glLogicOp_load_with_dyn(&mut get_proc_address) as usize;
    glMapBuffer_load_with_dyn(&mut get_proc_address) as usize;
    glMapBufferRange_load_with_dyn(&mut get_proc_address) as usize;
    glMultiDrawArrays_load_with_dyn(&mut get_proc_address) as usize;
    glMultiDrawElements_load_with_dyn(&mut get_proc_address) as usize;
    glMultiDrawElementsBaseVertex_load_with_dyn(&mut get_proc_address) as usize;
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    {
      glObjectLabel_load_with_dyn(&mut get_proc_address) as usize;
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    {
      glObjectPtrLabel_load_with_dyn(&mut get_proc_address) as usize;
    }
    glPixelStoref_load_with_dyn(&mut get_proc_address) as usize;
    glPixelStorei_load_with_dyn(&mut get_proc_address) as usize;
    glPointParameterf_load_with_dyn(&mut get_proc_address) as usize;
    glPointParameterfv_load_with_dyn(&mut get_proc_address) as usize;
    glPointParameteri_load_with_dyn(&mut get_proc_address) as usize;
    glPointParameteriv_load_with_dyn(&mut get_proc_address) as usize;
    glPointSize_load_with_dyn(&mut get_proc_address) as usize;
    glPolygonMode_load_with_dyn(&mut get_proc_address) as usize;
    glPolygonOffset_load_with_dyn(&mut get_proc_address) as usize;
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    {
      glPopDebugGroup_load_with_dyn(&mut get_proc_address) as usize;
    }
    glPrimitiveRestartIndex_load_with_dyn(&mut get_proc_address) as usize;
    glProvokingVertex_load_with_dyn(&mut get_proc_address) as usize;
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    {
      glPushDebugGroup_load_with_dyn(&mut get_proc_address) as usize;
    }
    glQueryCounter_load_with_dyn(&mut get_proc_address) as usize;
    glReadBuffer_load_with_dyn(&mut get_proc_address) as usize;
    glReadPixels_load_with_dyn(&mut get_proc_address) as usize;
    glRenderbufferStorage_load_with_dyn(&mut get_proc_address) as usize;
    glRenderbufferStorageMultisample_load_with_dyn(&mut get_proc_address)
      as usize;
    glSampleCoverage_load_with_dyn(&mut get_proc_address) as usize;
    glSampleMaski_load_with_dyn(&mut get_proc_address) as usize;
    glSamplerParameterIiv_load_with_dyn(&mut get_proc_address) as usize;
    glSamplerParameterIuiv_load_with_dyn(&mut get_proc_address) as usize;
    glSamplerParameterf_load_with_dyn(&mut get_proc_address) as usize;
    glSamplerParameterfv_load_with_dyn(&mut get_proc_address) as usize;
    glSamplerParameteri_load_with_dyn(&mut get_proc_address) as usize;
    glSamplerParameteriv_load_with_dyn(&mut get_proc_address) as usize;
    glScissor_load_with_dyn(&mut get_proc_address) as usize;
    glShaderSource_load_with_dyn(&mut get_proc_address) as usize;
    glStencilFunc_load_with_dyn(&mut get_proc_address) as usize;
    glStencilFuncSeparate_load_with_dyn(&mut get_proc_address) as usize;
    glStencilMask_load_with_dyn(&mut get_proc_address) as usize;
    glStencilMaskSeparate_load_with_dyn(&mut get_proc_address) as usize;
    glStencilOp_load_with_dyn(&mut get_proc_address) as usize;
    glStencilOpSeparate_load_with_dyn(&mut get_proc_address) as usize;
    glTexBuffer_load_with_dyn(&mut get_proc_address) as usize;
    glTexImage1D_load_with_dyn(&mut get_proc_address) as usize;
    glTexImage2D_load_with_dyn(&mut get_proc_address) as usize;
    glTexImage2DMultisample_load_with_dyn(&mut get_proc_address) as usize;
    glTexImage3D_load_with_dyn(&mut get_proc_address) as usize;
    glTexImage3DMultisample_load_with_dyn(&mut get_proc_address) as usize;
    glTexParameterIiv_load_with_dyn(&mut get_proc_address) as usize;
    glTexParameterIuiv_load_with_dyn(&mut get_proc_address) as usize;
    glTexParameterf_load_with_dyn(&mut get_proc_address) as usize;
    glTexParameterfv_load_with_dyn(&mut get_proc_address) as usize;
    glTexParameteri_load_with_dyn(&mut get_proc_address) as usize;
    glTexParameteriv_load_with_dyn(&mut get_proc_address) as usize;
    glTexSubImage1D_load_with_dyn(&mut get_proc_address) as usize;
    glTexSubImage2D_load_with_dyn(&mut get_proc_address) as usize;
    glTexSubImage3D_load_with_dyn(&mut get_proc_address) as usize;
    glTransformFeedbackVaryings_load_with_dyn(&mut get_proc_address) as usize;
    glUniform1f_load_with_dyn(&mut get_proc_address) as usize;
    glUniform1fv_load_with_dyn(&mut get_proc_address) as usize;
    glUniform1i_load_with_dyn(&mut get_proc_address) as usize;
    glUniform1iv_load_with_dyn(&mut get_proc_address) as usize;
    glUniform1ui_load_with_dyn(&mut get_proc_address) as usize;
    glUniform1uiv_load_with_dyn(&mut get_proc_address) as usize;
    glUniform2f_load_with_dyn(&mut get_proc_address) as usize;
    glUniform2fv_load_with_dyn(&mut get_proc_address) as usize;
    glUniform2i_load_with_dyn(&mut get_proc_address) as usize;
    glUniform2iv_load_with_dyn(&mut get_proc_address) as usize;
    glUniform2ui_load_with_dyn(&mut get_proc_address) as usize;
    glUniform2uiv_load_with_dyn(&mut get_proc_address) as usize;
    glUniform3f_load_with_dyn(&mut get_proc_address) as usize;
    glUniform3fv_load_with_dyn(&mut get_proc_address) as usize;
    glUniform3i_load_with_dyn(&mut get_proc_address) as usize;
    glUniform3iv_load_with_dyn(&mut get_proc_address) as usize;
    glUniform3ui_load_with_dyn(&mut get_proc_address) as usize;
    glUniform3uiv_load_with_dyn(&mut get_proc_address) as usize;
    glUniform4f_load_with_dyn(&mut get_proc_address) as usize;
    glUniform4fv_load_with_dyn(&mut get_proc_address) as usize;
    glUniform4i_load_with_dyn(&mut get_proc_address) as usize;
    glUniform4iv_load_with_dyn(&mut get_proc_address) as usize;
    glUniform4ui_load_with_dyn(&mut get_proc_address) as usize;
    glUniform4uiv_load_with_dyn(&mut get_proc_address) as usize;
    glUniformBlockBinding_load_with_dyn(&mut get_proc_address) as usize;
    glUniformMatrix2fv_load_with_dyn(&mut get_proc_address) as usize;
    glUniformMatrix2x3fv_load_with_dyn(&mut get_proc_address) as usize;
    glUniformMatrix2x4fv_load_with_dyn(&mut get_proc_address) as usize;
    glUniformMatrix3fv_load_with_dyn(&mut get_proc_address) as usize;
    glUniformMatrix3x2fv_load_with_dyn(&mut get_proc_address) as usize;
    glUniformMatrix3x4fv_load_with_dyn(&mut get_proc_address) as usize;
    glUniformMatrix4fv_load_with_dyn(&mut get_proc_address) as usize;
    glUniformMatrix4x2fv_load_with_dyn(&mut get_proc_address) as usize;
    glUniformMatrix4x3fv_load_with_dyn(&mut get_proc_address) as usize;
    glUnmapBuffer_load_with_dyn(&mut get_proc_address) as usize;
    glUseProgram_load_with_dyn(&mut get_proc_address) as usize;
    glValidateProgram_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib1d_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib1dv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib1f_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib1fv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib1s_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib1sv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib2d_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib2dv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib2f_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib2fv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib2s_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib2sv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib3d_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib3dv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib3f_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib3fv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib3s_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib3sv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4Nbv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4Niv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4Nsv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4Nub_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4Nubv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4Nuiv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4Nusv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4bv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4d_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4dv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4f_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4fv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4iv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4s_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4sv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4ubv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4uiv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttrib4usv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribDivisor_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI1i_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI1iv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI1ui_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI1uiv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI2i_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI2iv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI2ui_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI2uiv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI3i_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI3iv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI3ui_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI3uiv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI4bv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI4i_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI4iv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI4sv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI4ubv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI4ui_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI4uiv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribI4usv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribIPointer_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribP1ui_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribP1uiv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribP2ui_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribP2uiv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribP3ui_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribP3uiv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribP4ui_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribP4uiv_load_with_dyn(&mut get_proc_address) as usize;
    glVertexAttribPointer_load_with_dyn(&mut get_proc_address) as usize;
    glViewport_load_with_dyn(&mut get_proc_address) as usize;
    glWaitSync_load_with_dyn(&mut get_proc_address) as usize;
  }

  /// [glActiveTexture](http://docs.gl/gl3/glActiveTexture)(texture)
  /// * `texture` group: TextureUnit
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glActiveTexture(texture: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glActiveTexture({:#X});", texture);
    }
    let out =
      call_atomic_ptr_1arg("glActiveTexture", &glActiveTexture_p, texture);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glActiveTexture");
    }
    out
  }
  static glActiveTexture_p: APcv = ap_null();
  /// Tries to load [`glActiveTexture`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glActiveTexture_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glActiveTexture\0",
      &glActiveTexture_p,
    )
  }
  /// Checks if the pointer for [`glActiveTexture`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glActiveTexture_is_loaded() -> bool {
    !glActiveTexture_p.load(RELAX).is_null()
  }

  /// [glAttachShader](http://docs.gl/gl3/glAttachShader)(program, shader)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glAttachShader(program: GLuint, shader: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glAttachShader({:?}, {:?});", program, shader);
    }
    let out = call_atomic_ptr_2arg(
      "glAttachShader",
      &glAttachShader_p,
      program,
      shader,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glAttachShader");
    }
    out
  }
  static glAttachShader_p: APcv = ap_null();
  /// Tries to load [`glAttachShader`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glAttachShader_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glAttachShader\0",
      &glAttachShader_p,
    )
  }
  /// Checks if the pointer for [`glAttachShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glAttachShader_is_loaded() -> bool {
    !glAttachShader_p.load(RELAX).is_null()
  }

  /// [glBeginConditionalRender](http://docs.gl/gl3/glBeginConditionalRender)(id, mode)
  /// * `mode` group: ConditionalRenderMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBeginConditionalRender(id: GLuint, mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBeginConditionalRender({:?}, {:#X});", id, mode);
    }
    let out = call_atomic_ptr_2arg(
      "glBeginConditionalRender",
      &glBeginConditionalRender_p,
      id,
      mode,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBeginConditionalRender");
    }
    out
  }
  static glBeginConditionalRender_p: APcv = ap_null();
  /// Tries to load [`glBeginConditionalRender`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glBeginConditionalRender_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBeginConditionalRender\0",
      &glBeginConditionalRender_p,
    )
  }
  /// Checks if the pointer for [`glBeginConditionalRender`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBeginConditionalRender_is_loaded() -> bool {
    !glBeginConditionalRender_p.load(RELAX).is_null()
  }

  /// [glBeginQuery](http://docs.gl/gl3/glBeginQuery)(target, id)
  /// * `target` group: QueryTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBeginQuery(target: GLenum, id: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBeginQuery({:#X}, {:?});", target, id);
    }
    let out = call_atomic_ptr_2arg("glBeginQuery", &glBeginQuery_p, target, id);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBeginQuery");
    }
    out
  }
  static glBeginQuery_p: APcv = ap_null();
  /// Tries to load [`glBeginQuery`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBeginQuery_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBeginQuery\0",
      &glBeginQuery_p,
    )
  }
  /// Checks if the pointer for [`glBeginQuery`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBeginQuery_is_loaded() -> bool {
    !glBeginQuery_p.load(RELAX).is_null()
  }

  /// [glBeginTransformFeedback](http://docs.gl/gl3/glBeginTransformFeedback)(primitiveMode)
  /// * `primitiveMode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBeginTransformFeedback(primitiveMode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBeginTransformFeedback({:#X});", primitiveMode);
    }
    let out = call_atomic_ptr_1arg(
      "glBeginTransformFeedback",
      &glBeginTransformFeedback_p,
      primitiveMode,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBeginTransformFeedback");
    }
    out
  }
  static glBeginTransformFeedback_p: APcv = ap_null();
  /// Tries to load [`glBeginTransformFeedback`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glBeginTransformFeedback_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBeginTransformFeedback\0",
      &glBeginTransformFeedback_p,
    )
  }
  /// Checks if the pointer for [`glBeginTransformFeedback`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBeginTransformFeedback_is_loaded() -> bool {
    !glBeginTransformFeedback_p.load(RELAX).is_null()
  }

  /// [glBindAttribLocation](http://docs.gl/gl3/glBindAttribLocation)(program, index, name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindAttribLocation(
    program: GLuint, index: GLuint, name: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindAttribLocation({:?}, {:?}, {:p});",
        program,
        index,
        name
      );
    }
    let out = call_atomic_ptr_3arg(
      "glBindAttribLocation",
      &glBindAttribLocation_p,
      program,
      index,
      name,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBindAttribLocation");
    }
    out
  }
  static glBindAttribLocation_p: APcv = ap_null();
  /// Tries to load [`glBindAttribLocation`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBindAttribLocation_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBindAttribLocation\0",
      &glBindAttribLocation_p,
    )
  }
  /// Checks if the pointer for [`glBindAttribLocation`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindAttribLocation_is_loaded() -> bool {
    !glBindAttribLocation_p.load(RELAX).is_null()
  }

  /// [glBindBuffer](http://docs.gl/gl3/glBindBuffer)(target, buffer)
  /// * `target` group: BufferTargetARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindBuffer(target: GLenum, buffer: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindBuffer({:#X}, {:?});", target, buffer);
    }
    let out =
      call_atomic_ptr_2arg("glBindBuffer", &glBindBuffer_p, target, buffer);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBindBuffer");
    }
    out
  }
  static glBindBuffer_p: APcv = ap_null();
  /// Tries to load [`glBindBuffer`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBindBuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBindBuffer\0",
      &glBindBuffer_p,
    )
  }
  /// Checks if the pointer for [`glBindBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindBuffer_is_loaded() -> bool {
    !glBindBuffer_p.load(RELAX).is_null()
  }

  /// [glBindBufferBase](http://docs.gl/gl3/glBindBufferBase)(target, index, buffer)
  /// * `target` group: BufferTargetARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindBufferBase(
    target: GLenum, index: GLuint, buffer: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindBufferBase({:#X}, {:?}, {:?});",
        target,
        index,
        buffer
      );
    }
    let out = call_atomic_ptr_3arg(
      "glBindBufferBase",
      &glBindBufferBase_p,
      target,
      index,
      buffer,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBindBufferBase");
    }
    out
  }
  static glBindBufferBase_p: APcv = ap_null();
  /// Tries to load [`glBindBufferBase`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBindBufferBase_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBindBufferBase\0",
      &glBindBufferBase_p,
    )
  }
  /// Checks if the pointer for [`glBindBufferBase`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindBufferBase_is_loaded() -> bool {
    !glBindBufferBase_p.load(RELAX).is_null()
  }

  /// [glBindBufferRange](http://docs.gl/gl3/glBindBufferRange)(target, index, buffer, offset, size)
  /// * `target` group: BufferTargetARB
  /// * `offset` group: BufferOffset
  /// * `size` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindBufferRange(
    target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr,
    size: GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindBufferRange({:#X}, {:?}, {:?}, {:?}, {:?});",
        target,
        index,
        buffer,
        offset,
        size
      );
    }
    let out = call_atomic_ptr_5arg(
      "glBindBufferRange",
      &glBindBufferRange_p,
      target,
      index,
      buffer,
      offset,
      size,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBindBufferRange");
    }
    out
  }
  static glBindBufferRange_p: APcv = ap_null();
  /// Tries to load [`glBindBufferRange`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBindBufferRange_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBindBufferRange\0",
      &glBindBufferRange_p,
    )
  }
  /// Checks if the pointer for [`glBindBufferRange`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindBufferRange_is_loaded() -> bool {
    !glBindBufferRange_p.load(RELAX).is_null()
  }

  /// [glBindFragDataLocation](http://docs.gl/gl3/glBindFragDataLocation)(program, color, name)
  /// * `name` len: COMPSIZE(name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindFragDataLocation(
    program: GLuint, color: GLuint, name: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindFragDataLocation({:?}, {:?}, {:p});",
        program,
        color,
        name
      );
    }
    let out = call_atomic_ptr_3arg(
      "glBindFragDataLocation",
      &glBindFragDataLocation_p,
      program,
      color,
      name,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBindFragDataLocation");
    }
    out
  }
  static glBindFragDataLocation_p: APcv = ap_null();
  /// Tries to load [`glBindFragDataLocation`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glBindFragDataLocation_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBindFragDataLocation\0",
      &glBindFragDataLocation_p,
    )
  }
  /// Checks if the pointer for [`glBindFragDataLocation`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindFragDataLocation_is_loaded() -> bool {
    !glBindFragDataLocation_p.load(RELAX).is_null()
  }

  /// [glBindFragDataLocationIndexed](http://docs.gl/gl3/glBindFragDataLocationIndexed)(program, colorNumber, index, name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindFragDataLocationIndexed(
    program: GLuint, colorNumber: GLuint, index: GLuint, name: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindFragDataLocationIndexed({:?}, {:?}, {:?}, {:p});",
        program,
        colorNumber,
        index,
        name
      );
    }
    let out = call_atomic_ptr_4arg(
      "glBindFragDataLocationIndexed",
      &glBindFragDataLocationIndexed_p,
      program,
      colorNumber,
      index,
      name,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBindFragDataLocationIndexed");
    }
    out
  }
  static glBindFragDataLocationIndexed_p: APcv = ap_null();
  /// Tries to load [`glBindFragDataLocationIndexed`], returns if a non-null
  /// pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glBindFragDataLocationIndexed_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBindFragDataLocationIndexed\0",
      &glBindFragDataLocationIndexed_p,
    )
  }
  /// Checks if the pointer for [`glBindFragDataLocationIndexed`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindFragDataLocationIndexed_is_loaded() -> bool {
    !glBindFragDataLocationIndexed_p.load(RELAX).is_null()
  }

  /// [glBindFramebuffer](http://docs.gl/gl3/glBindFramebuffer)(target, framebuffer)
  /// * `target` group: FramebufferTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindFramebuffer(target: GLenum, framebuffer: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindFramebuffer({:#X}, {:?});", target, framebuffer);
    }
    let out = call_atomic_ptr_2arg(
      "glBindFramebuffer",
      &glBindFramebuffer_p,
      target,
      framebuffer,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBindFramebuffer");
    }
    out
  }
  static glBindFramebuffer_p: APcv = ap_null();
  /// Tries to load [`glBindFramebuffer`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBindFramebuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBindFramebuffer\0",
      &glBindFramebuffer_p,
    )
  }
  /// Checks if the pointer for [`glBindFramebuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindFramebuffer_is_loaded() -> bool {
    !glBindFramebuffer_p.load(RELAX).is_null()
  }

  /// [glBindRenderbuffer](http://docs.gl/gl3/glBindRenderbuffer)(target, renderbuffer)
  /// * `target` group: RenderbufferTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindRenderbuffer(target: GLenum, renderbuffer: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindRenderbuffer({:#X}, {:?});", target, renderbuffer);
    }
    let out = call_atomic_ptr_2arg(
      "glBindRenderbuffer",
      &glBindRenderbuffer_p,
      target,
      renderbuffer,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBindRenderbuffer");
    }
    out
  }
  static glBindRenderbuffer_p: APcv = ap_null();
  /// Tries to load [`glBindRenderbuffer`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBindRenderbuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBindRenderbuffer\0",
      &glBindRenderbuffer_p,
    )
  }
  /// Checks if the pointer for [`glBindRenderbuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindRenderbuffer_is_loaded() -> bool {
    !glBindRenderbuffer_p.load(RELAX).is_null()
  }

  /// [glBindSampler](http://docs.gl/gl3/glBindSampler)(unit, sampler)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindSampler(unit: GLuint, sampler: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindSampler({:?}, {:?});", unit, sampler);
    }
    let out =
      call_atomic_ptr_2arg("glBindSampler", &glBindSampler_p, unit, sampler);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBindSampler");
    }
    out
  }
  static glBindSampler_p: APcv = ap_null();
  /// Tries to load [`glBindSampler`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBindSampler_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBindSampler\0",
      &glBindSampler_p,
    )
  }
  /// Checks if the pointer for [`glBindSampler`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindSampler_is_loaded() -> bool {
    !glBindSampler_p.load(RELAX).is_null()
  }

  /// [glBindTexture](http://docs.gl/gl3/glBindTexture)(target, texture)
  /// * `target` group: TextureTarget
  /// * `texture` group: Texture
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindTexture(target: GLenum, texture: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindTexture({:#X}, {:?});", target, texture);
    }
    let out =
      call_atomic_ptr_2arg("glBindTexture", &glBindTexture_p, target, texture);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBindTexture");
    }
    out
  }
  static glBindTexture_p: APcv = ap_null();
  /// Tries to load [`glBindTexture`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBindTexture_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBindTexture\0",
      &glBindTexture_p,
    )
  }
  /// Checks if the pointer for [`glBindTexture`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindTexture_is_loaded() -> bool {
    !glBindTexture_p.load(RELAX).is_null()
  }

  /// [glBindVertexArray](http://docs.gl/gl3/glBindVertexArray)(array)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindVertexArray(array: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindVertexArray({:?});", array);
    }
    let out =
      call_atomic_ptr_1arg("glBindVertexArray", &glBindVertexArray_p, array);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBindVertexArray");
    }
    out
  }
  static glBindVertexArray_p: APcv = ap_null();
  /// Tries to load [`glBindVertexArray`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBindVertexArray_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBindVertexArray\0",
      &glBindVertexArray_p,
    )
  }
  /// Checks if the pointer for [`glBindVertexArray`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindVertexArray_is_loaded() -> bool {
    !glBindVertexArray_p.load(RELAX).is_null()
  }

  /// [glBlendColor](http://docs.gl/gl3/glBlendColor)(red, green, blue, alpha)
  /// * `red` group: ColorF
  /// * `green` group: ColorF
  /// * `blue` group: ColorF
  /// * `alpha` group: ColorF
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendColor(
    red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBlendColor({:?}, {:?}, {:?}, {:?});",
        red,
        green,
        blue,
        alpha
      );
    }
    let out = call_atomic_ptr_4arg(
      "glBlendColor",
      &glBlendColor_p,
      red,
      green,
      blue,
      alpha,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBlendColor");
    }
    out
  }
  static glBlendColor_p: APcv = ap_null();
  /// Tries to load [`glBlendColor`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBlendColor_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBlendColor\0",
      &glBlendColor_p,
    )
  }
  /// Checks if the pointer for [`glBlendColor`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendColor_is_loaded() -> bool {
    !glBlendColor_p.load(RELAX).is_null()
  }

  /// [glBlendEquation](http://docs.gl/gl3/glBlendEquation)(mode)
  /// * `mode` group: BlendEquationModeEXT
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendEquation(mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBlendEquation({:#X});", mode);
    }
    let out = call_atomic_ptr_1arg("glBlendEquation", &glBlendEquation_p, mode);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBlendEquation");
    }
    out
  }
  static glBlendEquation_p: APcv = ap_null();
  /// Tries to load [`glBlendEquation`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBlendEquation_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBlendEquation\0",
      &glBlendEquation_p,
    )
  }
  /// Checks if the pointer for [`glBlendEquation`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendEquation_is_loaded() -> bool {
    !glBlendEquation_p.load(RELAX).is_null()
  }

  /// [glBlendEquationSeparate](http://docs.gl/gl3/glBlendEquationSeparate)(modeRGB, modeAlpha)
  /// * `modeRGB` group: BlendEquationModeEXT
  /// * `modeAlpha` group: BlendEquationModeEXT
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBlendEquationSeparate({:#X}, {:#X});",
        modeRGB,
        modeAlpha
      );
    }
    let out = call_atomic_ptr_2arg(
      "glBlendEquationSeparate",
      &glBlendEquationSeparate_p,
      modeRGB,
      modeAlpha,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBlendEquationSeparate");
    }
    out
  }
  static glBlendEquationSeparate_p: APcv = ap_null();
  /// Tries to load [`glBlendEquationSeparate`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glBlendEquationSeparate_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBlendEquationSeparate\0",
      &glBlendEquationSeparate_p,
    )
  }
  /// Checks if the pointer for [`glBlendEquationSeparate`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendEquationSeparate_is_loaded() -> bool {
    !glBlendEquationSeparate_p.load(RELAX).is_null()
  }

  /// [glBlendFunc](http://docs.gl/gl3/glBlendFunc)(sfactor, dfactor)
  /// * `sfactor` group: BlendingFactor
  /// * `dfactor` group: BlendingFactor
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendFunc(sfactor: GLenum, dfactor: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBlendFunc({:#X}, {:#X});", sfactor, dfactor);
    }
    let out =
      call_atomic_ptr_2arg("glBlendFunc", &glBlendFunc_p, sfactor, dfactor);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBlendFunc");
    }
    out
  }
  static glBlendFunc_p: APcv = ap_null();
  /// Tries to load [`glBlendFunc`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glBlendFunc_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glBlendFunc\0", &glBlendFunc_p)
  }
  /// Checks if the pointer for [`glBlendFunc`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendFunc_is_loaded() -> bool {
    !glBlendFunc_p.load(RELAX).is_null()
  }

  /// [glBlendFuncSeparate](http://docs.gl/gl3/glBlendFuncSeparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)
  /// * `sfactorRGB` group: BlendingFactor
  /// * `dfactorRGB` group: BlendingFactor
  /// * `sfactorAlpha` group: BlendingFactor
  /// * `dfactorAlpha` group: BlendingFactor
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendFuncSeparate(
    sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum,
    dfactorAlpha: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBlendFuncSeparate({:#X}, {:#X}, {:#X}, {:#X});",
        sfactorRGB,
        dfactorRGB,
        sfactorAlpha,
        dfactorAlpha
      );
    }
    let out = call_atomic_ptr_4arg(
      "glBlendFuncSeparate",
      &glBlendFuncSeparate_p,
      sfactorRGB,
      dfactorRGB,
      sfactorAlpha,
      dfactorAlpha,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBlendFuncSeparate");
    }
    out
  }
  static glBlendFuncSeparate_p: APcv = ap_null();
  /// Tries to load [`glBlendFuncSeparate`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBlendFuncSeparate_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBlendFuncSeparate\0",
      &glBlendFuncSeparate_p,
    )
  }
  /// Checks if the pointer for [`glBlendFuncSeparate`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendFuncSeparate_is_loaded() -> bool {
    !glBlendFuncSeparate_p.load(RELAX).is_null()
  }

  /// [glBlitFramebuffer](http://docs.gl/gl3/glBlitFramebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
  /// * `mask` group: ClearBufferMask
  /// * `filter` group: BlitFramebufferFilter
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlitFramebuffer(
    srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint,
    dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBlitFramebuffer({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X});", srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    }
    let out = call_atomic_ptr_10arg(
      "glBlitFramebuffer",
      &glBlitFramebuffer_p,
      srcX0,
      srcY0,
      srcX1,
      srcY1,
      dstX0,
      dstY0,
      dstX1,
      dstY1,
      mask,
      filter,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBlitFramebuffer");
    }
    out
  }
  static glBlitFramebuffer_p: APcv = ap_null();
  /// Tries to load [`glBlitFramebuffer`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBlitFramebuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBlitFramebuffer\0",
      &glBlitFramebuffer_p,
    )
  }
  /// Checks if the pointer for [`glBlitFramebuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlitFramebuffer_is_loaded() -> bool {
    !glBlitFramebuffer_p.load(RELAX).is_null()
  }

  /// [glBufferData](http://docs.gl/gl3/glBufferData)(target, size, data, usage)
  /// * `target` group: BufferTargetARB
  /// * `size` group: BufferSize
  /// * `data` len: size
  /// * `usage` group: BufferUsageARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBufferData(
    target: GLenum, size: GLsizeiptr, data: *const c_void, usage: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBufferData({:#X}, {:?}, {:p}, {:#X});",
        target,
        size,
        data,
        usage
      );
    }
    let out = call_atomic_ptr_4arg(
      "glBufferData",
      &glBufferData_p,
      target,
      size,
      data,
      usage,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBufferData");
    }
    out
  }
  static glBufferData_p: APcv = ap_null();
  /// Tries to load [`glBufferData`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBufferData_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBufferData\0",
      &glBufferData_p,
    )
  }
  /// Checks if the pointer for [`glBufferData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBufferData_is_loaded() -> bool {
    !glBufferData_p.load(RELAX).is_null()
  }

  /// [glBufferSubData](http://docs.gl/gl3/glBufferSubData)(target, offset, size, data)
  /// * `target` group: BufferTargetARB
  /// * `offset` group: BufferOffset
  /// * `size` group: BufferSize
  /// * `data` len: size
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBufferSubData(
    target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBufferSubData({:#X}, {:?}, {:?}, {:p});",
        target,
        offset,
        size,
        data
      );
    }
    let out = call_atomic_ptr_4arg(
      "glBufferSubData",
      &glBufferSubData_p,
      target,
      offset,
      size,
      data,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glBufferSubData");
    }
    out
  }
  static glBufferSubData_p: APcv = ap_null();
  /// Tries to load [`glBufferSubData`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glBufferSubData_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glBufferSubData\0",
      &glBufferSubData_p,
    )
  }
  /// Checks if the pointer for [`glBufferSubData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBufferSubData_is_loaded() -> bool {
    !glBufferSubData_p.load(RELAX).is_null()
  }

  /// [glCheckFramebufferStatus](http://docs.gl/gl3/glCheckFramebufferStatus)(target)
  /// * `target` group: FramebufferTarget
  /// * return value group: FramebufferStatus
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCheckFramebufferStatus(target: GLenum) -> GLenum {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCheckFramebufferStatus({:#X});", target);
    }
    let out = call_atomic_ptr_1arg(
      "glCheckFramebufferStatus",
      &glCheckFramebufferStatus_p,
      target,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCheckFramebufferStatus");
    }
    out
  }
  static glCheckFramebufferStatus_p: APcv = ap_null();
  /// Tries to load [`glCheckFramebufferStatus`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glCheckFramebufferStatus_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCheckFramebufferStatus\0",
      &glCheckFramebufferStatus_p,
    )
  }
  /// Checks if the pointer for [`glCheckFramebufferStatus`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCheckFramebufferStatus_is_loaded() -> bool {
    !glCheckFramebufferStatus_p.load(RELAX).is_null()
  }

  /// [glClampColor](http://docs.gl/gl3/glClampColor)(target, clamp)
  /// * `target` group: ClampColorTargetARB
  /// * `clamp` group: ClampColorModeARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClampColor(target: GLenum, clamp: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClampColor({:#X}, {:#X});", target, clamp);
    }
    let out =
      call_atomic_ptr_2arg("glClampColor", &glClampColor_p, target, clamp);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glClampColor");
    }
    out
  }
  static glClampColor_p: APcv = ap_null();
  /// Tries to load [`glClampColor`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glClampColor_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glClampColor\0",
      &glClampColor_p,
    )
  }
  /// Checks if the pointer for [`glClampColor`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClampColor_is_loaded() -> bool {
    !glClampColor_p.load(RELAX).is_null()
  }

  /// [glClear](http://docs.gl/gl3/glClear)(mask)
  /// * `mask` group: ClearBufferMask
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClear(mask: GLbitfield) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClear({:?});", mask);
    }
    let out = call_atomic_ptr_1arg("glClear", &glClear_p, mask);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glClear");
    }
    out
  }
  static glClear_p: APcv = ap_null();
  /// Tries to load [`glClear`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glClear_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glClear\0", &glClear_p)
  }
  /// Checks if the pointer for [`glClear`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClear_is_loaded() -> bool {
    !glClear_p.load(RELAX).is_null()
  }

  /// [glClearBufferfi](http://docs.gl/gl3/glClearBuffer)(buffer, drawbuffer, depth, stencil)
  /// * `buffer` group: Buffer
  /// * `drawbuffer` group: DrawBufferName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearBufferfi(
    buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearBufferfi({:#X}, {:?}, {:?}, {:?});",
        buffer,
        drawbuffer,
        depth,
        stencil
      );
    }
    let out = call_atomic_ptr_4arg(
      "glClearBufferfi",
      &glClearBufferfi_p,
      buffer,
      drawbuffer,
      depth,
      stencil,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glClearBufferfi");
    }
    out
  }
  static glClearBufferfi_p: APcv = ap_null();
  /// Tries to load [`glClearBufferfi`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glClearBufferfi_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glClearBufferfi\0",
      &glClearBufferfi_p,
    )
  }
  /// Checks if the pointer for [`glClearBufferfi`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearBufferfi_is_loaded() -> bool {
    !glClearBufferfi_p.load(RELAX).is_null()
  }

  /// [glClearBufferfv](http://docs.gl/gl3/glClearBuffer)(buffer, drawbuffer, value)
  /// * `buffer` group: Buffer
  /// * `drawbuffer` group: DrawBufferName
  /// * `value` len: COMPSIZE(buffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearBufferfv(
    buffer: GLenum, drawbuffer: GLint, value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearBufferfv({:#X}, {:?}, {:p});",
        buffer,
        drawbuffer,
        value
      );
    }
    let out = call_atomic_ptr_3arg(
      "glClearBufferfv",
      &glClearBufferfv_p,
      buffer,
      drawbuffer,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glClearBufferfv");
    }
    out
  }
  static glClearBufferfv_p: APcv = ap_null();
  /// Tries to load [`glClearBufferfv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glClearBufferfv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glClearBufferfv\0",
      &glClearBufferfv_p,
    )
  }
  /// Checks if the pointer for [`glClearBufferfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearBufferfv_is_loaded() -> bool {
    !glClearBufferfv_p.load(RELAX).is_null()
  }

  /// [glClearBufferiv](http://docs.gl/gl3/glClearBuffer)(buffer, drawbuffer, value)
  /// * `buffer` group: Buffer
  /// * `drawbuffer` group: DrawBufferName
  /// * `value` len: COMPSIZE(buffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearBufferiv(
    buffer: GLenum, drawbuffer: GLint, value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearBufferiv({:#X}, {:?}, {:p});",
        buffer,
        drawbuffer,
        value
      );
    }
    let out = call_atomic_ptr_3arg(
      "glClearBufferiv",
      &glClearBufferiv_p,
      buffer,
      drawbuffer,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glClearBufferiv");
    }
    out
  }
  static glClearBufferiv_p: APcv = ap_null();
  /// Tries to load [`glClearBufferiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glClearBufferiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glClearBufferiv\0",
      &glClearBufferiv_p,
    )
  }
  /// Checks if the pointer for [`glClearBufferiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearBufferiv_is_loaded() -> bool {
    !glClearBufferiv_p.load(RELAX).is_null()
  }

  /// [glClearBufferuiv](http://docs.gl/gl3/glClearBuffer)(buffer, drawbuffer, value)
  /// * `buffer` group: Buffer
  /// * `drawbuffer` group: DrawBufferName
  /// * `value` len: COMPSIZE(buffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearBufferuiv(
    buffer: GLenum, drawbuffer: GLint, value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearBufferuiv({:#X}, {:?}, {:p});",
        buffer,
        drawbuffer,
        value
      );
    }
    let out = call_atomic_ptr_3arg(
      "glClearBufferuiv",
      &glClearBufferuiv_p,
      buffer,
      drawbuffer,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glClearBufferuiv");
    }
    out
  }
  static glClearBufferuiv_p: APcv = ap_null();
  /// Tries to load [`glClearBufferuiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glClearBufferuiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glClearBufferuiv\0",
      &glClearBufferuiv_p,
    )
  }
  /// Checks if the pointer for [`glClearBufferuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearBufferuiv_is_loaded() -> bool {
    !glClearBufferuiv_p.load(RELAX).is_null()
  }

  /// [glClearColor](http://docs.gl/gl3/glClearColor)(red, green, blue, alpha)
  /// * `red` group: ColorF
  /// * `green` group: ColorF
  /// * `blue` group: ColorF
  /// * `alpha` group: ColorF
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearColor(
    red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearColor({:?}, {:?}, {:?}, {:?});",
        red,
        green,
        blue,
        alpha
      );
    }
    let out = call_atomic_ptr_4arg(
      "glClearColor",
      &glClearColor_p,
      red,
      green,
      blue,
      alpha,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glClearColor");
    }
    out
  }
  static glClearColor_p: APcv = ap_null();
  /// Tries to load [`glClearColor`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glClearColor_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glClearColor\0",
      &glClearColor_p,
    )
  }
  /// Checks if the pointer for [`glClearColor`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearColor_is_loaded() -> bool {
    !glClearColor_p.load(RELAX).is_null()
  }

  /// [glClearDepth](http://docs.gl/gl3/glClearDepth)(depth)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearDepth(depth: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClearDepth({:?});", depth);
    }
    let out = call_atomic_ptr_1arg("glClearDepth", &glClearDepth_p, depth);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glClearDepth");
    }
    out
  }
  static glClearDepth_p: APcv = ap_null();
  /// Tries to load [`glClearDepth`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glClearDepth_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glClearDepth\0",
      &glClearDepth_p,
    )
  }
  /// Checks if the pointer for [`glClearDepth`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearDepth_is_loaded() -> bool {
    !glClearDepth_p.load(RELAX).is_null()
  }

  /// [glClearStencil](http://docs.gl/gl3/glClearStencil)(s)
  /// * `s` group: StencilValue
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearStencil(s: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClearStencil({:?});", s);
    }
    let out = call_atomic_ptr_1arg("glClearStencil", &glClearStencil_p, s);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glClearStencil");
    }
    out
  }
  static glClearStencil_p: APcv = ap_null();
  /// Tries to load [`glClearStencil`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glClearStencil_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glClearStencil\0",
      &glClearStencil_p,
    )
  }
  /// Checks if the pointer for [`glClearStencil`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearStencil_is_loaded() -> bool {
    !glClearStencil_p.load(RELAX).is_null()
  }

  /// [glClientWaitSync](http://docs.gl/gl3/glClientWaitSync)(sync, flags, timeout)
  /// * `sync` group: sync
  /// * `flags` group: SyncObjectMask
  /// * return value group: SyncStatus
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClientWaitSync(
    sync: GLsync, flags: GLbitfield, timeout: GLuint64,
  ) -> GLenum {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClientWaitSync({:p}, {:?}, {:?});",
        sync,
        flags,
        timeout
      );
    }
    let out = call_atomic_ptr_3arg(
      "glClientWaitSync",
      &glClientWaitSync_p,
      sync,
      flags,
      timeout,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glClientWaitSync");
    }
    out
  }
  static glClientWaitSync_p: APcv = ap_null();
  /// Tries to load [`glClientWaitSync`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glClientWaitSync_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glClientWaitSync\0",
      &glClientWaitSync_p,
    )
  }
  /// Checks if the pointer for [`glClientWaitSync`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClientWaitSync_is_loaded() -> bool {
    !glClientWaitSync_p.load(RELAX).is_null()
  }

  /// [glColorMask](http://docs.gl/gl3/glColorMask)(red, green, blue, alpha)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glColorMask(
    red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glColorMask({:?}, {:?}, {:?}, {:?});",
        red,
        green,
        blue,
        alpha
      );
    }
    let out = call_atomic_ptr_4arg(
      "glColorMask",
      &glColorMask_p,
      red,
      green,
      blue,
      alpha,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glColorMask");
    }
    out
  }
  static glColorMask_p: APcv = ap_null();
  /// Tries to load [`glColorMask`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glColorMask_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glColorMask\0", &glColorMask_p)
  }
  /// Checks if the pointer for [`glColorMask`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glColorMask_is_loaded() -> bool {
    !glColorMask_p.load(RELAX).is_null()
  }

  /// [glColorMaski](http://docs.gl/gl3/glColorMask)(index, r, g, b, a)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glColorMaski(
    index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glColorMaski({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        r,
        g,
        b,
        a
      );
    }
    let out =
      call_atomic_ptr_5arg("glColorMaski", &glColorMaski_p, index, r, g, b, a);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glColorMaski");
    }
    out
  }
  static glColorMaski_p: APcv = ap_null();
  /// Tries to load [`glColorMaski`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glColorMaski_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glColorMaski\0",
      &glColorMaski_p,
    )
  }
  /// Checks if the pointer for [`glColorMaski`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glColorMaski_is_loaded() -> bool {
    !glColorMaski_p.load(RELAX).is_null()
  }

  /// [glCompileShader](http://docs.gl/gl3/glCompileShader)(shader)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompileShader(shader: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompileShader({:?});", shader);
    }
    let out =
      call_atomic_ptr_1arg("glCompileShader", &glCompileShader_p, shader);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCompileShader");
    }
    out
  }
  static glCompileShader_p: APcv = ap_null();
  /// Tries to load [`glCompileShader`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glCompileShader_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCompileShader\0",
      &glCompileShader_p,
    )
  }
  /// Checks if the pointer for [`glCompileShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompileShader_is_loaded() -> bool {
    !glCompileShader_p.load(RELAX).is_null()
  }

  /// [glCompressedTexImage1D](http://docs.gl/gl3/glCompressedTexImage1D)(target, level, internalformat, width, border, imageSize, data)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `border` group: CheckedInt32
  /// * `data` group: CompressedTextureARB
  /// * `data` len: imageSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTexImage1D(
    target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei,
    border: GLint, imageSize: GLsizei, data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTexImage1D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, border, imageSize, data);
    }
    let out = call_atomic_ptr_7arg(
      "glCompressedTexImage1D",
      &glCompressedTexImage1D_p,
      target,
      level,
      internalformat,
      width,
      border,
      imageSize,
      data,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCompressedTexImage1D");
    }
    out
  }
  static glCompressedTexImage1D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTexImage1D`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glCompressedTexImage1D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCompressedTexImage1D\0",
      &glCompressedTexImage1D_p,
    )
  }
  /// Checks if the pointer for [`glCompressedTexImage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTexImage1D_is_loaded() -> bool {
    !glCompressedTexImage1D_p.load(RELAX).is_null()
  }

  /// [glCompressedTexImage2D](http://docs.gl/gl3/glCompressedTexImage2D)(target, level, internalformat, width, height, border, imageSize, data)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `border` group: CheckedInt32
  /// * `data` group: CompressedTextureARB
  /// * `data` len: imageSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTexImage2D(
    target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei,
    height: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTexImage2D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, height, border, imageSize, data);
    }
    let out = call_atomic_ptr_8arg(
      "glCompressedTexImage2D",
      &glCompressedTexImage2D_p,
      target,
      level,
      internalformat,
      width,
      height,
      border,
      imageSize,
      data,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCompressedTexImage2D");
    }
    out
  }
  static glCompressedTexImage2D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTexImage2D`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glCompressedTexImage2D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCompressedTexImage2D\0",
      &glCompressedTexImage2D_p,
    )
  }
  /// Checks if the pointer for [`glCompressedTexImage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTexImage2D_is_loaded() -> bool {
    !glCompressedTexImage2D_p.load(RELAX).is_null()
  }

  /// [glCompressedTexImage3D](http://docs.gl/gl3/glCompressedTexImage3D)(target, level, internalformat, width, height, depth, border, imageSize, data)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `border` group: CheckedInt32
  /// * `data` group: CompressedTextureARB
  /// * `data` len: imageSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTexImage3D(
    target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei,
    height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTexImage3D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, height, depth, border, imageSize, data);
    }
    let out = call_atomic_ptr_9arg(
      "glCompressedTexImage3D",
      &glCompressedTexImage3D_p,
      target,
      level,
      internalformat,
      width,
      height,
      depth,
      border,
      imageSize,
      data,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCompressedTexImage3D");
    }
    out
  }
  static glCompressedTexImage3D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTexImage3D`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glCompressedTexImage3D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCompressedTexImage3D\0",
      &glCompressedTexImage3D_p,
    )
  }
  /// Checks if the pointer for [`glCompressedTexImage3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTexImage3D_is_loaded() -> bool {
    !glCompressedTexImage3D_p.load(RELAX).is_null()
  }

  /// [glCompressedTexSubImage1D](http://docs.gl/gl3/glCompressedTexSubImage1D)(target, level, xoffset, width, format, imageSize, data)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `data` group: CompressedTextureARB
  /// * `data` len: imageSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTexSubImage1D(
    target: GLenum, level: GLint, xoffset: GLint, width: GLsizei,
    format: GLenum, imageSize: GLsizei, data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, width, format, imageSize, data);
    }
    let out = call_atomic_ptr_7arg(
      "glCompressedTexSubImage1D",
      &glCompressedTexSubImage1D_p,
      target,
      level,
      xoffset,
      width,
      format,
      imageSize,
      data,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCompressedTexSubImage1D");
    }
    out
  }
  static glCompressedTexSubImage1D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTexSubImage1D`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glCompressedTexSubImage1D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCompressedTexSubImage1D\0",
      &glCompressedTexSubImage1D_p,
    )
  }
  /// Checks if the pointer for [`glCompressedTexSubImage1D`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTexSubImage1D_is_loaded() -> bool {
    !glCompressedTexSubImage1D_p.load(RELAX).is_null()
  }

  /// [glCompressedTexSubImage2D](http://docs.gl/gl3/glCompressedTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, imageSize, data)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `yoffset` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `data` group: CompressedTextureARB
  /// * `data` len: imageSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTexSubImage2D(
    target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,
    width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, yoffset, width, height, format, imageSize, data);
    }
    let out = call_atomic_ptr_9arg(
      "glCompressedTexSubImage2D",
      &glCompressedTexSubImage2D_p,
      target,
      level,
      xoffset,
      yoffset,
      width,
      height,
      format,
      imageSize,
      data,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCompressedTexSubImage2D");
    }
    out
  }
  static glCompressedTexSubImage2D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTexSubImage2D`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glCompressedTexSubImage2D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCompressedTexSubImage2D\0",
      &glCompressedTexSubImage2D_p,
    )
  }
  /// Checks if the pointer for [`glCompressedTexSubImage2D`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTexSubImage2D_is_loaded() -> bool {
    !glCompressedTexSubImage2D_p.load(RELAX).is_null()
  }

  /// [glCompressedTexSubImage3D](http://docs.gl/gl3/glCompressedTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `yoffset` group: CheckedInt32
  /// * `zoffset` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `data` group: CompressedTextureARB
  /// * `data` len: imageSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTexSubImage3D(
    target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,
    zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei,
    format: GLenum, imageSize: GLsizei, data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    }
    let out = call_atomic_ptr_11arg(
      "glCompressedTexSubImage3D",
      &glCompressedTexSubImage3D_p,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      width,
      height,
      depth,
      format,
      imageSize,
      data,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCompressedTexSubImage3D");
    }
    out
  }
  static glCompressedTexSubImage3D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTexSubImage3D`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glCompressedTexSubImage3D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCompressedTexSubImage3D\0",
      &glCompressedTexSubImage3D_p,
    )
  }
  /// Checks if the pointer for [`glCompressedTexSubImage3D`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTexSubImage3D_is_loaded() -> bool {
    !glCompressedTexSubImage3D_p.load(RELAX).is_null()
  }

  /// [glCopyBufferSubData](http://docs.gl/gl3/glCopyBufferSubData)(readTarget, writeTarget, readOffset, writeOffset, size)
  /// * `readTarget` group: CopyBufferSubDataTarget
  /// * `writeTarget` group: CopyBufferSubDataTarget
  /// * `readOffset` group: BufferOffset
  /// * `writeOffset` group: BufferOffset
  /// * `size` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyBufferSubData(
    readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr,
    writeOffset: GLintptr, size: GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glCopyBufferSubData({:#X}, {:#X}, {:?}, {:?}, {:?});",
        readTarget,
        writeTarget,
        readOffset,
        writeOffset,
        size
      );
    }
    let out = call_atomic_ptr_5arg(
      "glCopyBufferSubData",
      &glCopyBufferSubData_p,
      readTarget,
      writeTarget,
      readOffset,
      writeOffset,
      size,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCopyBufferSubData");
    }
    out
  }
  static glCopyBufferSubData_p: APcv = ap_null();
  /// Tries to load [`glCopyBufferSubData`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glCopyBufferSubData_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCopyBufferSubData\0",
      &glCopyBufferSubData_p,
    )
  }
  /// Checks if the pointer for [`glCopyBufferSubData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyBufferSubData_is_loaded() -> bool {
    !glCopyBufferSubData_p.load(RELAX).is_null()
  }

  /// [glCopyTexImage1D](http://docs.gl/gl3/glCopyTexImage1D)(target, level, internalformat, x, y, width, border)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  /// * `border` group: CheckedInt32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTexImage1D(
    target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint,
    width: GLsizei, border: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glCopyTexImage1D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});",
        target,
        level,
        internalformat,
        x,
        y,
        width,
        border
      );
    }
    let out = call_atomic_ptr_7arg(
      "glCopyTexImage1D",
      &glCopyTexImage1D_p,
      target,
      level,
      internalformat,
      x,
      y,
      width,
      border,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCopyTexImage1D");
    }
    out
  }
  static glCopyTexImage1D_p: APcv = ap_null();
  /// Tries to load [`glCopyTexImage1D`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glCopyTexImage1D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCopyTexImage1D\0",
      &glCopyTexImage1D_p,
    )
  }
  /// Checks if the pointer for [`glCopyTexImage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTexImage1D_is_loaded() -> bool {
    !glCopyTexImage1D_p.load(RELAX).is_null()
  }

  /// [glCopyTexImage2D](http://docs.gl/gl3/glCopyTexImage2D)(target, level, internalformat, x, y, width, height, border)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  /// * `border` group: CheckedInt32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTexImage2D(
    target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint,
    width: GLsizei, height: GLsizei, border: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCopyTexImage2D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, internalformat, x, y, width, height, border);
    }
    let out = call_atomic_ptr_8arg(
      "glCopyTexImage2D",
      &glCopyTexImage2D_p,
      target,
      level,
      internalformat,
      x,
      y,
      width,
      height,
      border,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCopyTexImage2D");
    }
    out
  }
  static glCopyTexImage2D_p: APcv = ap_null();
  /// Tries to load [`glCopyTexImage2D`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glCopyTexImage2D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCopyTexImage2D\0",
      &glCopyTexImage2D_p,
    )
  }
  /// Checks if the pointer for [`glCopyTexImage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTexImage2D_is_loaded() -> bool {
    !glCopyTexImage2D_p.load(RELAX).is_null()
  }

  /// [glCopyTexSubImage1D](http://docs.gl/gl3/glCopyTexSubImage1D)(target, level, xoffset, x, y, width)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTexSubImage1D(
    target: GLenum, level: GLint, xoffset: GLint, x: GLint, y: GLint,
    width: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glCopyTexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
        target,
        level,
        xoffset,
        x,
        y,
        width
      );
    }
    let out = call_atomic_ptr_6arg(
      "glCopyTexSubImage1D",
      &glCopyTexSubImage1D_p,
      target,
      level,
      xoffset,
      x,
      y,
      width,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCopyTexSubImage1D");
    }
    out
  }
  static glCopyTexSubImage1D_p: APcv = ap_null();
  /// Tries to load [`glCopyTexSubImage1D`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glCopyTexSubImage1D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCopyTexSubImage1D\0",
      &glCopyTexSubImage1D_p,
    )
  }
  /// Checks if the pointer for [`glCopyTexSubImage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTexSubImage1D_is_loaded() -> bool {
    !glCopyTexSubImage1D_p.load(RELAX).is_null()
  }

  /// [glCopyTexSubImage2D](http://docs.gl/gl3/glCopyTexSubImage2D)(target, level, xoffset, yoffset, x, y, width, height)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `yoffset` group: CheckedInt32
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTexSubImage2D(
    target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint,
    y: GLint, width: GLsizei, height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCopyTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, xoffset, yoffset, x, y, width, height);
    }
    let out = call_atomic_ptr_8arg(
      "glCopyTexSubImage2D",
      &glCopyTexSubImage2D_p,
      target,
      level,
      xoffset,
      yoffset,
      x,
      y,
      width,
      height,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCopyTexSubImage2D");
    }
    out
  }
  static glCopyTexSubImage2D_p: APcv = ap_null();
  /// Tries to load [`glCopyTexSubImage2D`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glCopyTexSubImage2D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCopyTexSubImage2D\0",
      &glCopyTexSubImage2D_p,
    )
  }
  /// Checks if the pointer for [`glCopyTexSubImage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTexSubImage2D_is_loaded() -> bool {
    !glCopyTexSubImage2D_p.load(RELAX).is_null()
  }

  /// [glCopyTexSubImage3D](http://docs.gl/gl3/glCopyTexSubImage3D)(target, level, xoffset, yoffset, zoffset, x, y, width, height)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `yoffset` group: CheckedInt32
  /// * `zoffset` group: CheckedInt32
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTexSubImage3D(
    target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,
    zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCopyTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, xoffset, yoffset, zoffset, x, y, width, height);
    }
    let out = call_atomic_ptr_9arg(
      "glCopyTexSubImage3D",
      &glCopyTexSubImage3D_p,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      x,
      y,
      width,
      height,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCopyTexSubImage3D");
    }
    out
  }
  static glCopyTexSubImage3D_p: APcv = ap_null();
  /// Tries to load [`glCopyTexSubImage3D`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glCopyTexSubImage3D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCopyTexSubImage3D\0",
      &glCopyTexSubImage3D_p,
    )
  }
  /// Checks if the pointer for [`glCopyTexSubImage3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTexSubImage3D_is_loaded() -> bool {
    !glCopyTexSubImage3D_p.load(RELAX).is_null()
  }

  /// [glCreateProgram](http://docs.gl/gl3/glCreateProgram)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateProgram() -> GLuint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCreateProgram();",);
    }
    let out = call_atomic_ptr_0arg("glCreateProgram", &glCreateProgram_p);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCreateProgram");
    }
    out
  }
  static glCreateProgram_p: APcv = ap_null();
  /// Tries to load [`glCreateProgram`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glCreateProgram_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCreateProgram\0",
      &glCreateProgram_p,
    )
  }
  /// Checks if the pointer for [`glCreateProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateProgram_is_loaded() -> bool {
    !glCreateProgram_p.load(RELAX).is_null()
  }

  /// [glCreateShader](http://docs.gl/gl3/glCreateShader)(type_)
  /// * `type_` group: ShaderType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateShader(type_: GLenum) -> GLuint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCreateShader({:#X});", type_);
    }
    let out = call_atomic_ptr_1arg("glCreateShader", &glCreateShader_p, type_);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCreateShader");
    }
    out
  }
  static glCreateShader_p: APcv = ap_null();
  /// Tries to load [`glCreateShader`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glCreateShader_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glCreateShader\0",
      &glCreateShader_p,
    )
  }
  /// Checks if the pointer for [`glCreateShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateShader_is_loaded() -> bool {
    !glCreateShader_p.load(RELAX).is_null()
  }

  /// [glCullFace](http://docs.gl/gl3/glCullFace)(mode)
  /// * `mode` group: CullFaceMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCullFace(mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCullFace({:#X});", mode);
    }
    let out = call_atomic_ptr_1arg("glCullFace", &glCullFace_p, mode);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glCullFace");
    }
    out
  }
  static glCullFace_p: APcv = ap_null();
  /// Tries to load [`glCullFace`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glCullFace_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glCullFace\0", &glCullFace_p)
  }
  /// Checks if the pointer for [`glCullFace`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCullFace_is_loaded() -> bool {
    !glCullFace_p.load(RELAX).is_null()
  }

  /// [glDebugMessageCallback](http://docs.gl/gl3/glDebugMessageCallback)(callback, userParam)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glDebugMessageCallback(
    callback: GLDEBUGPROC, userParam: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDebugMessageCallback({:?}, {:p});",
        transmute::<_, Option<fn()>>(callback),
        userParam
      );
    }
    let out = call_atomic_ptr_2arg(
      "glDebugMessageCallback",
      &glDebugMessageCallback_p,
      callback,
      userParam,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDebugMessageCallback");
    }
    out
  }
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  static glDebugMessageCallback_p: APcv = ap_null();
  /// Tries to load [`glDebugMessageCallback`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glDebugMessageCallback_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDebugMessageCallback\0",
      &glDebugMessageCallback_p,
    )
  }
  /// Checks if the pointer for [`glDebugMessageCallback`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub fn glDebugMessageCallback_is_loaded() -> bool {
    !glDebugMessageCallback_p.load(RELAX).is_null()
  }

  /// [glDebugMessageCallbackARB](http://docs.gl/gl3/glDebugMessageCallbackARB)(callback, userParam)
  /// * `userParam` len: COMPSIZE(callback)
  /// * alias of: [`glDebugMessageCallback`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub unsafe fn glDebugMessageCallbackARB(
    callback: GLDEBUGPROCARB, userParam: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDebugMessageCallbackARB({:?}, {:p});",
        transmute::<_, Option<fn()>>(callback),
        userParam
      );
    }
    let out = call_atomic_ptr_2arg(
      "glDebugMessageCallbackARB",
      &glDebugMessageCallbackARB_p,
      callback,
      userParam,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDebugMessageCallbackARB");
    }
    out
  }
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  static glDebugMessageCallbackARB_p: APcv = ap_null();
  /// Tries to load [`glDebugMessageCallbackARB`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub unsafe fn glDebugMessageCallbackARB_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDebugMessageCallbackARB\0",
      &glDebugMessageCallbackARB_p,
    )
  }
  /// Checks if the pointer for [`glDebugMessageCallbackARB`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub fn glDebugMessageCallbackARB_is_loaded() -> bool {
    !glDebugMessageCallbackARB_p.load(RELAX).is_null()
  }

  /// [glDebugMessageControl](http://docs.gl/gl3/glDebugMessageControl)(source, type_, severity, count, ids, enabled)
  /// * `source` group: DebugSource
  /// * `type_` group: DebugType
  /// * `severity` group: DebugSeverity
  /// * `ids` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glDebugMessageControl(
    source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei,
    ids: *const GLuint, enabled: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDebugMessageControl({:#X}, {:#X}, {:#X}, {:?}, {:p}, {:?});",
        source,
        type_,
        severity,
        count,
        ids,
        enabled
      );
    }
    let out = call_atomic_ptr_6arg(
      "glDebugMessageControl",
      &glDebugMessageControl_p,
      source,
      type_,
      severity,
      count,
      ids,
      enabled,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDebugMessageControl");
    }
    out
  }
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  static glDebugMessageControl_p: APcv = ap_null();
  /// Tries to load [`glDebugMessageControl`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glDebugMessageControl_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDebugMessageControl\0",
      &glDebugMessageControl_p,
    )
  }
  /// Checks if the pointer for [`glDebugMessageControl`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub fn glDebugMessageControl_is_loaded() -> bool {
    !glDebugMessageControl_p.load(RELAX).is_null()
  }

  /// [glDebugMessageControlARB](http://docs.gl/gl3/glDebugMessageControlARB)(source, type_, severity, count, ids, enabled)
  /// * `source` group: DebugSource
  /// * `type_` group: DebugType
  /// * `severity` group: DebugSeverity
  /// * `ids` len: count
  /// * alias of: [`glDebugMessageControl`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub unsafe fn glDebugMessageControlARB(
    source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei,
    ids: *const GLuint, enabled: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDebugMessageControlARB({:#X}, {:#X}, {:#X}, {:?}, {:p}, {:?});", source, type_, severity, count, ids, enabled);
    }
    let out = call_atomic_ptr_6arg(
      "glDebugMessageControlARB",
      &glDebugMessageControlARB_p,
      source,
      type_,
      severity,
      count,
      ids,
      enabled,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDebugMessageControlARB");
    }
    out
  }
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  static glDebugMessageControlARB_p: APcv = ap_null();
  /// Tries to load [`glDebugMessageControlARB`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub unsafe fn glDebugMessageControlARB_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDebugMessageControlARB\0",
      &glDebugMessageControlARB_p,
    )
  }
  /// Checks if the pointer for [`glDebugMessageControlARB`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub fn glDebugMessageControlARB_is_loaded() -> bool {
    !glDebugMessageControlARB_p.load(RELAX).is_null()
  }

  /// [glDebugMessageInsert](http://docs.gl/gl3/glDebugMessageInsert)(source, type_, id, severity, length, buf)
  /// * `source` group: DebugSource
  /// * `type_` group: DebugType
  /// * `severity` group: DebugSeverity
  /// * `buf` len: COMPSIZE(buf,length)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glDebugMessageInsert(
    source: GLenum, type_: GLenum, id: GLuint, severity: GLenum,
    length: GLsizei, buf: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDebugMessageInsert({:#X}, {:#X}, {:?}, {:#X}, {:?}, {:p});",
        source,
        type_,
        id,
        severity,
        length,
        buf
      );
    }
    let out = call_atomic_ptr_6arg(
      "glDebugMessageInsert",
      &glDebugMessageInsert_p,
      source,
      type_,
      id,
      severity,
      length,
      buf,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDebugMessageInsert");
    }
    out
  }
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  static glDebugMessageInsert_p: APcv = ap_null();
  /// Tries to load [`glDebugMessageInsert`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glDebugMessageInsert_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDebugMessageInsert\0",
      &glDebugMessageInsert_p,
    )
  }
  /// Checks if the pointer for [`glDebugMessageInsert`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub fn glDebugMessageInsert_is_loaded() -> bool {
    !glDebugMessageInsert_p.load(RELAX).is_null()
  }

  /// [glDebugMessageInsertARB](http://docs.gl/gl3/glDebugMessageInsertARB)(source, type_, id, severity, length, buf)
  /// * `source` group: DebugSource
  /// * `type_` group: DebugType
  /// * `severity` group: DebugSeverity
  /// * `buf` len: length
  /// * alias of: [`glDebugMessageInsert`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub unsafe fn glDebugMessageInsertARB(
    source: GLenum, type_: GLenum, id: GLuint, severity: GLenum,
    length: GLsizei, buf: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDebugMessageInsertARB({:#X}, {:#X}, {:?}, {:#X}, {:?}, {:p});", source, type_, id, severity, length, buf);
    }
    let out = call_atomic_ptr_6arg(
      "glDebugMessageInsertARB",
      &glDebugMessageInsertARB_p,
      source,
      type_,
      id,
      severity,
      length,
      buf,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDebugMessageInsertARB");
    }
    out
  }
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  static glDebugMessageInsertARB_p: APcv = ap_null();
  /// Tries to load [`glDebugMessageInsertARB`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub unsafe fn glDebugMessageInsertARB_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDebugMessageInsertARB\0",
      &glDebugMessageInsertARB_p,
    )
  }
  /// Checks if the pointer for [`glDebugMessageInsertARB`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub fn glDebugMessageInsertARB_is_loaded() -> bool {
    !glDebugMessageInsertARB_p.load(RELAX).is_null()
  }

  /// [glDeleteBuffers](http://docs.gl/gl3/glDeleteBuffers)(n, buffers)
  /// * `buffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteBuffers(n: GLsizei, buffers: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteBuffers({:?}, {:p});", n, buffers);
    }
    let out =
      call_atomic_ptr_2arg("glDeleteBuffers", &glDeleteBuffers_p, n, buffers);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDeleteBuffers");
    }
    out
  }
  static glDeleteBuffers_p: APcv = ap_null();
  /// Tries to load [`glDeleteBuffers`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDeleteBuffers_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDeleteBuffers\0",
      &glDeleteBuffers_p,
    )
  }
  /// Checks if the pointer for [`glDeleteBuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteBuffers_is_loaded() -> bool {
    !glDeleteBuffers_p.load(RELAX).is_null()
  }

  /// [glDeleteFramebuffers](http://docs.gl/gl3/glDeleteFramebuffers)(n, framebuffers)
  /// * `framebuffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteFramebuffers(n: GLsizei, framebuffers: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteFramebuffers({:?}, {:p});", n, framebuffers);
    }
    let out = call_atomic_ptr_2arg(
      "glDeleteFramebuffers",
      &glDeleteFramebuffers_p,
      n,
      framebuffers,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDeleteFramebuffers");
    }
    out
  }
  static glDeleteFramebuffers_p: APcv = ap_null();
  /// Tries to load [`glDeleteFramebuffers`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDeleteFramebuffers_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDeleteFramebuffers\0",
      &glDeleteFramebuffers_p,
    )
  }
  /// Checks if the pointer for [`glDeleteFramebuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteFramebuffers_is_loaded() -> bool {
    !glDeleteFramebuffers_p.load(RELAX).is_null()
  }

  /// [glDeleteProgram](http://docs.gl/gl3/glDeleteProgram)(program)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteProgram(program: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteProgram({:?});", program);
    }
    let out =
      call_atomic_ptr_1arg("glDeleteProgram", &glDeleteProgram_p, program);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDeleteProgram");
    }
    out
  }
  static glDeleteProgram_p: APcv = ap_null();
  /// Tries to load [`glDeleteProgram`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDeleteProgram_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDeleteProgram\0",
      &glDeleteProgram_p,
    )
  }
  /// Checks if the pointer for [`glDeleteProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteProgram_is_loaded() -> bool {
    !glDeleteProgram_p.load(RELAX).is_null()
  }

  /// [glDeleteQueries](http://docs.gl/gl3/glDeleteQueries)(n, ids)
  /// * `ids` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteQueries(n: GLsizei, ids: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteQueries({:?}, {:p});", n, ids);
    }
    let out =
      call_atomic_ptr_2arg("glDeleteQueries", &glDeleteQueries_p, n, ids);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDeleteQueries");
    }
    out
  }
  static glDeleteQueries_p: APcv = ap_null();
  /// Tries to load [`glDeleteQueries`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDeleteQueries_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDeleteQueries\0",
      &glDeleteQueries_p,
    )
  }
  /// Checks if the pointer for [`glDeleteQueries`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteQueries_is_loaded() -> bool {
    !glDeleteQueries_p.load(RELAX).is_null()
  }

  /// [glDeleteRenderbuffers](http://docs.gl/gl3/glDeleteRenderbuffers)(n, renderbuffers)
  /// * `renderbuffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteRenderbuffers(
    n: GLsizei, renderbuffers: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteRenderbuffers({:?}, {:p});", n, renderbuffers);
    }
    let out = call_atomic_ptr_2arg(
      "glDeleteRenderbuffers",
      &glDeleteRenderbuffers_p,
      n,
      renderbuffers,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDeleteRenderbuffers");
    }
    out
  }
  static glDeleteRenderbuffers_p: APcv = ap_null();
  /// Tries to load [`glDeleteRenderbuffers`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDeleteRenderbuffers_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDeleteRenderbuffers\0",
      &glDeleteRenderbuffers_p,
    )
  }
  /// Checks if the pointer for [`glDeleteRenderbuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteRenderbuffers_is_loaded() -> bool {
    !glDeleteRenderbuffers_p.load(RELAX).is_null()
  }

  /// [glDeleteSamplers](http://docs.gl/gl3/glDeleteSamplers)(count, samplers)
  /// * `samplers` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteSamplers(count: GLsizei, samplers: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteSamplers({:?}, {:p});", count, samplers);
    }
    let out = call_atomic_ptr_2arg(
      "glDeleteSamplers",
      &glDeleteSamplers_p,
      count,
      samplers,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDeleteSamplers");
    }
    out
  }
  static glDeleteSamplers_p: APcv = ap_null();
  /// Tries to load [`glDeleteSamplers`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDeleteSamplers_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDeleteSamplers\0",
      &glDeleteSamplers_p,
    )
  }
  /// Checks if the pointer for [`glDeleteSamplers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteSamplers_is_loaded() -> bool {
    !glDeleteSamplers_p.load(RELAX).is_null()
  }

  /// [glDeleteShader](http://docs.gl/gl3/glDeleteShader)(shader)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteShader(shader: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteShader({:?});", shader);
    }
    let out = call_atomic_ptr_1arg("glDeleteShader", &glDeleteShader_p, shader);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDeleteShader");
    }
    out
  }
  static glDeleteShader_p: APcv = ap_null();
  /// Tries to load [`glDeleteShader`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDeleteShader_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDeleteShader\0",
      &glDeleteShader_p,
    )
  }
  /// Checks if the pointer for [`glDeleteShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteShader_is_loaded() -> bool {
    !glDeleteShader_p.load(RELAX).is_null()
  }

  /// [glDeleteSync](http://docs.gl/gl3/glDeleteSync)(sync)
  /// * `sync` group: sync
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteSync(sync: GLsync) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteSync({:p});", sync);
    }
    let out = call_atomic_ptr_1arg("glDeleteSync", &glDeleteSync_p, sync);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDeleteSync");
    }
    out
  }
  static glDeleteSync_p: APcv = ap_null();
  /// Tries to load [`glDeleteSync`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDeleteSync_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDeleteSync\0",
      &glDeleteSync_p,
    )
  }
  /// Checks if the pointer for [`glDeleteSync`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteSync_is_loaded() -> bool {
    !glDeleteSync_p.load(RELAX).is_null()
  }

  /// [glDeleteTextures](http://docs.gl/gl3/glDeleteTextures)(n, textures)
  /// * `textures` group: Texture
  /// * `textures` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteTextures(n: GLsizei, textures: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteTextures({:?}, {:p});", n, textures);
    }
    let out = call_atomic_ptr_2arg(
      "glDeleteTextures",
      &glDeleteTextures_p,
      n,
      textures,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDeleteTextures");
    }
    out
  }
  static glDeleteTextures_p: APcv = ap_null();
  /// Tries to load [`glDeleteTextures`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDeleteTextures_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDeleteTextures\0",
      &glDeleteTextures_p,
    )
  }
  /// Checks if the pointer for [`glDeleteTextures`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteTextures_is_loaded() -> bool {
    !glDeleteTextures_p.load(RELAX).is_null()
  }

  /// [glDeleteVertexArrays](http://docs.gl/gl3/glDeleteVertexArrays)(n, arrays)
  /// * `arrays` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteVertexArrays(n: GLsizei, arrays: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteVertexArrays({:?}, {:p});", n, arrays);
    }
    let out = call_atomic_ptr_2arg(
      "glDeleteVertexArrays",
      &glDeleteVertexArrays_p,
      n,
      arrays,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDeleteVertexArrays");
    }
    out
  }
  static glDeleteVertexArrays_p: APcv = ap_null();
  /// Tries to load [`glDeleteVertexArrays`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDeleteVertexArrays_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDeleteVertexArrays\0",
      &glDeleteVertexArrays_p,
    )
  }
  /// Checks if the pointer for [`glDeleteVertexArrays`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteVertexArrays_is_loaded() -> bool {
    !glDeleteVertexArrays_p.load(RELAX).is_null()
  }

  /// [glDepthFunc](http://docs.gl/gl3/glDepthFunc)(func)
  /// * `func` group: DepthFunction
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDepthFunc(func: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDepthFunc({:#X});", func);
    }
    let out = call_atomic_ptr_1arg("glDepthFunc", &glDepthFunc_p, func);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDepthFunc");
    }
    out
  }
  static glDepthFunc_p: APcv = ap_null();
  /// Tries to load [`glDepthFunc`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glDepthFunc_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glDepthFunc\0", &glDepthFunc_p)
  }
  /// Checks if the pointer for [`glDepthFunc`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDepthFunc_is_loaded() -> bool {
    !glDepthFunc_p.load(RELAX).is_null()
  }

  /// [glDepthMask](http://docs.gl/gl3/glDepthMask)(flag)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDepthMask(flag: GLboolean) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDepthMask({:?});", flag);
    }
    let out = call_atomic_ptr_1arg("glDepthMask", &glDepthMask_p, flag);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDepthMask");
    }
    out
  }
  static glDepthMask_p: APcv = ap_null();
  /// Tries to load [`glDepthMask`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glDepthMask_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glDepthMask\0", &glDepthMask_p)
  }
  /// Checks if the pointer for [`glDepthMask`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDepthMask_is_loaded() -> bool {
    !glDepthMask_p.load(RELAX).is_null()
  }

  /// [glDepthRange](http://docs.gl/gl3/glDepthRange)(n, f)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDepthRange(n: GLdouble, f: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDepthRange({:?}, {:?});", n, f);
    }
    let out = call_atomic_ptr_2arg("glDepthRange", &glDepthRange_p, n, f);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDepthRange");
    }
    out
  }
  static glDepthRange_p: APcv = ap_null();
  /// Tries to load [`glDepthRange`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDepthRange_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDepthRange\0",
      &glDepthRange_p,
    )
  }
  /// Checks if the pointer for [`glDepthRange`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDepthRange_is_loaded() -> bool {
    !glDepthRange_p.load(RELAX).is_null()
  }

  /// [glDetachShader](http://docs.gl/gl3/glDetachShader)(program, shader)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDetachShader(program: GLuint, shader: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDetachShader({:?}, {:?});", program, shader);
    }
    let out = call_atomic_ptr_2arg(
      "glDetachShader",
      &glDetachShader_p,
      program,
      shader,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDetachShader");
    }
    out
  }
  static glDetachShader_p: APcv = ap_null();
  /// Tries to load [`glDetachShader`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDetachShader_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDetachShader\0",
      &glDetachShader_p,
    )
  }
  /// Checks if the pointer for [`glDetachShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDetachShader_is_loaded() -> bool {
    !glDetachShader_p.load(RELAX).is_null()
  }

  /// [glDisable](http://docs.gl/gl3/glDisable)(cap)
  /// * `cap` group: EnableCap
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDisable(cap: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDisable({:#X});", cap);
    }
    let out = call_atomic_ptr_1arg("glDisable", &glDisable_p, cap);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDisable");
    }
    out
  }
  static glDisable_p: APcv = ap_null();
  /// Tries to load [`glDisable`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glDisable_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glDisable\0", &glDisable_p)
  }
  /// Checks if the pointer for [`glDisable`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDisable_is_loaded() -> bool {
    !glDisable_p.load(RELAX).is_null()
  }

  /// [glDisableVertexAttribArray](http://docs.gl/gl3/glDisableVertexAttribArray)(index)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDisableVertexAttribArray(index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDisableVertexAttribArray({:?});", index);
    }
    let out = call_atomic_ptr_1arg(
      "glDisableVertexAttribArray",
      &glDisableVertexAttribArray_p,
      index,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDisableVertexAttribArray");
    }
    out
  }
  static glDisableVertexAttribArray_p: APcv = ap_null();
  /// Tries to load [`glDisableVertexAttribArray`], returns if a non-null
  /// pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glDisableVertexAttribArray_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDisableVertexAttribArray\0",
      &glDisableVertexAttribArray_p,
    )
  }
  /// Checks if the pointer for [`glDisableVertexAttribArray`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDisableVertexAttribArray_is_loaded() -> bool {
    !glDisableVertexAttribArray_p.load(RELAX).is_null()
  }

  /// [glDisablei](http://docs.gl/gl3/glDisable)(target, index)
  /// * `target` group: EnableCap
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDisablei(target: GLenum, index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDisablei({:#X}, {:?});", target, index);
    }
    let out = call_atomic_ptr_2arg("glDisablei", &glDisablei_p, target, index);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDisablei");
    }
    out
  }
  static glDisablei_p: APcv = ap_null();
  /// Tries to load [`glDisablei`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glDisablei_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glDisablei\0", &glDisablei_p)
  }
  /// Checks if the pointer for [`glDisablei`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDisablei_is_loaded() -> bool {
    !glDisablei_p.load(RELAX).is_null()
  }

  /// [glDrawArrays](http://docs.gl/gl3/glDrawArrays)(mode, first, count)
  /// * `mode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawArrays(mode: GLenum, first: GLint, count: GLsizei) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawArrays({:#X}, {:?}, {:?});", mode, first, count);
    }
    let out =
      call_atomic_ptr_3arg("glDrawArrays", &glDrawArrays_p, mode, first, count);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDrawArrays");
    }
    out
  }
  static glDrawArrays_p: APcv = ap_null();
  /// Tries to load [`glDrawArrays`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDrawArrays_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDrawArrays\0",
      &glDrawArrays_p,
    )
  }
  /// Checks if the pointer for [`glDrawArrays`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawArrays_is_loaded() -> bool {
    !glDrawArrays_p.load(RELAX).is_null()
  }

  /// [glDrawArraysInstanced](http://docs.gl/gl3/glDrawArraysInstanced)(mode, first, count, instancecount)
  /// * `mode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawArraysInstanced(
    mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawArraysInstanced({:#X}, {:?}, {:?}, {:?});",
        mode,
        first,
        count,
        instancecount
      );
    }
    let out = call_atomic_ptr_4arg(
      "glDrawArraysInstanced",
      &glDrawArraysInstanced_p,
      mode,
      first,
      count,
      instancecount,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDrawArraysInstanced");
    }
    out
  }
  static glDrawArraysInstanced_p: APcv = ap_null();
  /// Tries to load [`glDrawArraysInstanced`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDrawArraysInstanced_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDrawArraysInstanced\0",
      &glDrawArraysInstanced_p,
    )
  }
  /// Checks if the pointer for [`glDrawArraysInstanced`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawArraysInstanced_is_loaded() -> bool {
    !glDrawArraysInstanced_p.load(RELAX).is_null()
  }

  /// [glDrawBuffer](http://docs.gl/gl3/glDrawBuffer)(buf)
  /// * `buf` group: DrawBufferMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawBuffer(buf: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawBuffer({:#X});", buf);
    }
    let out = call_atomic_ptr_1arg("glDrawBuffer", &glDrawBuffer_p, buf);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDrawBuffer");
    }
    out
  }
  static glDrawBuffer_p: APcv = ap_null();
  /// Tries to load [`glDrawBuffer`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDrawBuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDrawBuffer\0",
      &glDrawBuffer_p,
    )
  }
  /// Checks if the pointer for [`glDrawBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawBuffer_is_loaded() -> bool {
    !glDrawBuffer_p.load(RELAX).is_null()
  }

  /// [glDrawBuffers](http://docs.gl/gl3/glDrawBuffers)(n, bufs)
  /// * `bufs` group: DrawBufferMode
  /// * `bufs` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawBuffers(n: GLsizei, bufs: *const GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawBuffers({:?}, {:p});", n, bufs);
    }
    let out = call_atomic_ptr_2arg("glDrawBuffers", &glDrawBuffers_p, n, bufs);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDrawBuffers");
    }
    out
  }
  static glDrawBuffers_p: APcv = ap_null();
  /// Tries to load [`glDrawBuffers`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDrawBuffers_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDrawBuffers\0",
      &glDrawBuffers_p,
    )
  }
  /// Checks if the pointer for [`glDrawBuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawBuffers_is_loaded() -> bool {
    !glDrawBuffers_p.load(RELAX).is_null()
  }

  /// [glDrawElements](http://docs.gl/gl3/glDrawElements)(mode, count, type_, indices)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(count,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawElements(
    mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawElements({:#X}, {:?}, {:#X}, {:p});",
        mode,
        count,
        type_,
        indices
      );
    }
    let out = call_atomic_ptr_4arg(
      "glDrawElements",
      &glDrawElements_p,
      mode,
      count,
      type_,
      indices,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDrawElements");
    }
    out
  }
  static glDrawElements_p: APcv = ap_null();
  /// Tries to load [`glDrawElements`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDrawElements_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDrawElements\0",
      &glDrawElements_p,
    )
  }
  /// Checks if the pointer for [`glDrawElements`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawElements_is_loaded() -> bool {
    !glDrawElements_p.load(RELAX).is_null()
  }

  /// [glDrawElementsBaseVertex](http://docs.gl/gl3/glDrawElementsBaseVertex)(mode, count, type_, indices, basevertex)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(count,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawElementsBaseVertex(
    mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void,
    basevertex: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawElementsBaseVertex({:#X}, {:?}, {:#X}, {:p}, {:?});",
        mode,
        count,
        type_,
        indices,
        basevertex
      );
    }
    let out = call_atomic_ptr_5arg(
      "glDrawElementsBaseVertex",
      &glDrawElementsBaseVertex_p,
      mode,
      count,
      type_,
      indices,
      basevertex,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDrawElementsBaseVertex");
    }
    out
  }
  static glDrawElementsBaseVertex_p: APcv = ap_null();
  /// Tries to load [`glDrawElementsBaseVertex`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glDrawElementsBaseVertex_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDrawElementsBaseVertex\0",
      &glDrawElementsBaseVertex_p,
    )
  }
  /// Checks if the pointer for [`glDrawElementsBaseVertex`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawElementsBaseVertex_is_loaded() -> bool {
    !glDrawElementsBaseVertex_p.load(RELAX).is_null()
  }

  /// [glDrawElementsInstanced](http://docs.gl/gl3/glDrawElementsInstanced)(mode, count, type_, indices, instancecount)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(count,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawElementsInstanced(
    mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void,
    instancecount: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawElementsInstanced({:#X}, {:?}, {:#X}, {:p}, {:?});",
        mode,
        count,
        type_,
        indices,
        instancecount
      );
    }
    let out = call_atomic_ptr_5arg(
      "glDrawElementsInstanced",
      &glDrawElementsInstanced_p,
      mode,
      count,
      type_,
      indices,
      instancecount,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDrawElementsInstanced");
    }
    out
  }
  static glDrawElementsInstanced_p: APcv = ap_null();
  /// Tries to load [`glDrawElementsInstanced`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glDrawElementsInstanced_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDrawElementsInstanced\0",
      &glDrawElementsInstanced_p,
    )
  }
  /// Checks if the pointer for [`glDrawElementsInstanced`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawElementsInstanced_is_loaded() -> bool {
    !glDrawElementsInstanced_p.load(RELAX).is_null()
  }

  /// [glDrawElementsInstancedBaseVertex](http://docs.gl/gl3/glDrawElementsInstancedBaseVertex)(mode, count, type_, indices, instancecount, basevertex)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(count,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawElementsInstancedBaseVertex(
    mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void,
    instancecount: GLsizei, basevertex: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawElementsInstancedBaseVertex({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?});", mode, count, type_, indices, instancecount, basevertex);
    }
    let out = call_atomic_ptr_6arg(
      "glDrawElementsInstancedBaseVertex",
      &glDrawElementsInstancedBaseVertex_p,
      mode,
      count,
      type_,
      indices,
      instancecount,
      basevertex,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDrawElementsInstancedBaseVertex");
    }
    out
  }
  static glDrawElementsInstancedBaseVertex_p: APcv = ap_null();
  /// Tries to load [`glDrawElementsInstancedBaseVertex`], returns if a non-null
  /// pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glDrawElementsInstancedBaseVertex_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDrawElementsInstancedBaseVertex\0",
      &glDrawElementsInstancedBaseVertex_p,
    )
  }
  /// Checks if the pointer for [`glDrawElementsInstancedBaseVertex`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawElementsInstancedBaseVertex_is_loaded() -> bool {
    !glDrawElementsInstancedBaseVertex_p.load(RELAX).is_null()
  }

  /// [glDrawRangeElements](http://docs.gl/gl3/glDrawRangeElements)(mode, start, end, count, type_, indices)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(count,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawRangeElements(
    mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum,
    indices: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawRangeElements({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p});",
        mode,
        start,
        end,
        count,
        type_,
        indices
      );
    }
    let out = call_atomic_ptr_6arg(
      "glDrawRangeElements",
      &glDrawRangeElements_p,
      mode,
      start,
      end,
      count,
      type_,
      indices,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDrawRangeElements");
    }
    out
  }
  static glDrawRangeElements_p: APcv = ap_null();
  /// Tries to load [`glDrawRangeElements`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glDrawRangeElements_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDrawRangeElements\0",
      &glDrawRangeElements_p,
    )
  }
  /// Checks if the pointer for [`glDrawRangeElements`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawRangeElements_is_loaded() -> bool {
    !glDrawRangeElements_p.load(RELAX).is_null()
  }

  /// [glDrawRangeElementsBaseVertex](http://docs.gl/gl3/glDrawRangeElementsBaseVertex)(mode, start, end, count, type_, indices, basevertex)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(count,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawRangeElementsBaseVertex(
    mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum,
    indices: *const c_void, basevertex: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawRangeElementsBaseVertex({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p}, {:?});", mode, start, end, count, type_, indices, basevertex);
    }
    let out = call_atomic_ptr_7arg(
      "glDrawRangeElementsBaseVertex",
      &glDrawRangeElementsBaseVertex_p,
      mode,
      start,
      end,
      count,
      type_,
      indices,
      basevertex,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glDrawRangeElementsBaseVertex");
    }
    out
  }
  static glDrawRangeElementsBaseVertex_p: APcv = ap_null();
  /// Tries to load [`glDrawRangeElementsBaseVertex`], returns if a non-null
  /// pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glDrawRangeElementsBaseVertex_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glDrawRangeElementsBaseVertex\0",
      &glDrawRangeElementsBaseVertex_p,
    )
  }
  /// Checks if the pointer for [`glDrawRangeElementsBaseVertex`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawRangeElementsBaseVertex_is_loaded() -> bool {
    !glDrawRangeElementsBaseVertex_p.load(RELAX).is_null()
  }

  /// [glEnable](http://docs.gl/gl3/glEnable)(cap)
  /// * `cap` group: EnableCap
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEnable(cap: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEnable({:#X});", cap);
    }
    let out = call_atomic_ptr_1arg("glEnable", &glEnable_p, cap);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glEnable");
    }
    out
  }
  static glEnable_p: APcv = ap_null();
  /// Tries to load [`glEnable`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glEnable_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glEnable\0", &glEnable_p)
  }
  /// Checks if the pointer for [`glEnable`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEnable_is_loaded() -> bool {
    !glEnable_p.load(RELAX).is_null()
  }

  /// [glEnableVertexAttribArray](http://docs.gl/gl3/glEnableVertexAttribArray)(index)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEnableVertexAttribArray(index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEnableVertexAttribArray({:?});", index);
    }
    let out = call_atomic_ptr_1arg(
      "glEnableVertexAttribArray",
      &glEnableVertexAttribArray_p,
      index,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glEnableVertexAttribArray");
    }
    out
  }
  static glEnableVertexAttribArray_p: APcv = ap_null();
  /// Tries to load [`glEnableVertexAttribArray`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glEnableVertexAttribArray_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glEnableVertexAttribArray\0",
      &glEnableVertexAttribArray_p,
    )
  }
  /// Checks if the pointer for [`glEnableVertexAttribArray`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEnableVertexAttribArray_is_loaded() -> bool {
    !glEnableVertexAttribArray_p.load(RELAX).is_null()
  }

  /// [glEnablei](http://docs.gl/gl3/glEnable)(target, index)
  /// * `target` group: EnableCap
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEnablei(target: GLenum, index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEnablei({:#X}, {:?});", target, index);
    }
    let out = call_atomic_ptr_2arg("glEnablei", &glEnablei_p, target, index);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glEnablei");
    }
    out
  }
  static glEnablei_p: APcv = ap_null();
  /// Tries to load [`glEnablei`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glEnablei_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glEnablei\0", &glEnablei_p)
  }
  /// Checks if the pointer for [`glEnablei`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEnablei_is_loaded() -> bool {
    !glEnablei_p.load(RELAX).is_null()
  }

  /// [glEndConditionalRender](http://docs.gl/gl3/glEndConditionalRender)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEndConditionalRender() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEndConditionalRender();",);
    }
    let out =
      call_atomic_ptr_0arg("glEndConditionalRender", &glEndConditionalRender_p);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glEndConditionalRender");
    }
    out
  }
  static glEndConditionalRender_p: APcv = ap_null();
  /// Tries to load [`glEndConditionalRender`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glEndConditionalRender_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glEndConditionalRender\0",
      &glEndConditionalRender_p,
    )
  }
  /// Checks if the pointer for [`glEndConditionalRender`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEndConditionalRender_is_loaded() -> bool {
    !glEndConditionalRender_p.load(RELAX).is_null()
  }

  /// [glEndQuery](http://docs.gl/gl3/glEndQuery)(target)
  /// * `target` group: QueryTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEndQuery(target: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEndQuery({:#X});", target);
    }
    let out = call_atomic_ptr_1arg("glEndQuery", &glEndQuery_p, target);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glEndQuery");
    }
    out
  }
  static glEndQuery_p: APcv = ap_null();
  /// Tries to load [`glEndQuery`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glEndQuery_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glEndQuery\0", &glEndQuery_p)
  }
  /// Checks if the pointer for [`glEndQuery`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEndQuery_is_loaded() -> bool {
    !glEndQuery_p.load(RELAX).is_null()
  }

  /// [glEndTransformFeedback](http://docs.gl/gl3/glEndTransformFeedback)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEndTransformFeedback() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEndTransformFeedback();",);
    }
    let out =
      call_atomic_ptr_0arg("glEndTransformFeedback", &glEndTransformFeedback_p);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glEndTransformFeedback");
    }
    out
  }
  static glEndTransformFeedback_p: APcv = ap_null();
  /// Tries to load [`glEndTransformFeedback`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glEndTransformFeedback_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glEndTransformFeedback\0",
      &glEndTransformFeedback_p,
    )
  }
  /// Checks if the pointer for [`glEndTransformFeedback`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEndTransformFeedback_is_loaded() -> bool {
    !glEndTransformFeedback_p.load(RELAX).is_null()
  }

  /// [glFenceSync](http://docs.gl/gl3/glFenceSync)(condition, flags)
  /// * `condition` group: SyncCondition
  /// * return value group: sync
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFenceSync(condition: GLenum, flags: GLbitfield) -> GLsync {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glFenceSync({:#X}, {:?});", condition, flags);
    }
    let out =
      call_atomic_ptr_2arg("glFenceSync", &glFenceSync_p, condition, flags);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glFenceSync");
    }
    out
  }
  static glFenceSync_p: APcv = ap_null();
  /// Tries to load [`glFenceSync`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glFenceSync_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glFenceSync\0", &glFenceSync_p)
  }
  /// Checks if the pointer for [`glFenceSync`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFenceSync_is_loaded() -> bool {
    !glFenceSync_p.load(RELAX).is_null()
  }

  /// [glFinish](http://docs.gl/gl3/glFinish)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFinish() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glFinish();",);
    }
    let out = call_atomic_ptr_0arg("glFinish", &glFinish_p);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glFinish");
    }
    out
  }
  static glFinish_p: APcv = ap_null();
  /// Tries to load [`glFinish`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glFinish_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glFinish\0", &glFinish_p)
  }
  /// Checks if the pointer for [`glFinish`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFinish_is_loaded() -> bool {
    !glFinish_p.load(RELAX).is_null()
  }

  /// [glFlush](http://docs.gl/gl3/glFlush)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFlush() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glFlush();",);
    }
    let out = call_atomic_ptr_0arg("glFlush", &glFlush_p);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glFlush");
    }
    out
  }
  static glFlush_p: APcv = ap_null();
  /// Tries to load [`glFlush`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glFlush_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glFlush\0", &glFlush_p)
  }
  /// Checks if the pointer for [`glFlush`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFlush_is_loaded() -> bool {
    !glFlush_p.load(RELAX).is_null()
  }

  /// [glFlushMappedBufferRange](http://docs.gl/gl3/glFlushMappedBufferRange)(target, offset, length)
  /// * `target` group: BufferTargetARB
  /// * `offset` group: BufferOffset
  /// * `length` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFlushMappedBufferRange(
    target: GLenum, offset: GLintptr, length: GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFlushMappedBufferRange({:#X}, {:?}, {:?});",
        target,
        offset,
        length
      );
    }
    let out = call_atomic_ptr_3arg(
      "glFlushMappedBufferRange",
      &glFlushMappedBufferRange_p,
      target,
      offset,
      length,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glFlushMappedBufferRange");
    }
    out
  }
  static glFlushMappedBufferRange_p: APcv = ap_null();
  /// Tries to load [`glFlushMappedBufferRange`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glFlushMappedBufferRange_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glFlushMappedBufferRange\0",
      &glFlushMappedBufferRange_p,
    )
  }
  /// Checks if the pointer for [`glFlushMappedBufferRange`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFlushMappedBufferRange_is_loaded() -> bool {
    !glFlushMappedBufferRange_p.load(RELAX).is_null()
  }

  /// [glFramebufferRenderbuffer](http://docs.gl/gl3/glFramebufferRenderbuffer)(target, attachment, renderbuffertarget, renderbuffer)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  /// * `renderbuffertarget` group: RenderbufferTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferRenderbuffer(
    target: GLenum, attachment: GLenum, renderbuffertarget: GLenum,
    renderbuffer: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFramebufferRenderbuffer({:#X}, {:#X}, {:#X}, {:?});",
        target,
        attachment,
        renderbuffertarget,
        renderbuffer
      );
    }
    let out = call_atomic_ptr_4arg(
      "glFramebufferRenderbuffer",
      &glFramebufferRenderbuffer_p,
      target,
      attachment,
      renderbuffertarget,
      renderbuffer,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glFramebufferRenderbuffer");
    }
    out
  }
  static glFramebufferRenderbuffer_p: APcv = ap_null();
  /// Tries to load [`glFramebufferRenderbuffer`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glFramebufferRenderbuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glFramebufferRenderbuffer\0",
      &glFramebufferRenderbuffer_p,
    )
  }
  /// Checks if the pointer for [`glFramebufferRenderbuffer`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferRenderbuffer_is_loaded() -> bool {
    !glFramebufferRenderbuffer_p.load(RELAX).is_null()
  }

  /// [glFramebufferTexture](http://docs.gl/gl3/glFramebufferTexture)(target, attachment, texture, level)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferTexture(
    target: GLenum, attachment: GLenum, texture: GLuint, level: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFramebufferTexture({:#X}, {:#X}, {:?}, {:?});",
        target,
        attachment,
        texture,
        level
      );
    }
    let out = call_atomic_ptr_4arg(
      "glFramebufferTexture",
      &glFramebufferTexture_p,
      target,
      attachment,
      texture,
      level,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glFramebufferTexture");
    }
    out
  }
  static glFramebufferTexture_p: APcv = ap_null();
  /// Tries to load [`glFramebufferTexture`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glFramebufferTexture_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glFramebufferTexture\0",
      &glFramebufferTexture_p,
    )
  }
  /// Checks if the pointer for [`glFramebufferTexture`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferTexture_is_loaded() -> bool {
    !glFramebufferTexture_p.load(RELAX).is_null()
  }

  /// [glFramebufferTexture1D](http://docs.gl/gl3/glFramebufferTexture1D)(target, attachment, textarget, texture, level)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  /// * `textarget` group: TextureTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferTexture1D(
    target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint,
    level: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFramebufferTexture1D({:#X}, {:#X}, {:#X}, {:?}, {:?});",
        target,
        attachment,
        textarget,
        texture,
        level
      );
    }
    let out = call_atomic_ptr_5arg(
      "glFramebufferTexture1D",
      &glFramebufferTexture1D_p,
      target,
      attachment,
      textarget,
      texture,
      level,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glFramebufferTexture1D");
    }
    out
  }
  static glFramebufferTexture1D_p: APcv = ap_null();
  /// Tries to load [`glFramebufferTexture1D`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glFramebufferTexture1D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glFramebufferTexture1D\0",
      &glFramebufferTexture1D_p,
    )
  }
  /// Checks if the pointer for [`glFramebufferTexture1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferTexture1D_is_loaded() -> bool {
    !glFramebufferTexture1D_p.load(RELAX).is_null()
  }

  /// [glFramebufferTexture2D](http://docs.gl/gl3/glFramebufferTexture2D)(target, attachment, textarget, texture, level)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  /// * `textarget` group: TextureTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferTexture2D(
    target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint,
    level: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFramebufferTexture2D({:#X}, {:#X}, {:#X}, {:?}, {:?});",
        target,
        attachment,
        textarget,
        texture,
        level
      );
    }
    let out = call_atomic_ptr_5arg(
      "glFramebufferTexture2D",
      &glFramebufferTexture2D_p,
      target,
      attachment,
      textarget,
      texture,
      level,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glFramebufferTexture2D");
    }
    out
  }
  static glFramebufferTexture2D_p: APcv = ap_null();
  /// Tries to load [`glFramebufferTexture2D`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glFramebufferTexture2D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glFramebufferTexture2D\0",
      &glFramebufferTexture2D_p,
    )
  }
  /// Checks if the pointer for [`glFramebufferTexture2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferTexture2D_is_loaded() -> bool {
    !glFramebufferTexture2D_p.load(RELAX).is_null()
  }

  /// [glFramebufferTexture3D](http://docs.gl/gl3/glFramebufferTexture3D)(target, attachment, textarget, texture, level, zoffset)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  /// * `textarget` group: TextureTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferTexture3D(
    target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint,
    level: GLint, zoffset: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glFramebufferTexture3D({:#X}, {:#X}, {:#X}, {:?}, {:?}, {:?});", target, attachment, textarget, texture, level, zoffset);
    }
    let out = call_atomic_ptr_6arg(
      "glFramebufferTexture3D",
      &glFramebufferTexture3D_p,
      target,
      attachment,
      textarget,
      texture,
      level,
      zoffset,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glFramebufferTexture3D");
    }
    out
  }
  static glFramebufferTexture3D_p: APcv = ap_null();
  /// Tries to load [`glFramebufferTexture3D`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glFramebufferTexture3D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glFramebufferTexture3D\0",
      &glFramebufferTexture3D_p,
    )
  }
  /// Checks if the pointer for [`glFramebufferTexture3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferTexture3D_is_loaded() -> bool {
    !glFramebufferTexture3D_p.load(RELAX).is_null()
  }

  /// [glFramebufferTextureLayer](http://docs.gl/gl3/glFramebufferTextureLayer)(target, attachment, texture, level, layer)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  /// * `texture` group: Texture
  /// * `level` group: CheckedInt32
  /// * `layer` group: CheckedInt32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferTextureLayer(
    target: GLenum, attachment: GLenum, texture: GLuint, level: GLint,
    layer: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFramebufferTextureLayer({:#X}, {:#X}, {:?}, {:?}, {:?});",
        target,
        attachment,
        texture,
        level,
        layer
      );
    }
    let out = call_atomic_ptr_5arg(
      "glFramebufferTextureLayer",
      &glFramebufferTextureLayer_p,
      target,
      attachment,
      texture,
      level,
      layer,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glFramebufferTextureLayer");
    }
    out
  }
  static glFramebufferTextureLayer_p: APcv = ap_null();
  /// Tries to load [`glFramebufferTextureLayer`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glFramebufferTextureLayer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glFramebufferTextureLayer\0",
      &glFramebufferTextureLayer_p,
    )
  }
  /// Checks if the pointer for [`glFramebufferTextureLayer`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferTextureLayer_is_loaded() -> bool {
    !glFramebufferTextureLayer_p.load(RELAX).is_null()
  }

  /// [glFrontFace](http://docs.gl/gl3/glFrontFace)(mode)
  /// * `mode` group: FrontFaceDirection
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFrontFace(mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glFrontFace({:#X});", mode);
    }
    let out = call_atomic_ptr_1arg("glFrontFace", &glFrontFace_p, mode);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glFrontFace");
    }
    out
  }
  static glFrontFace_p: APcv = ap_null();
  /// Tries to load [`glFrontFace`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glFrontFace_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glFrontFace\0", &glFrontFace_p)
  }
  /// Checks if the pointer for [`glFrontFace`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFrontFace_is_loaded() -> bool {
    !glFrontFace_p.load(RELAX).is_null()
  }

  /// [glGenBuffers](http://docs.gl/gl3/glGenBuffers)(n, buffers)
  /// * `buffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenBuffers(n: GLsizei, buffers: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenBuffers({:?}, {:p});", n, buffers);
    }
    let out = call_atomic_ptr_2arg("glGenBuffers", &glGenBuffers_p, n, buffers);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGenBuffers");
    }
    out
  }
  static glGenBuffers_p: APcv = ap_null();
  /// Tries to load [`glGenBuffers`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGenBuffers_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGenBuffers\0",
      &glGenBuffers_p,
    )
  }
  /// Checks if the pointer for [`glGenBuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenBuffers_is_loaded() -> bool {
    !glGenBuffers_p.load(RELAX).is_null()
  }

  /// [glGenFramebuffers](http://docs.gl/gl3/glGenFramebuffers)(n, framebuffers)
  /// * `framebuffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenFramebuffers(n: GLsizei, framebuffers: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenFramebuffers({:?}, {:p});", n, framebuffers);
    }
    let out = call_atomic_ptr_2arg(
      "glGenFramebuffers",
      &glGenFramebuffers_p,
      n,
      framebuffers,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGenFramebuffers");
    }
    out
  }
  static glGenFramebuffers_p: APcv = ap_null();
  /// Tries to load [`glGenFramebuffers`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGenFramebuffers_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGenFramebuffers\0",
      &glGenFramebuffers_p,
    )
  }
  /// Checks if the pointer for [`glGenFramebuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenFramebuffers_is_loaded() -> bool {
    !glGenFramebuffers_p.load(RELAX).is_null()
  }

  /// [glGenQueries](http://docs.gl/gl3/glGenQueries)(n, ids)
  /// * `ids` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenQueries(n: GLsizei, ids: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenQueries({:?}, {:p});", n, ids);
    }
    let out = call_atomic_ptr_2arg("glGenQueries", &glGenQueries_p, n, ids);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGenQueries");
    }
    out
  }
  static glGenQueries_p: APcv = ap_null();
  /// Tries to load [`glGenQueries`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGenQueries_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGenQueries\0",
      &glGenQueries_p,
    )
  }
  /// Checks if the pointer for [`glGenQueries`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenQueries_is_loaded() -> bool {
    !glGenQueries_p.load(RELAX).is_null()
  }

  /// [glGenRenderbuffers](http://docs.gl/gl3/glGenRenderbuffers)(n, renderbuffers)
  /// * `renderbuffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenRenderbuffers(n: GLsizei, renderbuffers: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenRenderbuffers({:?}, {:p});", n, renderbuffers);
    }
    let out = call_atomic_ptr_2arg(
      "glGenRenderbuffers",
      &glGenRenderbuffers_p,
      n,
      renderbuffers,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGenRenderbuffers");
    }
    out
  }
  static glGenRenderbuffers_p: APcv = ap_null();
  /// Tries to load [`glGenRenderbuffers`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGenRenderbuffers_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGenRenderbuffers\0",
      &glGenRenderbuffers_p,
    )
  }
  /// Checks if the pointer for [`glGenRenderbuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenRenderbuffers_is_loaded() -> bool {
    !glGenRenderbuffers_p.load(RELAX).is_null()
  }

  /// [glGenSamplers](http://docs.gl/gl3/glGenSamplers)(count, samplers)
  /// * `samplers` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenSamplers(count: GLsizei, samplers: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenSamplers({:?}, {:p});", count, samplers);
    }
    let out =
      call_atomic_ptr_2arg("glGenSamplers", &glGenSamplers_p, count, samplers);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGenSamplers");
    }
    out
  }
  static glGenSamplers_p: APcv = ap_null();
  /// Tries to load [`glGenSamplers`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGenSamplers_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGenSamplers\0",
      &glGenSamplers_p,
    )
  }
  /// Checks if the pointer for [`glGenSamplers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenSamplers_is_loaded() -> bool {
    !glGenSamplers_p.load(RELAX).is_null()
  }

  /// [glGenTextures](http://docs.gl/gl3/glGenTextures)(n, textures)
  /// * `textures` group: Texture
  /// * `textures` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenTextures(n: GLsizei, textures: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenTextures({:?}, {:p});", n, textures);
    }
    let out =
      call_atomic_ptr_2arg("glGenTextures", &glGenTextures_p, n, textures);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGenTextures");
    }
    out
  }
  static glGenTextures_p: APcv = ap_null();
  /// Tries to load [`glGenTextures`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGenTextures_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGenTextures\0",
      &glGenTextures_p,
    )
  }
  /// Checks if the pointer for [`glGenTextures`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenTextures_is_loaded() -> bool {
    !glGenTextures_p.load(RELAX).is_null()
  }

  /// [glGenVertexArrays](http://docs.gl/gl3/glGenVertexArrays)(n, arrays)
  /// * `arrays` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenVertexArrays(n: GLsizei, arrays: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenVertexArrays({:?}, {:p});", n, arrays);
    }
    let out = call_atomic_ptr_2arg(
      "glGenVertexArrays",
      &glGenVertexArrays_p,
      n,
      arrays,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGenVertexArrays");
    }
    out
  }
  static glGenVertexArrays_p: APcv = ap_null();
  /// Tries to load [`glGenVertexArrays`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGenVertexArrays_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGenVertexArrays\0",
      &glGenVertexArrays_p,
    )
  }
  /// Checks if the pointer for [`glGenVertexArrays`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenVertexArrays_is_loaded() -> bool {
    !glGenVertexArrays_p.load(RELAX).is_null()
  }

  /// [glGenerateMipmap](http://docs.gl/gl3/glGenerateMipmap)(target)
  /// * `target` group: TextureTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenerateMipmap(target: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenerateMipmap({:#X});", target);
    }
    let out =
      call_atomic_ptr_1arg("glGenerateMipmap", &glGenerateMipmap_p, target);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGenerateMipmap");
    }
    out
  }
  static glGenerateMipmap_p: APcv = ap_null();
  /// Tries to load [`glGenerateMipmap`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGenerateMipmap_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGenerateMipmap\0",
      &glGenerateMipmap_p,
    )
  }
  /// Checks if the pointer for [`glGenerateMipmap`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenerateMipmap_is_loaded() -> bool {
    !glGenerateMipmap_p.load(RELAX).is_null()
  }

  /// [glGetActiveAttrib](http://docs.gl/gl3/glGetActiveAttrib)(program, index, bufSize, length, size, type_, name)
  /// * `length` len: 1
  /// * `size` len: 1
  /// * `type_` group: AttributeType
  /// * `type_` len: 1
  /// * `name` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveAttrib(
    program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei,
    size: *mut GLint, type_: *mut GLenum, name: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveAttrib({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});",
        program,
        index,
        bufSize,
        length,
        size,
        type_,
        name
      );
    }
    let out = call_atomic_ptr_7arg(
      "glGetActiveAttrib",
      &glGetActiveAttrib_p,
      program,
      index,
      bufSize,
      length,
      size,
      type_,
      name,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetActiveAttrib");
    }
    out
  }
  static glGetActiveAttrib_p: APcv = ap_null();
  /// Tries to load [`glGetActiveAttrib`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetActiveAttrib_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetActiveAttrib\0",
      &glGetActiveAttrib_p,
    )
  }
  /// Checks if the pointer for [`glGetActiveAttrib`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveAttrib_is_loaded() -> bool {
    !glGetActiveAttrib_p.load(RELAX).is_null()
  }

  /// [glGetActiveUniform](http://docs.gl/gl3/glGetActiveUniform)(program, index, bufSize, length, size, type_, name)
  /// * `length` len: 1
  /// * `size` len: 1
  /// * `type_` group: UniformType
  /// * `type_` len: 1
  /// * `name` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveUniform(
    program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei,
    size: *mut GLint, type_: *mut GLenum, name: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveUniform({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});",
        program,
        index,
        bufSize,
        length,
        size,
        type_,
        name
      );
    }
    let out = call_atomic_ptr_7arg(
      "glGetActiveUniform",
      &glGetActiveUniform_p,
      program,
      index,
      bufSize,
      length,
      size,
      type_,
      name,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetActiveUniform");
    }
    out
  }
  static glGetActiveUniform_p: APcv = ap_null();
  /// Tries to load [`glGetActiveUniform`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetActiveUniform_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetActiveUniform\0",
      &glGetActiveUniform_p,
    )
  }
  /// Checks if the pointer for [`glGetActiveUniform`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveUniform_is_loaded() -> bool {
    !glGetActiveUniform_p.load(RELAX).is_null()
  }

  /// [glGetActiveUniformBlockName](http://docs.gl/gl3/glGetActiveUniformBlockName)(program, uniformBlockIndex, bufSize, length, uniformBlockName)
  /// * `length` len: 1
  /// * `uniformBlockName` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveUniformBlockName(
    program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei,
    length: *mut GLsizei, uniformBlockName: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveUniformBlockName({:?}, {:?}, {:?}, {:p}, {:p});",
        program,
        uniformBlockIndex,
        bufSize,
        length,
        uniformBlockName
      );
    }
    let out = call_atomic_ptr_5arg(
      "glGetActiveUniformBlockName",
      &glGetActiveUniformBlockName_p,
      program,
      uniformBlockIndex,
      bufSize,
      length,
      uniformBlockName,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetActiveUniformBlockName");
    }
    out
  }
  static glGetActiveUniformBlockName_p: APcv = ap_null();
  /// Tries to load [`glGetActiveUniformBlockName`], returns if a non-null
  /// pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetActiveUniformBlockName_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetActiveUniformBlockName\0",
      &glGetActiveUniformBlockName_p,
    )
  }
  /// Checks if the pointer for [`glGetActiveUniformBlockName`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveUniformBlockName_is_loaded() -> bool {
    !glGetActiveUniformBlockName_p.load(RELAX).is_null()
  }

  /// [glGetActiveUniformBlockiv](http://docs.gl/gl3/glGetActiveUniformBlockiv)(program, uniformBlockIndex, pname, params)
  /// * `pname` group: UniformBlockPName
  /// * `params` len: COMPSIZE(program,uniformBlockIndex,pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveUniformBlockiv(
    program: GLuint, uniformBlockIndex: GLuint, pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveUniformBlockiv({:?}, {:?}, {:#X}, {:p});",
        program,
        uniformBlockIndex,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_4arg(
      "glGetActiveUniformBlockiv",
      &glGetActiveUniformBlockiv_p,
      program,
      uniformBlockIndex,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetActiveUniformBlockiv");
    }
    out
  }
  static glGetActiveUniformBlockiv_p: APcv = ap_null();
  /// Tries to load [`glGetActiveUniformBlockiv`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetActiveUniformBlockiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetActiveUniformBlockiv\0",
      &glGetActiveUniformBlockiv_p,
    )
  }
  /// Checks if the pointer for [`glGetActiveUniformBlockiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveUniformBlockiv_is_loaded() -> bool {
    !glGetActiveUniformBlockiv_p.load(RELAX).is_null()
  }

  /// [glGetActiveUniformName](http://docs.gl/gl3/glGetActiveUniformName)(program, uniformIndex, bufSize, length, uniformName)
  /// * `length` len: 1
  /// * `uniformName` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveUniformName(
    program: GLuint, uniformIndex: GLuint, bufSize: GLsizei,
    length: *mut GLsizei, uniformName: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveUniformName({:?}, {:?}, {:?}, {:p}, {:p});",
        program,
        uniformIndex,
        bufSize,
        length,
        uniformName
      );
    }
    let out = call_atomic_ptr_5arg(
      "glGetActiveUniformName",
      &glGetActiveUniformName_p,
      program,
      uniformIndex,
      bufSize,
      length,
      uniformName,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetActiveUniformName");
    }
    out
  }
  static glGetActiveUniformName_p: APcv = ap_null();
  /// Tries to load [`glGetActiveUniformName`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetActiveUniformName_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetActiveUniformName\0",
      &glGetActiveUniformName_p,
    )
  }
  /// Checks if the pointer for [`glGetActiveUniformName`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveUniformName_is_loaded() -> bool {
    !glGetActiveUniformName_p.load(RELAX).is_null()
  }

  /// [glGetActiveUniformsiv](http://docs.gl/gl3/glGetActiveUniformsiv)(program, uniformCount, uniformIndices, pname, params)
  /// * `uniformIndices` len: uniformCount
  /// * `pname` group: UniformPName
  /// * `params` len: COMPSIZE(uniformCount,pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveUniformsiv(
    program: GLuint, uniformCount: GLsizei, uniformIndices: *const GLuint,
    pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveUniformsiv({:?}, {:?}, {:p}, {:#X}, {:p});",
        program,
        uniformCount,
        uniformIndices,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_5arg(
      "glGetActiveUniformsiv",
      &glGetActiveUniformsiv_p,
      program,
      uniformCount,
      uniformIndices,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetActiveUniformsiv");
    }
    out
  }
  static glGetActiveUniformsiv_p: APcv = ap_null();
  /// Tries to load [`glGetActiveUniformsiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetActiveUniformsiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetActiveUniformsiv\0",
      &glGetActiveUniformsiv_p,
    )
  }
  /// Checks if the pointer for [`glGetActiveUniformsiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveUniformsiv_is_loaded() -> bool {
    !glGetActiveUniformsiv_p.load(RELAX).is_null()
  }

  /// [glGetAttachedShaders](http://docs.gl/gl3/glGetAttachedShaders)(program, maxCount, count, shaders)
  /// * `count` len: 1
  /// * `shaders` len: maxCount
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetAttachedShaders(
    program: GLuint, maxCount: GLsizei, count: *mut GLsizei,
    shaders: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetAttachedShaders({:?}, {:?}, {:p}, {:p});",
        program,
        maxCount,
        count,
        shaders
      );
    }
    let out = call_atomic_ptr_4arg(
      "glGetAttachedShaders",
      &glGetAttachedShaders_p,
      program,
      maxCount,
      count,
      shaders,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetAttachedShaders");
    }
    out
  }
  static glGetAttachedShaders_p: APcv = ap_null();
  /// Tries to load [`glGetAttachedShaders`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetAttachedShaders_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetAttachedShaders\0",
      &glGetAttachedShaders_p,
    )
  }
  /// Checks if the pointer for [`glGetAttachedShaders`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetAttachedShaders_is_loaded() -> bool {
    !glGetAttachedShaders_p.load(RELAX).is_null()
  }

  /// [glGetAttribLocation](http://docs.gl/gl3/glGetAttribLocation)(program, name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetAttribLocation(
    program: GLuint, name: *const GLchar,
  ) -> GLint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetAttribLocation({:?}, {:p});", program, name);
    }
    let out = call_atomic_ptr_2arg(
      "glGetAttribLocation",
      &glGetAttribLocation_p,
      program,
      name,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetAttribLocation");
    }
    out
  }
  static glGetAttribLocation_p: APcv = ap_null();
  /// Tries to load [`glGetAttribLocation`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetAttribLocation_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetAttribLocation\0",
      &glGetAttribLocation_p,
    )
  }
  /// Checks if the pointer for [`glGetAttribLocation`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetAttribLocation_is_loaded() -> bool {
    !glGetAttribLocation_p.load(RELAX).is_null()
  }

  /// [glGetBooleani_v](http://docs.gl/gl3/glGet)(target, index, data)
  /// * `target` group: BufferTargetARB
  /// * `data` len: COMPSIZE(target)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetBooleani_v(
    target: GLenum, index: GLuint, data: *mut GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetBooleani_v({:#X}, {:?}, {:p});",
        target,
        index,
        data
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetBooleani_v",
      &glGetBooleani_v_p,
      target,
      index,
      data,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetBooleani_v");
    }
    out
  }
  static glGetBooleani_v_p: APcv = ap_null();
  /// Tries to load [`glGetBooleani_v`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetBooleani_v_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetBooleani_v\0",
      &glGetBooleani_v_p,
    )
  }
  /// Checks if the pointer for [`glGetBooleani_v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetBooleani_v_is_loaded() -> bool {
    !glGetBooleani_v_p.load(RELAX).is_null()
  }

  /// [glGetBooleanv](http://docs.gl/gl3/glGet)(pname, data)
  /// * `pname` group: GetPName
  /// * `data` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetBooleanv(pname: GLenum, data: *mut GLboolean) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetBooleanv({:#X}, {:p});", pname, data);
    }
    let out =
      call_atomic_ptr_2arg("glGetBooleanv", &glGetBooleanv_p, pname, data);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetBooleanv");
    }
    out
  }
  static glGetBooleanv_p: APcv = ap_null();
  /// Tries to load [`glGetBooleanv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetBooleanv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetBooleanv\0",
      &glGetBooleanv_p,
    )
  }
  /// Checks if the pointer for [`glGetBooleanv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetBooleanv_is_loaded() -> bool {
    !glGetBooleanv_p.load(RELAX).is_null()
  }

  /// [glGetBufferParameteri64v](http://docs.gl/gl3/glGetBufferParameter)(target, pname, params)
  /// * `target` group: BufferTargetARB
  /// * `pname` group: BufferPNameARB
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetBufferParameteri64v(
    target: GLenum, pname: GLenum, params: *mut GLint64,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetBufferParameteri64v({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetBufferParameteri64v",
      &glGetBufferParameteri64v_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetBufferParameteri64v");
    }
    out
  }
  static glGetBufferParameteri64v_p: APcv = ap_null();
  /// Tries to load [`glGetBufferParameteri64v`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetBufferParameteri64v_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetBufferParameteri64v\0",
      &glGetBufferParameteri64v_p,
    )
  }
  /// Checks if the pointer for [`glGetBufferParameteri64v`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetBufferParameteri64v_is_loaded() -> bool {
    !glGetBufferParameteri64v_p.load(RELAX).is_null()
  }

  /// [glGetBufferParameteriv](http://docs.gl/gl3/glGetBufferParameter)(target, pname, params)
  /// * `target` group: BufferTargetARB
  /// * `pname` group: BufferPNameARB
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetBufferParameteriv(
    target: GLenum, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetBufferParameteriv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetBufferParameteriv",
      &glGetBufferParameteriv_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetBufferParameteriv");
    }
    out
  }
  static glGetBufferParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetBufferParameteriv`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetBufferParameteriv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetBufferParameteriv\0",
      &glGetBufferParameteriv_p,
    )
  }
  /// Checks if the pointer for [`glGetBufferParameteriv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetBufferParameteriv_is_loaded() -> bool {
    !glGetBufferParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetBufferPointerv](http://docs.gl/gl3/glGetBufferPointerv)(target, pname, params)
  /// * `target` group: BufferTargetARB
  /// * `pname` group: BufferPointerNameARB
  /// * `params` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetBufferPointerv(
    target: GLenum, pname: GLenum, params: *mut *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetBufferPointerv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetBufferPointerv",
      &glGetBufferPointerv_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetBufferPointerv");
    }
    out
  }
  static glGetBufferPointerv_p: APcv = ap_null();
  /// Tries to load [`glGetBufferPointerv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetBufferPointerv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetBufferPointerv\0",
      &glGetBufferPointerv_p,
    )
  }
  /// Checks if the pointer for [`glGetBufferPointerv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetBufferPointerv_is_loaded() -> bool {
    !glGetBufferPointerv_p.load(RELAX).is_null()
  }

  /// [glGetBufferSubData](http://docs.gl/gl3/glGetBufferSubData)(target, offset, size, data)
  /// * `target` group: BufferTargetARB
  /// * `offset` group: BufferOffset
  /// * `size` group: BufferSize
  /// * `data` len: size
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetBufferSubData(
    target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetBufferSubData({:#X}, {:?}, {:?}, {:p});",
        target,
        offset,
        size,
        data
      );
    }
    let out = call_atomic_ptr_4arg(
      "glGetBufferSubData",
      &glGetBufferSubData_p,
      target,
      offset,
      size,
      data,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetBufferSubData");
    }
    out
  }
  static glGetBufferSubData_p: APcv = ap_null();
  /// Tries to load [`glGetBufferSubData`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetBufferSubData_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetBufferSubData\0",
      &glGetBufferSubData_p,
    )
  }
  /// Checks if the pointer for [`glGetBufferSubData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetBufferSubData_is_loaded() -> bool {
    !glGetBufferSubData_p.load(RELAX).is_null()
  }

  /// [glGetCompressedTexImage](http://docs.gl/gl3/glGetCompressedTexImage)(target, level, img)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `img` group: CompressedTextureARB
  /// * `img` len: COMPSIZE(target,level)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetCompressedTexImage(
    target: GLenum, level: GLint, img: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetCompressedTexImage({:#X}, {:?}, {:p});",
        target,
        level,
        img
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetCompressedTexImage",
      &glGetCompressedTexImage_p,
      target,
      level,
      img,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetCompressedTexImage");
    }
    out
  }
  static glGetCompressedTexImage_p: APcv = ap_null();
  /// Tries to load [`glGetCompressedTexImage`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetCompressedTexImage_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetCompressedTexImage\0",
      &glGetCompressedTexImage_p,
    )
  }
  /// Checks if the pointer for [`glGetCompressedTexImage`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetCompressedTexImage_is_loaded() -> bool {
    !glGetCompressedTexImage_p.load(RELAX).is_null()
  }

  /// [glGetDebugMessageLog](http://docs.gl/gl3/glGetDebugMessageLog)(count, bufSize, sources, types, ids, severities, lengths, messageLog)
  /// * `sources` group: DebugSource
  /// * `sources` len: count
  /// * `types` group: DebugType
  /// * `types` len: count
  /// * `ids` len: count
  /// * `severities` group: DebugSeverity
  /// * `severities` len: count
  /// * `lengths` len: count
  /// * `messageLog` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glGetDebugMessageLog(
    count: GLuint, bufSize: GLsizei, sources: *mut GLenum, types: *mut GLenum,
    ids: *mut GLuint, severities: *mut GLenum, lengths: *mut GLsizei,
    messageLog: *mut GLchar,
  ) -> GLuint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetDebugMessageLog({:?}, {:?}, {:p}, {:p}, {:p}, {:p}, {:p}, {:p});", count, bufSize, sources, types, ids, severities, lengths, messageLog);
    }
    let out = call_atomic_ptr_8arg(
      "glGetDebugMessageLog",
      &glGetDebugMessageLog_p,
      count,
      bufSize,
      sources,
      types,
      ids,
      severities,
      lengths,
      messageLog,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetDebugMessageLog");
    }
    out
  }
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  static glGetDebugMessageLog_p: APcv = ap_null();
  /// Tries to load [`glGetDebugMessageLog`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glGetDebugMessageLog_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetDebugMessageLog\0",
      &glGetDebugMessageLog_p,
    )
  }
  /// Checks if the pointer for [`glGetDebugMessageLog`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub fn glGetDebugMessageLog_is_loaded() -> bool {
    !glGetDebugMessageLog_p.load(RELAX).is_null()
  }

  /// [glGetDebugMessageLogARB](http://docs.gl/gl3/glGetDebugMessageLogARB)(count, bufSize, sources, types, ids, severities, lengths, messageLog)
  /// * `sources` group: DebugSource
  /// * `sources` len: count
  /// * `types` group: DebugType
  /// * `types` len: count
  /// * `ids` len: count
  /// * `severities` group: DebugSeverity
  /// * `severities` len: count
  /// * `lengths` len: count
  /// * `messageLog` len: bufSize
  /// * alias of: [`glGetDebugMessageLog`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub unsafe fn glGetDebugMessageLogARB(
    count: GLuint, bufSize: GLsizei, sources: *mut GLenum, types: *mut GLenum,
    ids: *mut GLuint, severities: *mut GLenum, lengths: *mut GLsizei,
    messageLog: *mut GLchar,
  ) -> GLuint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetDebugMessageLogARB({:?}, {:?}, {:p}, {:p}, {:p}, {:p}, {:p}, {:p});", count, bufSize, sources, types, ids, severities, lengths, messageLog);
    }
    let out = call_atomic_ptr_8arg(
      "glGetDebugMessageLogARB",
      &glGetDebugMessageLogARB_p,
      count,
      bufSize,
      sources,
      types,
      ids,
      severities,
      lengths,
      messageLog,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetDebugMessageLogARB");
    }
    out
  }
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  static glGetDebugMessageLogARB_p: APcv = ap_null();
  /// Tries to load [`glGetDebugMessageLogARB`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub unsafe fn glGetDebugMessageLogARB_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetDebugMessageLogARB\0",
      &glGetDebugMessageLogARB_p,
    )
  }
  /// Checks if the pointer for [`glGetDebugMessageLogARB`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_ARB_debug_output"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
  pub fn glGetDebugMessageLogARB_is_loaded() -> bool {
    !glGetDebugMessageLogARB_p.load(RELAX).is_null()
  }

  /// [glGetDoublev](http://docs.gl/gl3/glGetDoublev)(pname, data)
  /// * `pname` group: GetPName
  /// * `data` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetDoublev(pname: GLenum, data: *mut GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetDoublev({:#X}, {:p});", pname, data);
    }
    let out =
      call_atomic_ptr_2arg("glGetDoublev", &glGetDoublev_p, pname, data);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetDoublev");
    }
    out
  }
  static glGetDoublev_p: APcv = ap_null();
  /// Tries to load [`glGetDoublev`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetDoublev_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetDoublev\0",
      &glGetDoublev_p,
    )
  }
  /// Checks if the pointer for [`glGetDoublev`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetDoublev_is_loaded() -> bool {
    !glGetDoublev_p.load(RELAX).is_null()
  }

  /// [glGetError](http://docs.gl/gl3/glGetError)()
  /// * return value group: ErrorCode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetError() -> GLenum {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetError();",);
    }
    let out = call_atomic_ptr_0arg("glGetError", &glGetError_p);

    out
  }
  static glGetError_p: APcv = ap_null();
  /// Tries to load [`glGetError`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetError_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glGetError\0", &glGetError_p)
  }
  /// Checks if the pointer for [`glGetError`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetError_is_loaded() -> bool {
    !glGetError_p.load(RELAX).is_null()
  }

  /// [glGetFloatv](http://docs.gl/gl3/glGet)(pname, data)
  /// * `pname` group: GetPName
  /// * `data` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetFloatv(pname: GLenum, data: *mut GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetFloatv({:#X}, {:p});", pname, data);
    }
    let out = call_atomic_ptr_2arg("glGetFloatv", &glGetFloatv_p, pname, data);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetFloatv");
    }
    out
  }
  static glGetFloatv_p: APcv = ap_null();
  /// Tries to load [`glGetFloatv`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetFloatv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glGetFloatv\0", &glGetFloatv_p)
  }
  /// Checks if the pointer for [`glGetFloatv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetFloatv_is_loaded() -> bool {
    !glGetFloatv_p.load(RELAX).is_null()
  }

  /// [glGetFragDataIndex](http://docs.gl/gl3/glGetFragDataIndex)(program, name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetFragDataIndex(
    program: GLuint, name: *const GLchar,
  ) -> GLint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetFragDataIndex({:?}, {:p});", program, name);
    }
    let out = call_atomic_ptr_2arg(
      "glGetFragDataIndex",
      &glGetFragDataIndex_p,
      program,
      name,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetFragDataIndex");
    }
    out
  }
  static glGetFragDataIndex_p: APcv = ap_null();
  /// Tries to load [`glGetFragDataIndex`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetFragDataIndex_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetFragDataIndex\0",
      &glGetFragDataIndex_p,
    )
  }
  /// Checks if the pointer for [`glGetFragDataIndex`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetFragDataIndex_is_loaded() -> bool {
    !glGetFragDataIndex_p.load(RELAX).is_null()
  }

  /// [glGetFragDataLocation](http://docs.gl/gl3/glGetFragDataLocation)(program, name)
  /// * `name` len: COMPSIZE(name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetFragDataLocation(
    program: GLuint, name: *const GLchar,
  ) -> GLint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetFragDataLocation({:?}, {:p});", program, name);
    }
    let out = call_atomic_ptr_2arg(
      "glGetFragDataLocation",
      &glGetFragDataLocation_p,
      program,
      name,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetFragDataLocation");
    }
    out
  }
  static glGetFragDataLocation_p: APcv = ap_null();
  /// Tries to load [`glGetFragDataLocation`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetFragDataLocation_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetFragDataLocation\0",
      &glGetFragDataLocation_p,
    )
  }
  /// Checks if the pointer for [`glGetFragDataLocation`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetFragDataLocation_is_loaded() -> bool {
    !glGetFragDataLocation_p.load(RELAX).is_null()
  }

  /// [glGetFramebufferAttachmentParameteriv](http://docs.gl/gl3/glGetFramebufferAttachmentParameter)(target, attachment, pname, params)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  /// * `pname` group: FramebufferAttachmentParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetFramebufferAttachmentParameteriv(
    target: GLenum, attachment: GLenum, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetFramebufferAttachmentParameteriv({:#X}, {:#X}, {:#X}, {:p});", target, attachment, pname, params);
    }
    let out = call_atomic_ptr_4arg(
      "glGetFramebufferAttachmentParameteriv",
      &glGetFramebufferAttachmentParameteriv_p,
      target,
      attachment,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetFramebufferAttachmentParameteriv");
    }
    out
  }
  static glGetFramebufferAttachmentParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetFramebufferAttachmentParameteriv`], returns if a
  /// non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetFramebufferAttachmentParameteriv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetFramebufferAttachmentParameteriv\0",
      &glGetFramebufferAttachmentParameteriv_p,
    )
  }
  /// Checks if the pointer for [`glGetFramebufferAttachmentParameteriv`] is
  /// loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetFramebufferAttachmentParameteriv_is_loaded() -> bool {
    !glGetFramebufferAttachmentParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetInteger64i_v](http://docs.gl/gl3/glGet)(target, index, data)
  /// * `data` len: COMPSIZE(target)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetInteger64i_v(
    target: GLenum, index: GLuint, data: *mut GLint64,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetInteger64i_v({:#X}, {:?}, {:p});",
        target,
        index,
        data
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetInteger64i_v",
      &glGetInteger64i_v_p,
      target,
      index,
      data,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetInteger64i_v");
    }
    out
  }
  static glGetInteger64i_v_p: APcv = ap_null();
  /// Tries to load [`glGetInteger64i_v`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetInteger64i_v_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetInteger64i_v\0",
      &glGetInteger64i_v_p,
    )
  }
  /// Checks if the pointer for [`glGetInteger64i_v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetInteger64i_v_is_loaded() -> bool {
    !glGetInteger64i_v_p.load(RELAX).is_null()
  }

  /// [glGetInteger64v](http://docs.gl/gl3/glGet)(pname, data)
  /// * `pname` group: GetPName
  /// * `data` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetInteger64v(pname: GLenum, data: *mut GLint64) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetInteger64v({:#X}, {:p});", pname, data);
    }
    let out =
      call_atomic_ptr_2arg("glGetInteger64v", &glGetInteger64v_p, pname, data);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetInteger64v");
    }
    out
  }
  static glGetInteger64v_p: APcv = ap_null();
  /// Tries to load [`glGetInteger64v`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetInteger64v_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetInteger64v\0",
      &glGetInteger64v_p,
    )
  }
  /// Checks if the pointer for [`glGetInteger64v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetInteger64v_is_loaded() -> bool {
    !glGetInteger64v_p.load(RELAX).is_null()
  }

  /// [glGetIntegeri_v](http://docs.gl/gl3/glGet)(target, index, data)
  /// * `data` len: COMPSIZE(target)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetIntegeri_v(
    target: GLenum, index: GLuint, data: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetIntegeri_v({:#X}, {:?}, {:p});",
        target,
        index,
        data
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetIntegeri_v",
      &glGetIntegeri_v_p,
      target,
      index,
      data,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetIntegeri_v");
    }
    out
  }
  static glGetIntegeri_v_p: APcv = ap_null();
  /// Tries to load [`glGetIntegeri_v`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetIntegeri_v_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetIntegeri_v\0",
      &glGetIntegeri_v_p,
    )
  }
  /// Checks if the pointer for [`glGetIntegeri_v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetIntegeri_v_is_loaded() -> bool {
    !glGetIntegeri_v_p.load(RELAX).is_null()
  }

  /// [glGetIntegerv](http://docs.gl/gl3/glGet)(pname, data)
  /// * `pname` group: GetPName
  /// * `data` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetIntegerv(pname: GLenum, data: *mut GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetIntegerv({:#X}, {:p});", pname, data);
    }
    let out =
      call_atomic_ptr_2arg("glGetIntegerv", &glGetIntegerv_p, pname, data);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetIntegerv");
    }
    out
  }
  static glGetIntegerv_p: APcv = ap_null();
  /// Tries to load [`glGetIntegerv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetIntegerv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetIntegerv\0",
      &glGetIntegerv_p,
    )
  }
  /// Checks if the pointer for [`glGetIntegerv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetIntegerv_is_loaded() -> bool {
    !glGetIntegerv_p.load(RELAX).is_null()
  }

  /// [glGetMultisamplefv](http://docs.gl/gl3/glGetMultisample)(pname, index, val)
  /// * `pname` group: GetMultisamplePNameNV
  /// * `val` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetMultisamplefv(
    pname: GLenum, index: GLuint, val: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetMultisamplefv({:#X}, {:?}, {:p});",
        pname,
        index,
        val
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetMultisamplefv",
      &glGetMultisamplefv_p,
      pname,
      index,
      val,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetMultisamplefv");
    }
    out
  }
  static glGetMultisamplefv_p: APcv = ap_null();
  /// Tries to load [`glGetMultisamplefv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetMultisamplefv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetMultisamplefv\0",
      &glGetMultisamplefv_p,
    )
  }
  /// Checks if the pointer for [`glGetMultisamplefv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetMultisamplefv_is_loaded() -> bool {
    !glGetMultisamplefv_p.load(RELAX).is_null()
  }

  /// [glGetObjectLabel](http://docs.gl/gl3/glGetObjectLabel)(identifier, name, bufSize, length, label)
  /// * `identifier` group: ObjectIdentifier
  /// * `length` len: 1
  /// * `label` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glGetObjectLabel(
    identifier: GLenum, name: GLuint, bufSize: GLsizei, length: *mut GLsizei,
    label: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetObjectLabel({:#X}, {:?}, {:?}, {:p}, {:p});",
        identifier,
        name,
        bufSize,
        length,
        label
      );
    }
    let out = call_atomic_ptr_5arg(
      "glGetObjectLabel",
      &glGetObjectLabel_p,
      identifier,
      name,
      bufSize,
      length,
      label,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetObjectLabel");
    }
    out
  }
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  static glGetObjectLabel_p: APcv = ap_null();
  /// Tries to load [`glGetObjectLabel`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glGetObjectLabel_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetObjectLabel\0",
      &glGetObjectLabel_p,
    )
  }
  /// Checks if the pointer for [`glGetObjectLabel`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub fn glGetObjectLabel_is_loaded() -> bool {
    !glGetObjectLabel_p.load(RELAX).is_null()
  }

  /// [glGetObjectPtrLabel](http://docs.gl/gl3/glGetObjectPtrLabel)(ptr, bufSize, length, label)
  /// * `length` len: 1
  /// * `label` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glGetObjectPtrLabel(
    ptr: *const c_void, bufSize: GLsizei, length: *mut GLsizei,
    label: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetObjectPtrLabel({:p}, {:?}, {:p}, {:p});",
        ptr,
        bufSize,
        length,
        label
      );
    }
    let out = call_atomic_ptr_4arg(
      "glGetObjectPtrLabel",
      &glGetObjectPtrLabel_p,
      ptr,
      bufSize,
      length,
      label,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetObjectPtrLabel");
    }
    out
  }
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  static glGetObjectPtrLabel_p: APcv = ap_null();
  /// Tries to load [`glGetObjectPtrLabel`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glGetObjectPtrLabel_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetObjectPtrLabel\0",
      &glGetObjectPtrLabel_p,
    )
  }
  /// Checks if the pointer for [`glGetObjectPtrLabel`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub fn glGetObjectPtrLabel_is_loaded() -> bool {
    !glGetObjectPtrLabel_p.load(RELAX).is_null()
  }

  /// [glGetPointerv](http://docs.gl/gl3/glGetPointerv)(pname, params)
  /// * `pname` group: GetPointervPName
  /// * `params` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glGetPointerv(pname: GLenum, params: *mut *mut c_void) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetPointerv({:#X}, {:p});", pname, params);
    }
    let out =
      call_atomic_ptr_2arg("glGetPointerv", &glGetPointerv_p, pname, params);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetPointerv");
    }
    out
  }
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  static glGetPointerv_p: APcv = ap_null();
  /// Tries to load [`glGetPointerv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glGetPointerv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetPointerv\0",
      &glGetPointerv_p,
    )
  }
  /// Checks if the pointer for [`glGetPointerv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub fn glGetPointerv_is_loaded() -> bool {
    !glGetPointerv_p.load(RELAX).is_null()
  }

  /// [glGetProgramInfoLog](http://docs.gl/gl3/glGetProgramInfoLog)(program, bufSize, length, infoLog)
  /// * `length` len: 1
  /// * `infoLog` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramInfoLog(
    program: GLuint, bufSize: GLsizei, length: *mut GLsizei,
    infoLog: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetProgramInfoLog({:?}, {:?}, {:p}, {:p});",
        program,
        bufSize,
        length,
        infoLog
      );
    }
    let out = call_atomic_ptr_4arg(
      "glGetProgramInfoLog",
      &glGetProgramInfoLog_p,
      program,
      bufSize,
      length,
      infoLog,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetProgramInfoLog");
    }
    out
  }
  static glGetProgramInfoLog_p: APcv = ap_null();
  /// Tries to load [`glGetProgramInfoLog`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetProgramInfoLog_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetProgramInfoLog\0",
      &glGetProgramInfoLog_p,
    )
  }
  /// Checks if the pointer for [`glGetProgramInfoLog`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramInfoLog_is_loaded() -> bool {
    !glGetProgramInfoLog_p.load(RELAX).is_null()
  }

  /// [glGetProgramiv](http://docs.gl/gl3/glGetProgram)(program, pname, params)
  /// * `pname` group: ProgramPropertyARB
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramiv(
    program: GLuint, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetProgramiv({:?}, {:#X}, {:p});",
        program,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetProgramiv",
      &glGetProgramiv_p,
      program,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetProgramiv");
    }
    out
  }
  static glGetProgramiv_p: APcv = ap_null();
  /// Tries to load [`glGetProgramiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetProgramiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetProgramiv\0",
      &glGetProgramiv_p,
    )
  }
  /// Checks if the pointer for [`glGetProgramiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramiv_is_loaded() -> bool {
    !glGetProgramiv_p.load(RELAX).is_null()
  }

  /// [glGetQueryObjecti64v](http://docs.gl/gl3/glGetQueryObject)(id, pname, params)
  /// * `pname` group: QueryObjectParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryObjecti64v(
    id: GLuint, pname: GLenum, params: *mut GLint64,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryObjecti64v({:?}, {:#X}, {:p});",
        id,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetQueryObjecti64v",
      &glGetQueryObjecti64v_p,
      id,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetQueryObjecti64v");
    }
    out
  }
  static glGetQueryObjecti64v_p: APcv = ap_null();
  /// Tries to load [`glGetQueryObjecti64v`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetQueryObjecti64v_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetQueryObjecti64v\0",
      &glGetQueryObjecti64v_p,
    )
  }
  /// Checks if the pointer for [`glGetQueryObjecti64v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryObjecti64v_is_loaded() -> bool {
    !glGetQueryObjecti64v_p.load(RELAX).is_null()
  }

  /// [glGetQueryObjectiv](http://docs.gl/gl3/glGetQueryObject)(id, pname, params)
  /// * `pname` group: QueryObjectParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryObjectiv(
    id: GLuint, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryObjectiv({:?}, {:#X}, {:p});",
        id,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetQueryObjectiv",
      &glGetQueryObjectiv_p,
      id,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetQueryObjectiv");
    }
    out
  }
  static glGetQueryObjectiv_p: APcv = ap_null();
  /// Tries to load [`glGetQueryObjectiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetQueryObjectiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetQueryObjectiv\0",
      &glGetQueryObjectiv_p,
    )
  }
  /// Checks if the pointer for [`glGetQueryObjectiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryObjectiv_is_loaded() -> bool {
    !glGetQueryObjectiv_p.load(RELAX).is_null()
  }

  /// [glGetQueryObjectui64v](http://docs.gl/gl3/glGetQueryObjectu)(id, pname, params)
  /// * `pname` group: QueryObjectParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryObjectui64v(
    id: GLuint, pname: GLenum, params: *mut GLuint64,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryObjectui64v({:?}, {:#X}, {:p});",
        id,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetQueryObjectui64v",
      &glGetQueryObjectui64v_p,
      id,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetQueryObjectui64v");
    }
    out
  }
  static glGetQueryObjectui64v_p: APcv = ap_null();
  /// Tries to load [`glGetQueryObjectui64v`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetQueryObjectui64v_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetQueryObjectui64v\0",
      &glGetQueryObjectui64v_p,
    )
  }
  /// Checks if the pointer for [`glGetQueryObjectui64v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryObjectui64v_is_loaded() -> bool {
    !glGetQueryObjectui64v_p.load(RELAX).is_null()
  }

  /// [glGetQueryObjectuiv](http://docs.gl/gl3/glGetQueryObject)(id, pname, params)
  /// * `pname` group: QueryObjectParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryObjectuiv(
    id: GLuint, pname: GLenum, params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryObjectuiv({:?}, {:#X}, {:p});",
        id,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetQueryObjectuiv",
      &glGetQueryObjectuiv_p,
      id,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetQueryObjectuiv");
    }
    out
  }
  static glGetQueryObjectuiv_p: APcv = ap_null();
  /// Tries to load [`glGetQueryObjectuiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetQueryObjectuiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetQueryObjectuiv\0",
      &glGetQueryObjectuiv_p,
    )
  }
  /// Checks if the pointer for [`glGetQueryObjectuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryObjectuiv_is_loaded() -> bool {
    !glGetQueryObjectuiv_p.load(RELAX).is_null()
  }

  /// [glGetQueryiv](http://docs.gl/gl3/glGetQuery)(target, pname, params)
  /// * `target` group: QueryTarget
  /// * `pname` group: QueryParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryiv(
    target: GLenum, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryiv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetQueryiv",
      &glGetQueryiv_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetQueryiv");
    }
    out
  }
  static glGetQueryiv_p: APcv = ap_null();
  /// Tries to load [`glGetQueryiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetQueryiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetQueryiv\0",
      &glGetQueryiv_p,
    )
  }
  /// Checks if the pointer for [`glGetQueryiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryiv_is_loaded() -> bool {
    !glGetQueryiv_p.load(RELAX).is_null()
  }

  /// [glGetRenderbufferParameteriv](http://docs.gl/gl3/glGetRenderbufferParameter)(target, pname, params)
  /// * `target` group: RenderbufferTarget
  /// * `pname` group: RenderbufferParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetRenderbufferParameteriv(
    target: GLenum, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetRenderbufferParameteriv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetRenderbufferParameteriv",
      &glGetRenderbufferParameteriv_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetRenderbufferParameteriv");
    }
    out
  }
  static glGetRenderbufferParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetRenderbufferParameteriv`], returns if a non-null
  /// pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetRenderbufferParameteriv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetRenderbufferParameteriv\0",
      &glGetRenderbufferParameteriv_p,
    )
  }
  /// Checks if the pointer for [`glGetRenderbufferParameteriv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetRenderbufferParameteriv_is_loaded() -> bool {
    !glGetRenderbufferParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetSamplerParameterIiv](http://docs.gl/gl3/glGetSamplerParameter)(sampler, pname, params)
  /// * `pname` group: SamplerParameterI
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetSamplerParameterIiv(
    sampler: GLuint, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetSamplerParameterIiv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetSamplerParameterIiv",
      &glGetSamplerParameterIiv_p,
      sampler,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetSamplerParameterIiv");
    }
    out
  }
  static glGetSamplerParameterIiv_p: APcv = ap_null();
  /// Tries to load [`glGetSamplerParameterIiv`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetSamplerParameterIiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetSamplerParameterIiv\0",
      &glGetSamplerParameterIiv_p,
    )
  }
  /// Checks if the pointer for [`glGetSamplerParameterIiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetSamplerParameterIiv_is_loaded() -> bool {
    !glGetSamplerParameterIiv_p.load(RELAX).is_null()
  }

  /// [glGetSamplerParameterIuiv](http://docs.gl/gl3/glGetSamplerParameter)(sampler, pname, params)
  /// * `pname` group: SamplerParameterI
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetSamplerParameterIuiv(
    sampler: GLuint, pname: GLenum, params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetSamplerParameterIuiv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetSamplerParameterIuiv",
      &glGetSamplerParameterIuiv_p,
      sampler,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetSamplerParameterIuiv");
    }
    out
  }
  static glGetSamplerParameterIuiv_p: APcv = ap_null();
  /// Tries to load [`glGetSamplerParameterIuiv`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetSamplerParameterIuiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetSamplerParameterIuiv\0",
      &glGetSamplerParameterIuiv_p,
    )
  }
  /// Checks if the pointer for [`glGetSamplerParameterIuiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetSamplerParameterIuiv_is_loaded() -> bool {
    !glGetSamplerParameterIuiv_p.load(RELAX).is_null()
  }

  /// [glGetSamplerParameterfv](http://docs.gl/gl3/glGetSamplerParameter)(sampler, pname, params)
  /// * `pname` group: SamplerParameterF
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetSamplerParameterfv(
    sampler: GLuint, pname: GLenum, params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetSamplerParameterfv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetSamplerParameterfv",
      &glGetSamplerParameterfv_p,
      sampler,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetSamplerParameterfv");
    }
    out
  }
  static glGetSamplerParameterfv_p: APcv = ap_null();
  /// Tries to load [`glGetSamplerParameterfv`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetSamplerParameterfv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetSamplerParameterfv\0",
      &glGetSamplerParameterfv_p,
    )
  }
  /// Checks if the pointer for [`glGetSamplerParameterfv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetSamplerParameterfv_is_loaded() -> bool {
    !glGetSamplerParameterfv_p.load(RELAX).is_null()
  }

  /// [glGetSamplerParameteriv](http://docs.gl/gl3/glGetSamplerParameter)(sampler, pname, params)
  /// * `pname` group: SamplerParameterI
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetSamplerParameteriv(
    sampler: GLuint, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetSamplerParameteriv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetSamplerParameteriv",
      &glGetSamplerParameteriv_p,
      sampler,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetSamplerParameteriv");
    }
    out
  }
  static glGetSamplerParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetSamplerParameteriv`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetSamplerParameteriv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetSamplerParameteriv\0",
      &glGetSamplerParameteriv_p,
    )
  }
  /// Checks if the pointer for [`glGetSamplerParameteriv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetSamplerParameteriv_is_loaded() -> bool {
    !glGetSamplerParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetShaderInfoLog](http://docs.gl/gl3/glGetShaderInfoLog)(shader, bufSize, length, infoLog)
  /// * `length` len: 1
  /// * `infoLog` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetShaderInfoLog(
    shader: GLuint, bufSize: GLsizei, length: *mut GLsizei,
    infoLog: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetShaderInfoLog({:?}, {:?}, {:p}, {:p});",
        shader,
        bufSize,
        length,
        infoLog
      );
    }
    let out = call_atomic_ptr_4arg(
      "glGetShaderInfoLog",
      &glGetShaderInfoLog_p,
      shader,
      bufSize,
      length,
      infoLog,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetShaderInfoLog");
    }
    out
  }
  static glGetShaderInfoLog_p: APcv = ap_null();
  /// Tries to load [`glGetShaderInfoLog`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetShaderInfoLog_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetShaderInfoLog\0",
      &glGetShaderInfoLog_p,
    )
  }
  /// Checks if the pointer for [`glGetShaderInfoLog`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetShaderInfoLog_is_loaded() -> bool {
    !glGetShaderInfoLog_p.load(RELAX).is_null()
  }

  /// [glGetShaderSource](http://docs.gl/gl3/glGetShaderSource)(shader, bufSize, length, source)
  /// * `length` len: 1
  /// * `source` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetShaderSource(
    shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, source: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetShaderSource({:?}, {:?}, {:p}, {:p});",
        shader,
        bufSize,
        length,
        source
      );
    }
    let out = call_atomic_ptr_4arg(
      "glGetShaderSource",
      &glGetShaderSource_p,
      shader,
      bufSize,
      length,
      source,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetShaderSource");
    }
    out
  }
  static glGetShaderSource_p: APcv = ap_null();
  /// Tries to load [`glGetShaderSource`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetShaderSource_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetShaderSource\0",
      &glGetShaderSource_p,
    )
  }
  /// Checks if the pointer for [`glGetShaderSource`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetShaderSource_is_loaded() -> bool {
    !glGetShaderSource_p.load(RELAX).is_null()
  }

  /// [glGetShaderiv](http://docs.gl/gl3/glGetShaderiv)(shader, pname, params)
  /// * `pname` group: ShaderParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetShaderiv(
    shader: GLuint, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetShaderiv({:?}, {:#X}, {:p});",
        shader,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetShaderiv",
      &glGetShaderiv_p,
      shader,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetShaderiv");
    }
    out
  }
  static glGetShaderiv_p: APcv = ap_null();
  /// Tries to load [`glGetShaderiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetShaderiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetShaderiv\0",
      &glGetShaderiv_p,
    )
  }
  /// Checks if the pointer for [`glGetShaderiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetShaderiv_is_loaded() -> bool {
    !glGetShaderiv_p.load(RELAX).is_null()
  }

  /// [glGetString](http://docs.gl/gl3/glGetString)(name)
  /// * `name` group: StringName
  /// * return value group: String
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetString(name: GLenum) -> *const GLubyte {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetString({:#X});", name);
    }
    let out = call_atomic_ptr_1arg("glGetString", &glGetString_p, name);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetString");
    }
    out
  }
  static glGetString_p: APcv = ap_null();
  /// Tries to load [`glGetString`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetString_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glGetString\0", &glGetString_p)
  }
  /// Checks if the pointer for [`glGetString`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetString_is_loaded() -> bool {
    !glGetString_p.load(RELAX).is_null()
  }

  /// [glGetStringi](http://docs.gl/gl3/glGetString)(name, index)
  /// * `name` group: StringName
  /// * return value group: String
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetStringi(name: GLenum, index: GLuint) -> *const GLubyte {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetStringi({:#X}, {:?});", name, index);
    }
    let out =
      call_atomic_ptr_2arg("glGetStringi", &glGetStringi_p, name, index);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetStringi");
    }
    out
  }
  static glGetStringi_p: APcv = ap_null();
  /// Tries to load [`glGetStringi`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetStringi_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetStringi\0",
      &glGetStringi_p,
    )
  }
  /// Checks if the pointer for [`glGetStringi`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetStringi_is_loaded() -> bool {
    !glGetStringi_p.load(RELAX).is_null()
  }

  /// [glGetSynciv](http://docs.gl/gl3/glGetSync)(sync, pname, count, length, values)
  /// * `sync` group: sync
  /// * `pname` group: SyncParameterName
  /// * `length` len: 1
  /// * `values` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetSynciv(
    sync: GLsync, pname: GLenum, count: GLsizei, length: *mut GLsizei,
    values: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetSynciv({:p}, {:#X}, {:?}, {:p}, {:p});",
        sync,
        pname,
        count,
        length,
        values
      );
    }
    let out = call_atomic_ptr_5arg(
      "glGetSynciv",
      &glGetSynciv_p,
      sync,
      pname,
      count,
      length,
      values,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetSynciv");
    }
    out
  }
  static glGetSynciv_p: APcv = ap_null();
  /// Tries to load [`glGetSynciv`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetSynciv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glGetSynciv\0", &glGetSynciv_p)
  }
  /// Checks if the pointer for [`glGetSynciv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetSynciv_is_loaded() -> bool {
    !glGetSynciv_p.load(RELAX).is_null()
  }

  /// [glGetTexImage](http://docs.gl/gl3/glGetTexImage)(target, level, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(target,level,format,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexImage(
    target: GLenum, level: GLint, format: GLenum, type_: GLenum,
    pixels: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexImage({:#X}, {:?}, {:#X}, {:#X}, {:p});",
        target,
        level,
        format,
        type_,
        pixels
      );
    }
    let out = call_atomic_ptr_5arg(
      "glGetTexImage",
      &glGetTexImage_p,
      target,
      level,
      format,
      type_,
      pixels,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetTexImage");
    }
    out
  }
  static glGetTexImage_p: APcv = ap_null();
  /// Tries to load [`glGetTexImage`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetTexImage_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetTexImage\0",
      &glGetTexImage_p,
    )
  }
  /// Checks if the pointer for [`glGetTexImage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexImage_is_loaded() -> bool {
    !glGetTexImage_p.load(RELAX).is_null()
  }

  /// [glGetTexLevelParameterfv](http://docs.gl/gl3/glGetTexLevelParameter)(target, level, pname, params)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `pname` group: GetTextureParameter
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexLevelParameterfv(
    target: GLenum, level: GLint, pname: GLenum, params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexLevelParameterfv({:#X}, {:?}, {:#X}, {:p});",
        target,
        level,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_4arg(
      "glGetTexLevelParameterfv",
      &glGetTexLevelParameterfv_p,
      target,
      level,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetTexLevelParameterfv");
    }
    out
  }
  static glGetTexLevelParameterfv_p: APcv = ap_null();
  /// Tries to load [`glGetTexLevelParameterfv`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetTexLevelParameterfv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetTexLevelParameterfv\0",
      &glGetTexLevelParameterfv_p,
    )
  }
  /// Checks if the pointer for [`glGetTexLevelParameterfv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexLevelParameterfv_is_loaded() -> bool {
    !glGetTexLevelParameterfv_p.load(RELAX).is_null()
  }

  /// [glGetTexLevelParameteriv](http://docs.gl/gl3/glGetTexLevelParameter)(target, level, pname, params)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `pname` group: GetTextureParameter
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexLevelParameteriv(
    target: GLenum, level: GLint, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexLevelParameteriv({:#X}, {:?}, {:#X}, {:p});",
        target,
        level,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_4arg(
      "glGetTexLevelParameteriv",
      &glGetTexLevelParameteriv_p,
      target,
      level,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetTexLevelParameteriv");
    }
    out
  }
  static glGetTexLevelParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetTexLevelParameteriv`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetTexLevelParameteriv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetTexLevelParameteriv\0",
      &glGetTexLevelParameteriv_p,
    )
  }
  /// Checks if the pointer for [`glGetTexLevelParameteriv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexLevelParameteriv_is_loaded() -> bool {
    !glGetTexLevelParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetTexParameterIiv](http://docs.gl/gl3/glGetTexParameter)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: GetTextureParameter
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexParameterIiv(
    target: GLenum, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexParameterIiv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetTexParameterIiv",
      &glGetTexParameterIiv_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetTexParameterIiv");
    }
    out
  }
  static glGetTexParameterIiv_p: APcv = ap_null();
  /// Tries to load [`glGetTexParameterIiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetTexParameterIiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetTexParameterIiv\0",
      &glGetTexParameterIiv_p,
    )
  }
  /// Checks if the pointer for [`glGetTexParameterIiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexParameterIiv_is_loaded() -> bool {
    !glGetTexParameterIiv_p.load(RELAX).is_null()
  }

  /// [glGetTexParameterIuiv](http://docs.gl/gl3/glGetTexParameter)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: GetTextureParameter
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexParameterIuiv(
    target: GLenum, pname: GLenum, params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexParameterIuiv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetTexParameterIuiv",
      &glGetTexParameterIuiv_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetTexParameterIuiv");
    }
    out
  }
  static glGetTexParameterIuiv_p: APcv = ap_null();
  /// Tries to load [`glGetTexParameterIuiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetTexParameterIuiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetTexParameterIuiv\0",
      &glGetTexParameterIuiv_p,
    )
  }
  /// Checks if the pointer for [`glGetTexParameterIuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexParameterIuiv_is_loaded() -> bool {
    !glGetTexParameterIuiv_p.load(RELAX).is_null()
  }

  /// [glGetTexParameterfv](http://docs.gl/gl3/glGetTexParameter)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: GetTextureParameter
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexParameterfv(
    target: GLenum, pname: GLenum, params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexParameterfv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetTexParameterfv",
      &glGetTexParameterfv_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetTexParameterfv");
    }
    out
  }
  static glGetTexParameterfv_p: APcv = ap_null();
  /// Tries to load [`glGetTexParameterfv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetTexParameterfv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetTexParameterfv\0",
      &glGetTexParameterfv_p,
    )
  }
  /// Checks if the pointer for [`glGetTexParameterfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexParameterfv_is_loaded() -> bool {
    !glGetTexParameterfv_p.load(RELAX).is_null()
  }

  /// [glGetTexParameteriv](http://docs.gl/gl3/glGetTexParameter)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: GetTextureParameter
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexParameteriv(
    target: GLenum, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexParameteriv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetTexParameteriv",
      &glGetTexParameteriv_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetTexParameteriv");
    }
    out
  }
  static glGetTexParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetTexParameteriv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetTexParameteriv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetTexParameteriv\0",
      &glGetTexParameteriv_p,
    )
  }
  /// Checks if the pointer for [`glGetTexParameteriv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexParameteriv_is_loaded() -> bool {
    !glGetTexParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetTransformFeedbackVarying](http://docs.gl/gl3/glGetTransformFeedbackVarying)(program, index, bufSize, length, size, type_, name)
  /// * `length` len: 1
  /// * `size` len: 1
  /// * `type_` group: AttributeType
  /// * `type_` len: 1
  /// * `name` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTransformFeedbackVarying(
    program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei,
    size: *mut GLsizei, type_: *mut GLenum, name: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetTransformFeedbackVarying({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});", program, index, bufSize, length, size, type_, name);
    }
    let out = call_atomic_ptr_7arg(
      "glGetTransformFeedbackVarying",
      &glGetTransformFeedbackVarying_p,
      program,
      index,
      bufSize,
      length,
      size,
      type_,
      name,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetTransformFeedbackVarying");
    }
    out
  }
  static glGetTransformFeedbackVarying_p: APcv = ap_null();
  /// Tries to load [`glGetTransformFeedbackVarying`], returns if a non-null
  /// pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetTransformFeedbackVarying_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetTransformFeedbackVarying\0",
      &glGetTransformFeedbackVarying_p,
    )
  }
  /// Checks if the pointer for [`glGetTransformFeedbackVarying`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTransformFeedbackVarying_is_loaded() -> bool {
    !glGetTransformFeedbackVarying_p.load(RELAX).is_null()
  }

  /// [glGetUniformBlockIndex](http://docs.gl/gl3/glGetUniformBlockIndex)(program, uniformBlockName)
  /// * `uniformBlockName` len: COMPSIZE()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformBlockIndex(
    program: GLuint, uniformBlockName: *const GLchar,
  ) -> GLuint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetUniformBlockIndex({:?}, {:p});",
        program,
        uniformBlockName
      );
    }
    let out = call_atomic_ptr_2arg(
      "glGetUniformBlockIndex",
      &glGetUniformBlockIndex_p,
      program,
      uniformBlockName,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetUniformBlockIndex");
    }
    out
  }
  static glGetUniformBlockIndex_p: APcv = ap_null();
  /// Tries to load [`glGetUniformBlockIndex`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetUniformBlockIndex_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetUniformBlockIndex\0",
      &glGetUniformBlockIndex_p,
    )
  }
  /// Checks if the pointer for [`glGetUniformBlockIndex`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformBlockIndex_is_loaded() -> bool {
    !glGetUniformBlockIndex_p.load(RELAX).is_null()
  }

  /// [glGetUniformIndices](http://docs.gl/gl3/glGetUniformIndices)(program, uniformCount, uniformNames, uniformIndices)
  /// * `uniformNames` len: COMPSIZE(uniformCount)
  /// * `uniformIndices` len: COMPSIZE(uniformCount)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformIndices(
    program: GLuint, uniformCount: GLsizei, uniformNames: *const *const GLchar,
    uniformIndices: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetUniformIndices({:?}, {:?}, {:p}, {:p});",
        program,
        uniformCount,
        uniformNames,
        uniformIndices
      );
    }
    let out = call_atomic_ptr_4arg(
      "glGetUniformIndices",
      &glGetUniformIndices_p,
      program,
      uniformCount,
      uniformNames,
      uniformIndices,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetUniformIndices");
    }
    out
  }
  static glGetUniformIndices_p: APcv = ap_null();
  /// Tries to load [`glGetUniformIndices`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetUniformIndices_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetUniformIndices\0",
      &glGetUniformIndices_p,
    )
  }
  /// Checks if the pointer for [`glGetUniformIndices`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformIndices_is_loaded() -> bool {
    !glGetUniformIndices_p.load(RELAX).is_null()
  }

  /// [glGetUniformLocation](http://docs.gl/gl3/glGetUniformLocation)(program, name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformLocation(
    program: GLuint, name: *const GLchar,
  ) -> GLint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetUniformLocation({:?}, {:p});", program, name);
    }
    let out = call_atomic_ptr_2arg(
      "glGetUniformLocation",
      &glGetUniformLocation_p,
      program,
      name,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetUniformLocation");
    }
    out
  }
  static glGetUniformLocation_p: APcv = ap_null();
  /// Tries to load [`glGetUniformLocation`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetUniformLocation_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetUniformLocation\0",
      &glGetUniformLocation_p,
    )
  }
  /// Checks if the pointer for [`glGetUniformLocation`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformLocation_is_loaded() -> bool {
    !glGetUniformLocation_p.load(RELAX).is_null()
  }

  /// [glGetUniformfv](http://docs.gl/gl3/glGetUniform)(program, location, params)
  /// * `params` len: COMPSIZE(program,location)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformfv(
    program: GLuint, location: GLint, params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetUniformfv({:?}, {:?}, {:p});",
        program,
        location,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetUniformfv",
      &glGetUniformfv_p,
      program,
      location,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetUniformfv");
    }
    out
  }
  static glGetUniformfv_p: APcv = ap_null();
  /// Tries to load [`glGetUniformfv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetUniformfv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetUniformfv\0",
      &glGetUniformfv_p,
    )
  }
  /// Checks if the pointer for [`glGetUniformfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformfv_is_loaded() -> bool {
    !glGetUniformfv_p.load(RELAX).is_null()
  }

  /// [glGetUniformiv](http://docs.gl/gl3/glGetUniform)(program, location, params)
  /// * `params` len: COMPSIZE(program,location)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformiv(
    program: GLuint, location: GLint, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetUniformiv({:?}, {:?}, {:p});",
        program,
        location,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetUniformiv",
      &glGetUniformiv_p,
      program,
      location,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetUniformiv");
    }
    out
  }
  static glGetUniformiv_p: APcv = ap_null();
  /// Tries to load [`glGetUniformiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetUniformiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetUniformiv\0",
      &glGetUniformiv_p,
    )
  }
  /// Checks if the pointer for [`glGetUniformiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformiv_is_loaded() -> bool {
    !glGetUniformiv_p.load(RELAX).is_null()
  }

  /// [glGetUniformuiv](http://docs.gl/gl3/glGetUniform)(program, location, params)
  /// * `params` len: COMPSIZE(program,location)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformuiv(
    program: GLuint, location: GLint, params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetUniformuiv({:?}, {:?}, {:p});",
        program,
        location,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetUniformuiv",
      &glGetUniformuiv_p,
      program,
      location,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetUniformuiv");
    }
    out
  }
  static glGetUniformuiv_p: APcv = ap_null();
  /// Tries to load [`glGetUniformuiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetUniformuiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetUniformuiv\0",
      &glGetUniformuiv_p,
    )
  }
  /// Checks if the pointer for [`glGetUniformuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformuiv_is_loaded() -> bool {
    !glGetUniformuiv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribIiv](http://docs.gl/gl3/glGetVertexAttrib)(index, pname, params)
  /// * `pname` group: VertexAttribEnum
  /// * `params` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribIiv(
    index: GLuint, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribIiv({:?}, {:#X}, {:p});",
        index,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetVertexAttribIiv",
      &glGetVertexAttribIiv_p,
      index,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetVertexAttribIiv");
    }
    out
  }
  static glGetVertexAttribIiv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribIiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetVertexAttribIiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetVertexAttribIiv\0",
      &glGetVertexAttribIiv_p,
    )
  }
  /// Checks if the pointer for [`glGetVertexAttribIiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribIiv_is_loaded() -> bool {
    !glGetVertexAttribIiv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribIuiv](http://docs.gl/gl3/glGetVertexAttrib)(index, pname, params)
  /// * `pname` group: VertexAttribEnum
  /// * `params` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribIuiv(
    index: GLuint, pname: GLenum, params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribIuiv({:?}, {:#X}, {:p});",
        index,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetVertexAttribIuiv",
      &glGetVertexAttribIuiv_p,
      index,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetVertexAttribIuiv");
    }
    out
  }
  static glGetVertexAttribIuiv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribIuiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetVertexAttribIuiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetVertexAttribIuiv\0",
      &glGetVertexAttribIuiv_p,
    )
  }
  /// Checks if the pointer for [`glGetVertexAttribIuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribIuiv_is_loaded() -> bool {
    !glGetVertexAttribIuiv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribPointerv](http://docs.gl/gl3/glGetVertexAttribPointerv)(index, pname, pointer)
  /// * `pname` group: VertexAttribPointerPropertyARB
  /// * `pointer` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribPointerv(
    index: GLuint, pname: GLenum, pointer: *mut *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribPointerv({:?}, {:#X}, {:p});",
        index,
        pname,
        pointer
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetVertexAttribPointerv",
      &glGetVertexAttribPointerv_p,
      index,
      pname,
      pointer,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetVertexAttribPointerv");
    }
    out
  }
  static glGetVertexAttribPointerv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribPointerv`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glGetVertexAttribPointerv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetVertexAttribPointerv\0",
      &glGetVertexAttribPointerv_p,
    )
  }
  /// Checks if the pointer for [`glGetVertexAttribPointerv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribPointerv_is_loaded() -> bool {
    !glGetVertexAttribPointerv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribdv](http://docs.gl/gl3/glGetVertexAttribdv)(index, pname, params)
  /// * `pname` group: VertexAttribPropertyARB
  /// * `params` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribdv(
    index: GLuint, pname: GLenum, params: *mut GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribdv({:?}, {:#X}, {:p});",
        index,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetVertexAttribdv",
      &glGetVertexAttribdv_p,
      index,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetVertexAttribdv");
    }
    out
  }
  static glGetVertexAttribdv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribdv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetVertexAttribdv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetVertexAttribdv\0",
      &glGetVertexAttribdv_p,
    )
  }
  /// Checks if the pointer for [`glGetVertexAttribdv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribdv_is_loaded() -> bool {
    !glGetVertexAttribdv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribfv](http://docs.gl/gl3/glGetVertexAttrib)(index, pname, params)
  /// * `pname` group: VertexAttribPropertyARB
  /// * `params` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribfv(
    index: GLuint, pname: GLenum, params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribfv({:?}, {:#X}, {:p});",
        index,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetVertexAttribfv",
      &glGetVertexAttribfv_p,
      index,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetVertexAttribfv");
    }
    out
  }
  static glGetVertexAttribfv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribfv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetVertexAttribfv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetVertexAttribfv\0",
      &glGetVertexAttribfv_p,
    )
  }
  /// Checks if the pointer for [`glGetVertexAttribfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribfv_is_loaded() -> bool {
    !glGetVertexAttribfv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribiv](http://docs.gl/gl3/glGetVertexAttrib)(index, pname, params)
  /// * `pname` group: VertexAttribPropertyARB
  /// * `params` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribiv(
    index: GLuint, pname: GLenum, params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribiv({:?}, {:#X}, {:p});",
        index,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glGetVertexAttribiv",
      &glGetVertexAttribiv_p,
      index,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glGetVertexAttribiv");
    }
    out
  }
  static glGetVertexAttribiv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glGetVertexAttribiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glGetVertexAttribiv\0",
      &glGetVertexAttribiv_p,
    )
  }
  /// Checks if the pointer for [`glGetVertexAttribiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribiv_is_loaded() -> bool {
    !glGetVertexAttribiv_p.load(RELAX).is_null()
  }

  /// [glHint](http://docs.gl/gl3/glHint)(target, mode)
  /// * `target` group: HintTarget
  /// * `mode` group: HintMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glHint(target: GLenum, mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glHint({:#X}, {:#X});", target, mode);
    }
    let out = call_atomic_ptr_2arg("glHint", &glHint_p, target, mode);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glHint");
    }
    out
  }
  static glHint_p: APcv = ap_null();
  /// Tries to load [`glHint`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glHint_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glHint\0", &glHint_p)
  }
  /// Checks if the pointer for [`glHint`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glHint_is_loaded() -> bool {
    !glHint_p.load(RELAX).is_null()
  }

  /// [glIsBuffer](http://docs.gl/gl3/glIsBuffer)(buffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsBuffer(buffer: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsBuffer({:?});", buffer);
    }
    let out = call_atomic_ptr_1arg("glIsBuffer", &glIsBuffer_p, buffer);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glIsBuffer");
    }
    out
  }
  static glIsBuffer_p: APcv = ap_null();
  /// Tries to load [`glIsBuffer`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glIsBuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glIsBuffer\0", &glIsBuffer_p)
  }
  /// Checks if the pointer for [`glIsBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsBuffer_is_loaded() -> bool {
    !glIsBuffer_p.load(RELAX).is_null()
  }

  /// [glIsEnabled](http://docs.gl/gl3/glIsEnabled)(cap)
  /// * `cap` group: EnableCap
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsEnabled(cap: GLenum) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsEnabled({:#X});", cap);
    }
    let out = call_atomic_ptr_1arg("glIsEnabled", &glIsEnabled_p, cap);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glIsEnabled");
    }
    out
  }
  static glIsEnabled_p: APcv = ap_null();
  /// Tries to load [`glIsEnabled`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glIsEnabled_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glIsEnabled\0", &glIsEnabled_p)
  }
  /// Checks if the pointer for [`glIsEnabled`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsEnabled_is_loaded() -> bool {
    !glIsEnabled_p.load(RELAX).is_null()
  }

  /// [glIsEnabledi](http://docs.gl/gl3/glIsEnabled)(target, index)
  /// * `target` group: EnableCap
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsEnabledi(target: GLenum, index: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsEnabledi({:#X}, {:?});", target, index);
    }
    let out =
      call_atomic_ptr_2arg("glIsEnabledi", &glIsEnabledi_p, target, index);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glIsEnabledi");
    }
    out
  }
  static glIsEnabledi_p: APcv = ap_null();
  /// Tries to load [`glIsEnabledi`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glIsEnabledi_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glIsEnabledi\0",
      &glIsEnabledi_p,
    )
  }
  /// Checks if the pointer for [`glIsEnabledi`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsEnabledi_is_loaded() -> bool {
    !glIsEnabledi_p.load(RELAX).is_null()
  }

  /// [glIsFramebuffer](http://docs.gl/gl3/glIsFramebuffer)(framebuffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsFramebuffer(framebuffer: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsFramebuffer({:?});", framebuffer);
    }
    let out =
      call_atomic_ptr_1arg("glIsFramebuffer", &glIsFramebuffer_p, framebuffer);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glIsFramebuffer");
    }
    out
  }
  static glIsFramebuffer_p: APcv = ap_null();
  /// Tries to load [`glIsFramebuffer`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glIsFramebuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glIsFramebuffer\0",
      &glIsFramebuffer_p,
    )
  }
  /// Checks if the pointer for [`glIsFramebuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsFramebuffer_is_loaded() -> bool {
    !glIsFramebuffer_p.load(RELAX).is_null()
  }

  /// [glIsProgram](http://docs.gl/gl3/glIsProgram)(program)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsProgram(program: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsProgram({:?});", program);
    }
    let out = call_atomic_ptr_1arg("glIsProgram", &glIsProgram_p, program);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glIsProgram");
    }
    out
  }
  static glIsProgram_p: APcv = ap_null();
  /// Tries to load [`glIsProgram`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glIsProgram_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glIsProgram\0", &glIsProgram_p)
  }
  /// Checks if the pointer for [`glIsProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsProgram_is_loaded() -> bool {
    !glIsProgram_p.load(RELAX).is_null()
  }

  /// [glIsQuery](http://docs.gl/gl3/glIsQuery)(id)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsQuery(id: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsQuery({:?});", id);
    }
    let out = call_atomic_ptr_1arg("glIsQuery", &glIsQuery_p, id);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glIsQuery");
    }
    out
  }
  static glIsQuery_p: APcv = ap_null();
  /// Tries to load [`glIsQuery`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glIsQuery_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glIsQuery\0", &glIsQuery_p)
  }
  /// Checks if the pointer for [`glIsQuery`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsQuery_is_loaded() -> bool {
    !glIsQuery_p.load(RELAX).is_null()
  }

  /// [glIsRenderbuffer](http://docs.gl/gl3/glIsRenderbuffer)(renderbuffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsRenderbuffer(renderbuffer: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsRenderbuffer({:?});", renderbuffer);
    }
    let out = call_atomic_ptr_1arg(
      "glIsRenderbuffer",
      &glIsRenderbuffer_p,
      renderbuffer,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glIsRenderbuffer");
    }
    out
  }
  static glIsRenderbuffer_p: APcv = ap_null();
  /// Tries to load [`glIsRenderbuffer`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glIsRenderbuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glIsRenderbuffer\0",
      &glIsRenderbuffer_p,
    )
  }
  /// Checks if the pointer for [`glIsRenderbuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsRenderbuffer_is_loaded() -> bool {
    !glIsRenderbuffer_p.load(RELAX).is_null()
  }

  /// [glIsSampler](http://docs.gl/gl3/glIsSampler)(sampler)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsSampler(sampler: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsSampler({:?});", sampler);
    }
    let out = call_atomic_ptr_1arg("glIsSampler", &glIsSampler_p, sampler);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glIsSampler");
    }
    out
  }
  static glIsSampler_p: APcv = ap_null();
  /// Tries to load [`glIsSampler`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glIsSampler_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glIsSampler\0", &glIsSampler_p)
  }
  /// Checks if the pointer for [`glIsSampler`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsSampler_is_loaded() -> bool {
    !glIsSampler_p.load(RELAX).is_null()
  }

  /// [glIsShader](http://docs.gl/gl3/glIsShader)(shader)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsShader(shader: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsShader({:?});", shader);
    }
    let out = call_atomic_ptr_1arg("glIsShader", &glIsShader_p, shader);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glIsShader");
    }
    out
  }
  static glIsShader_p: APcv = ap_null();
  /// Tries to load [`glIsShader`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glIsShader_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glIsShader\0", &glIsShader_p)
  }
  /// Checks if the pointer for [`glIsShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsShader_is_loaded() -> bool {
    !glIsShader_p.load(RELAX).is_null()
  }

  /// [glIsSync](http://docs.gl/gl3/glIsSync)(sync)
  /// * `sync` group: sync
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsSync(sync: GLsync) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsSync({:p});", sync);
    }
    let out = call_atomic_ptr_1arg("glIsSync", &glIsSync_p, sync);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glIsSync");
    }
    out
  }
  static glIsSync_p: APcv = ap_null();
  /// Tries to load [`glIsSync`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glIsSync_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glIsSync\0", &glIsSync_p)
  }
  /// Checks if the pointer for [`glIsSync`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsSync_is_loaded() -> bool {
    !glIsSync_p.load(RELAX).is_null()
  }

  /// [glIsTexture](http://docs.gl/gl3/glIsTexture)(texture)
  /// * `texture` group: Texture
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsTexture(texture: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsTexture({:?});", texture);
    }
    let out = call_atomic_ptr_1arg("glIsTexture", &glIsTexture_p, texture);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glIsTexture");
    }
    out
  }
  static glIsTexture_p: APcv = ap_null();
  /// Tries to load [`glIsTexture`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glIsTexture_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glIsTexture\0", &glIsTexture_p)
  }
  /// Checks if the pointer for [`glIsTexture`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsTexture_is_loaded() -> bool {
    !glIsTexture_p.load(RELAX).is_null()
  }

  /// [glIsVertexArray](http://docs.gl/gl3/glIsVertexArray)(array)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsVertexArray(array: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsVertexArray({:?});", array);
    }
    let out =
      call_atomic_ptr_1arg("glIsVertexArray", &glIsVertexArray_p, array);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glIsVertexArray");
    }
    out
  }
  static glIsVertexArray_p: APcv = ap_null();
  /// Tries to load [`glIsVertexArray`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glIsVertexArray_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glIsVertexArray\0",
      &glIsVertexArray_p,
    )
  }
  /// Checks if the pointer for [`glIsVertexArray`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsVertexArray_is_loaded() -> bool {
    !glIsVertexArray_p.load(RELAX).is_null()
  }

  /// [glLineWidth](http://docs.gl/gl3/glLineWidth)(width)
  /// * `width` group: CheckedFloat32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glLineWidth(width: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glLineWidth({:?});", width);
    }
    let out = call_atomic_ptr_1arg("glLineWidth", &glLineWidth_p, width);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glLineWidth");
    }
    out
  }
  static glLineWidth_p: APcv = ap_null();
  /// Tries to load [`glLineWidth`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glLineWidth_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glLineWidth\0", &glLineWidth_p)
  }
  /// Checks if the pointer for [`glLineWidth`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glLineWidth_is_loaded() -> bool {
    !glLineWidth_p.load(RELAX).is_null()
  }

  /// [glLinkProgram](http://docs.gl/gl3/glLinkProgram)(program)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glLinkProgram(program: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glLinkProgram({:?});", program);
    }
    let out = call_atomic_ptr_1arg("glLinkProgram", &glLinkProgram_p, program);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glLinkProgram");
    }
    out
  }
  static glLinkProgram_p: APcv = ap_null();
  /// Tries to load [`glLinkProgram`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glLinkProgram_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glLinkProgram\0",
      &glLinkProgram_p,
    )
  }
  /// Checks if the pointer for [`glLinkProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glLinkProgram_is_loaded() -> bool {
    !glLinkProgram_p.load(RELAX).is_null()
  }

  /// [glLogicOp](http://docs.gl/gl3/glLogicOp)(opcode)
  /// * `opcode` group: LogicOp
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glLogicOp(opcode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glLogicOp({:#X});", opcode);
    }
    let out = call_atomic_ptr_1arg("glLogicOp", &glLogicOp_p, opcode);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glLogicOp");
    }
    out
  }
  static glLogicOp_p: APcv = ap_null();
  /// Tries to load [`glLogicOp`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glLogicOp_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glLogicOp\0", &glLogicOp_p)
  }
  /// Checks if the pointer for [`glLogicOp`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glLogicOp_is_loaded() -> bool {
    !glLogicOp_p.load(RELAX).is_null()
  }

  /// [glMapBuffer](http://docs.gl/gl3/glMapBuffer)(target, access)
  /// * `target` group: BufferTargetARB
  /// * `access` group: BufferAccessARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMapBuffer(target: GLenum, access: GLenum) -> *mut c_void {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glMapBuffer({:#X}, {:#X});", target, access);
    }
    let out =
      call_atomic_ptr_2arg("glMapBuffer", &glMapBuffer_p, target, access);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glMapBuffer");
    }
    out
  }
  static glMapBuffer_p: APcv = ap_null();
  /// Tries to load [`glMapBuffer`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glMapBuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glMapBuffer\0", &glMapBuffer_p)
  }
  /// Checks if the pointer for [`glMapBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMapBuffer_is_loaded() -> bool {
    !glMapBuffer_p.load(RELAX).is_null()
  }

  /// [glMapBufferRange](http://docs.gl/gl3/glMapBufferRange)(target, offset, length, access)
  /// * `target` group: BufferTargetARB
  /// * `offset` group: BufferOffset
  /// * `length` group: BufferSize
  /// * `access` group: MapBufferAccessMask
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMapBufferRange(
    target: GLenum, offset: GLintptr, length: GLsizeiptr, access: GLbitfield,
  ) -> *mut c_void {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glMapBufferRange({:#X}, {:?}, {:?}, {:?});",
        target,
        offset,
        length,
        access
      );
    }
    let out = call_atomic_ptr_4arg(
      "glMapBufferRange",
      &glMapBufferRange_p,
      target,
      offset,
      length,
      access,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glMapBufferRange");
    }
    out
  }
  static glMapBufferRange_p: APcv = ap_null();
  /// Tries to load [`glMapBufferRange`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glMapBufferRange_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glMapBufferRange\0",
      &glMapBufferRange_p,
    )
  }
  /// Checks if the pointer for [`glMapBufferRange`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMapBufferRange_is_loaded() -> bool {
    !glMapBufferRange_p.load(RELAX).is_null()
  }

  /// [glMultiDrawArrays](http://docs.gl/gl3/glMultiDrawArrays)(mode, first, count, drawcount)
  /// * `mode` group: PrimitiveType
  /// * `first` len: COMPSIZE(drawcount)
  /// * `count` len: COMPSIZE(drawcount)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMultiDrawArrays(
    mode: GLenum, first: *const GLint, count: *const GLsizei,
    drawcount: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glMultiDrawArrays({:#X}, {:p}, {:p}, {:?});",
        mode,
        first,
        count,
        drawcount
      );
    }
    let out = call_atomic_ptr_4arg(
      "glMultiDrawArrays",
      &glMultiDrawArrays_p,
      mode,
      first,
      count,
      drawcount,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glMultiDrawArrays");
    }
    out
  }
  static glMultiDrawArrays_p: APcv = ap_null();
  /// Tries to load [`glMultiDrawArrays`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glMultiDrawArrays_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glMultiDrawArrays\0",
      &glMultiDrawArrays_p,
    )
  }
  /// Checks if the pointer for [`glMultiDrawArrays`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMultiDrawArrays_is_loaded() -> bool {
    !glMultiDrawArrays_p.load(RELAX).is_null()
  }

  /// [glMultiDrawElements](http://docs.gl/gl3/glMultiDrawElements)(mode, count, type_, indices, drawcount)
  /// * `mode` group: PrimitiveType
  /// * `count` len: COMPSIZE(drawcount)
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(drawcount)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMultiDrawElements(
    mode: GLenum, count: *const GLsizei, type_: GLenum,
    indices: *const *const c_void, drawcount: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glMultiDrawElements({:#X}, {:p}, {:#X}, {:p}, {:?});",
        mode,
        count,
        type_,
        indices,
        drawcount
      );
    }
    let out = call_atomic_ptr_5arg(
      "glMultiDrawElements",
      &glMultiDrawElements_p,
      mode,
      count,
      type_,
      indices,
      drawcount,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glMultiDrawElements");
    }
    out
  }
  static glMultiDrawElements_p: APcv = ap_null();
  /// Tries to load [`glMultiDrawElements`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glMultiDrawElements_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glMultiDrawElements\0",
      &glMultiDrawElements_p,
    )
  }
  /// Checks if the pointer for [`glMultiDrawElements`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMultiDrawElements_is_loaded() -> bool {
    !glMultiDrawElements_p.load(RELAX).is_null()
  }

  /// [glMultiDrawElementsBaseVertex](http://docs.gl/gl3/glMultiDrawElementsBaseVertex)(mode, count, type_, indices, drawcount, basevertex)
  /// * `mode` group: PrimitiveType
  /// * `count` len: COMPSIZE(drawcount)
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(drawcount)
  /// * `basevertex` len: COMPSIZE(drawcount)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMultiDrawElementsBaseVertex(
    mode: GLenum, count: *const GLsizei, type_: GLenum,
    indices: *const *const c_void, drawcount: GLsizei,
    basevertex: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glMultiDrawElementsBaseVertex({:#X}, {:p}, {:#X}, {:p}, {:?}, {:p});", mode, count, type_, indices, drawcount, basevertex);
    }
    let out = call_atomic_ptr_6arg(
      "glMultiDrawElementsBaseVertex",
      &glMultiDrawElementsBaseVertex_p,
      mode,
      count,
      type_,
      indices,
      drawcount,
      basevertex,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glMultiDrawElementsBaseVertex");
    }
    out
  }
  static glMultiDrawElementsBaseVertex_p: APcv = ap_null();
  /// Tries to load [`glMultiDrawElementsBaseVertex`], returns if a non-null
  /// pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glMultiDrawElementsBaseVertex_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glMultiDrawElementsBaseVertex\0",
      &glMultiDrawElementsBaseVertex_p,
    )
  }
  /// Checks if the pointer for [`glMultiDrawElementsBaseVertex`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMultiDrawElementsBaseVertex_is_loaded() -> bool {
    !glMultiDrawElementsBaseVertex_p.load(RELAX).is_null()
  }

  /// [glObjectLabel](http://docs.gl/gl3/glObjectLabel)(identifier, name, length, label)
  /// * `identifier` group: ObjectIdentifier
  /// * `label` len: COMPSIZE(label,length)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glObjectLabel(
    identifier: GLenum, name: GLuint, length: GLsizei, label: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glObjectLabel({:#X}, {:?}, {:?}, {:p});",
        identifier,
        name,
        length,
        label
      );
    }
    let out = call_atomic_ptr_4arg(
      "glObjectLabel",
      &glObjectLabel_p,
      identifier,
      name,
      length,
      label,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glObjectLabel");
    }
    out
  }
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  static glObjectLabel_p: APcv = ap_null();
  /// Tries to load [`glObjectLabel`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glObjectLabel_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glObjectLabel\0",
      &glObjectLabel_p,
    )
  }
  /// Checks if the pointer for [`glObjectLabel`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub fn glObjectLabel_is_loaded() -> bool {
    !glObjectLabel_p.load(RELAX).is_null()
  }

  /// [glObjectPtrLabel](http://docs.gl/gl3/glObjectPtrLabel)(ptr, length, label)
  /// * `label` len: COMPSIZE(label,length)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glObjectPtrLabel(
    ptr: *const c_void, length: GLsizei, label: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glObjectPtrLabel({:p}, {:?}, {:p});", ptr, length, label);
    }
    let out = call_atomic_ptr_3arg(
      "glObjectPtrLabel",
      &glObjectPtrLabel_p,
      ptr,
      length,
      label,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glObjectPtrLabel");
    }
    out
  }
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  static glObjectPtrLabel_p: APcv = ap_null();
  /// Tries to load [`glObjectPtrLabel`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glObjectPtrLabel_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glObjectPtrLabel\0",
      &glObjectPtrLabel_p,
    )
  }
  /// Checks if the pointer for [`glObjectPtrLabel`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub fn glObjectPtrLabel_is_loaded() -> bool {
    !glObjectPtrLabel_p.load(RELAX).is_null()
  }

  /// [glPixelStoref](http://docs.gl/gl3/glPixelStore)(pname, param)
  /// * `pname` group: PixelStoreParameter
  /// * `param` group: CheckedFloat32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPixelStoref(pname: GLenum, param: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPixelStoref({:#X}, {:?});", pname, param);
    }
    let out =
      call_atomic_ptr_2arg("glPixelStoref", &glPixelStoref_p, pname, param);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glPixelStoref");
    }
    out
  }
  static glPixelStoref_p: APcv = ap_null();
  /// Tries to load [`glPixelStoref`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glPixelStoref_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glPixelStoref\0",
      &glPixelStoref_p,
    )
  }
  /// Checks if the pointer for [`glPixelStoref`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPixelStoref_is_loaded() -> bool {
    !glPixelStoref_p.load(RELAX).is_null()
  }

  /// [glPixelStorei](http://docs.gl/gl3/glPixelStore)(pname, param)
  /// * `pname` group: PixelStoreParameter
  /// * `param` group: CheckedInt32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPixelStorei(pname: GLenum, param: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPixelStorei({:#X}, {:?});", pname, param);
    }
    let out =
      call_atomic_ptr_2arg("glPixelStorei", &glPixelStorei_p, pname, param);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glPixelStorei");
    }
    out
  }
  static glPixelStorei_p: APcv = ap_null();
  /// Tries to load [`glPixelStorei`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glPixelStorei_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glPixelStorei\0",
      &glPixelStorei_p,
    )
  }
  /// Checks if the pointer for [`glPixelStorei`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPixelStorei_is_loaded() -> bool {
    !glPixelStorei_p.load(RELAX).is_null()
  }

  /// [glPointParameterf](http://docs.gl/gl3/glPointParameter)(pname, param)
  /// * `pname` group: PointParameterNameARB
  /// * `param` group: CheckedFloat32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPointParameterf(pname: GLenum, param: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPointParameterf({:#X}, {:?});", pname, param);
    }
    let out = call_atomic_ptr_2arg(
      "glPointParameterf",
      &glPointParameterf_p,
      pname,
      param,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glPointParameterf");
    }
    out
  }
  static glPointParameterf_p: APcv = ap_null();
  /// Tries to load [`glPointParameterf`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glPointParameterf_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glPointParameterf\0",
      &glPointParameterf_p,
    )
  }
  /// Checks if the pointer for [`glPointParameterf`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPointParameterf_is_loaded() -> bool {
    !glPointParameterf_p.load(RELAX).is_null()
  }

  /// [glPointParameterfv](http://docs.gl/gl3/glPointParameter)(pname, params)
  /// * `pname` group: PointParameterNameARB
  /// * `params` group: CheckedFloat32
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPointParameterfv(pname: GLenum, params: *const GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPointParameterfv({:#X}, {:p});", pname, params);
    }
    let out = call_atomic_ptr_2arg(
      "glPointParameterfv",
      &glPointParameterfv_p,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glPointParameterfv");
    }
    out
  }
  static glPointParameterfv_p: APcv = ap_null();
  /// Tries to load [`glPointParameterfv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glPointParameterfv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glPointParameterfv\0",
      &glPointParameterfv_p,
    )
  }
  /// Checks if the pointer for [`glPointParameterfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPointParameterfv_is_loaded() -> bool {
    !glPointParameterfv_p.load(RELAX).is_null()
  }

  /// [glPointParameteri](http://docs.gl/gl3/glPointParameter)(pname, param)
  /// * `pname` group: PointParameterNameARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPointParameteri(pname: GLenum, param: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPointParameteri({:#X}, {:?});", pname, param);
    }
    let out = call_atomic_ptr_2arg(
      "glPointParameteri",
      &glPointParameteri_p,
      pname,
      param,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glPointParameteri");
    }
    out
  }
  static glPointParameteri_p: APcv = ap_null();
  /// Tries to load [`glPointParameteri`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glPointParameteri_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glPointParameteri\0",
      &glPointParameteri_p,
    )
  }
  /// Checks if the pointer for [`glPointParameteri`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPointParameteri_is_loaded() -> bool {
    !glPointParameteri_p.load(RELAX).is_null()
  }

  /// [glPointParameteriv](http://docs.gl/gl3/glPointParameter)(pname, params)
  /// * `pname` group: PointParameterNameARB
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPointParameteriv(pname: GLenum, params: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPointParameteriv({:#X}, {:p});", pname, params);
    }
    let out = call_atomic_ptr_2arg(
      "glPointParameteriv",
      &glPointParameteriv_p,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glPointParameteriv");
    }
    out
  }
  static glPointParameteriv_p: APcv = ap_null();
  /// Tries to load [`glPointParameteriv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glPointParameteriv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glPointParameteriv\0",
      &glPointParameteriv_p,
    )
  }
  /// Checks if the pointer for [`glPointParameteriv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPointParameteriv_is_loaded() -> bool {
    !glPointParameteriv_p.load(RELAX).is_null()
  }

  /// [glPointSize](http://docs.gl/gl3/glPointSize)(size)
  /// * `size` group: CheckedFloat32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPointSize(size: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPointSize({:?});", size);
    }
    let out = call_atomic_ptr_1arg("glPointSize", &glPointSize_p, size);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glPointSize");
    }
    out
  }
  static glPointSize_p: APcv = ap_null();
  /// Tries to load [`glPointSize`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glPointSize_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glPointSize\0", &glPointSize_p)
  }
  /// Checks if the pointer for [`glPointSize`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPointSize_is_loaded() -> bool {
    !glPointSize_p.load(RELAX).is_null()
  }

  /// [glPolygonMode](http://docs.gl/gl3/glPolygonMode)(face, mode)
  /// * `face` group: MaterialFace
  /// * `mode` group: PolygonMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPolygonMode(face: GLenum, mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPolygonMode({:#X}, {:#X});", face, mode);
    }
    let out =
      call_atomic_ptr_2arg("glPolygonMode", &glPolygonMode_p, face, mode);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glPolygonMode");
    }
    out
  }
  static glPolygonMode_p: APcv = ap_null();
  /// Tries to load [`glPolygonMode`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glPolygonMode_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glPolygonMode\0",
      &glPolygonMode_p,
    )
  }
  /// Checks if the pointer for [`glPolygonMode`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPolygonMode_is_loaded() -> bool {
    !glPolygonMode_p.load(RELAX).is_null()
  }

  /// [glPolygonOffset](http://docs.gl/gl3/glPolygonOffset)(factor, units)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPolygonOffset(factor: GLfloat, units: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPolygonOffset({:?}, {:?});", factor, units);
    }
    let out = call_atomic_ptr_2arg(
      "glPolygonOffset",
      &glPolygonOffset_p,
      factor,
      units,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glPolygonOffset");
    }
    out
  }
  static glPolygonOffset_p: APcv = ap_null();
  /// Tries to load [`glPolygonOffset`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glPolygonOffset_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glPolygonOffset\0",
      &glPolygonOffset_p,
    )
  }
  /// Checks if the pointer for [`glPolygonOffset`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPolygonOffset_is_loaded() -> bool {
    !glPolygonOffset_p.load(RELAX).is_null()
  }

  /// [glPopDebugGroup](http://docs.gl/gl3/glPopDebugGroup)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glPopDebugGroup() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPopDebugGroup();",);
    }
    let out = call_atomic_ptr_0arg("glPopDebugGroup", &glPopDebugGroup_p);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glPopDebugGroup");
    }
    out
  }
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  static glPopDebugGroup_p: APcv = ap_null();
  /// Tries to load [`glPopDebugGroup`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glPopDebugGroup_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glPopDebugGroup\0",
      &glPopDebugGroup_p,
    )
  }
  /// Checks if the pointer for [`glPopDebugGroup`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub fn glPopDebugGroup_is_loaded() -> bool {
    !glPopDebugGroup_p.load(RELAX).is_null()
  }

  /// [glPrimitiveRestartIndex](http://docs.gl/gl3/glPrimitiveRestartIndex)(index)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPrimitiveRestartIndex(index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPrimitiveRestartIndex({:?});", index);
    }
    let out = call_atomic_ptr_1arg(
      "glPrimitiveRestartIndex",
      &glPrimitiveRestartIndex_p,
      index,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glPrimitiveRestartIndex");
    }
    out
  }
  static glPrimitiveRestartIndex_p: APcv = ap_null();
  /// Tries to load [`glPrimitiveRestartIndex`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glPrimitiveRestartIndex_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glPrimitiveRestartIndex\0",
      &glPrimitiveRestartIndex_p,
    )
  }
  /// Checks if the pointer for [`glPrimitiveRestartIndex`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPrimitiveRestartIndex_is_loaded() -> bool {
    !glPrimitiveRestartIndex_p.load(RELAX).is_null()
  }

  /// [glProvokingVertex](http://docs.gl/gl3/glProvokingVertex)(mode)
  /// * `mode` group: VertexProvokingMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProvokingVertex(mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glProvokingVertex({:#X});", mode);
    }
    let out =
      call_atomic_ptr_1arg("glProvokingVertex", &glProvokingVertex_p, mode);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glProvokingVertex");
    }
    out
  }
  static glProvokingVertex_p: APcv = ap_null();
  /// Tries to load [`glProvokingVertex`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glProvokingVertex_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glProvokingVertex\0",
      &glProvokingVertex_p,
    )
  }
  /// Checks if the pointer for [`glProvokingVertex`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProvokingVertex_is_loaded() -> bool {
    !glProvokingVertex_p.load(RELAX).is_null()
  }

  /// [glPushDebugGroup](http://docs.gl/gl3/glPushDebugGroup)(source, id, length, message)
  /// * `source` group: DebugSource
  /// * `message` len: COMPSIZE(message,length)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glPushDebugGroup(
    source: GLenum, id: GLuint, length: GLsizei, message: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glPushDebugGroup({:#X}, {:?}, {:?}, {:p});",
        source,
        id,
        length,
        message
      );
    }
    let out = call_atomic_ptr_4arg(
      "glPushDebugGroup",
      &glPushDebugGroup_p,
      source,
      id,
      length,
      message,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glPushDebugGroup");
    }
    out
  }
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  static glPushDebugGroup_p: APcv = ap_null();
  /// Tries to load [`glPushDebugGroup`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub unsafe fn glPushDebugGroup_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glPushDebugGroup\0",
      &glPushDebugGroup_p,
    )
  }
  /// Checks if the pointer for [`glPushDebugGroup`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  #[cfg(any(feature = "GL_KHR_debug"))]
  #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
  pub fn glPushDebugGroup_is_loaded() -> bool {
    !glPushDebugGroup_p.load(RELAX).is_null()
  }

  /// [glQueryCounter](http://docs.gl/gl3/glQueryCounter)(id, target)
  /// * `target` group: QueryCounterTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glQueryCounter(id: GLuint, target: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glQueryCounter({:?}, {:#X});", id, target);
    }
    let out =
      call_atomic_ptr_2arg("glQueryCounter", &glQueryCounter_p, id, target);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glQueryCounter");
    }
    out
  }
  static glQueryCounter_p: APcv = ap_null();
  /// Tries to load [`glQueryCounter`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glQueryCounter_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glQueryCounter\0",
      &glQueryCounter_p,
    )
  }
  /// Checks if the pointer for [`glQueryCounter`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glQueryCounter_is_loaded() -> bool {
    !glQueryCounter_p.load(RELAX).is_null()
  }

  /// [glReadBuffer](http://docs.gl/gl3/glReadBuffer)(src)
  /// * `src` group: ReadBufferMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glReadBuffer(src: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glReadBuffer({:#X});", src);
    }
    let out = call_atomic_ptr_1arg("glReadBuffer", &glReadBuffer_p, src);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glReadBuffer");
    }
    out
  }
  static glReadBuffer_p: APcv = ap_null();
  /// Tries to load [`glReadBuffer`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glReadBuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glReadBuffer\0",
      &glReadBuffer_p,
    )
  }
  /// Checks if the pointer for [`glReadBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glReadBuffer_is_loaded() -> bool {
    !glReadBuffer_p.load(RELAX).is_null()
  }

  /// [glReadPixels](http://docs.gl/gl3/glReadPixels)(x, y, width, height, format, type_, pixels)
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width,height)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glReadPixels(
    x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum,
    type_: GLenum, pixels: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glReadPixels({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
        x,
        y,
        width,
        height,
        format,
        type_,
        pixels
      );
    }
    let out = call_atomic_ptr_7arg(
      "glReadPixels",
      &glReadPixels_p,
      x,
      y,
      width,
      height,
      format,
      type_,
      pixels,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glReadPixels");
    }
    out
  }
  static glReadPixels_p: APcv = ap_null();
  /// Tries to load [`glReadPixels`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glReadPixels_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glReadPixels\0",
      &glReadPixels_p,
    )
  }
  /// Checks if the pointer for [`glReadPixels`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glReadPixels_is_loaded() -> bool {
    !glReadPixels_p.load(RELAX).is_null()
  }

  /// [glRenderbufferStorage](http://docs.gl/gl3/glRenderbufferStorage)(target, internalformat, width, height)
  /// * `target` group: RenderbufferTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glRenderbufferStorage(
    target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glRenderbufferStorage({:#X}, {:#X}, {:?}, {:?});",
        target,
        internalformat,
        width,
        height
      );
    }
    let out = call_atomic_ptr_4arg(
      "glRenderbufferStorage",
      &glRenderbufferStorage_p,
      target,
      internalformat,
      width,
      height,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glRenderbufferStorage");
    }
    out
  }
  static glRenderbufferStorage_p: APcv = ap_null();
  /// Tries to load [`glRenderbufferStorage`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glRenderbufferStorage_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glRenderbufferStorage\0",
      &glRenderbufferStorage_p,
    )
  }
  /// Checks if the pointer for [`glRenderbufferStorage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glRenderbufferStorage_is_loaded() -> bool {
    !glRenderbufferStorage_p.load(RELAX).is_null()
  }

  /// [glRenderbufferStorageMultisample](http://docs.gl/gl3/glRenderbufferStorageMultisample)(target, samples, internalformat, width, height)
  /// * `target` group: RenderbufferTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glRenderbufferStorageMultisample(
    target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glRenderbufferStorageMultisample({:#X}, {:?}, {:#X}, {:?}, {:?});", target, samples, internalformat, width, height);
    }
    let out = call_atomic_ptr_5arg(
      "glRenderbufferStorageMultisample",
      &glRenderbufferStorageMultisample_p,
      target,
      samples,
      internalformat,
      width,
      height,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glRenderbufferStorageMultisample");
    }
    out
  }
  static glRenderbufferStorageMultisample_p: APcv = ap_null();
  /// Tries to load [`glRenderbufferStorageMultisample`], returns if a non-null
  /// pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glRenderbufferStorageMultisample_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glRenderbufferStorageMultisample\0",
      &glRenderbufferStorageMultisample_p,
    )
  }
  /// Checks if the pointer for [`glRenderbufferStorageMultisample`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glRenderbufferStorageMultisample_is_loaded() -> bool {
    !glRenderbufferStorageMultisample_p.load(RELAX).is_null()
  }

  /// [glSampleCoverage](http://docs.gl/gl3/glSampleCoverage)(value, invert)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSampleCoverage(value: GLfloat, invert: GLboolean) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glSampleCoverage({:?}, {:?});", value, invert);
    }
    let out = call_atomic_ptr_2arg(
      "glSampleCoverage",
      &glSampleCoverage_p,
      value,
      invert,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glSampleCoverage");
    }
    out
  }
  static glSampleCoverage_p: APcv = ap_null();
  /// Tries to load [`glSampleCoverage`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glSampleCoverage_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glSampleCoverage\0",
      &glSampleCoverage_p,
    )
  }
  /// Checks if the pointer for [`glSampleCoverage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSampleCoverage_is_loaded() -> bool {
    !glSampleCoverage_p.load(RELAX).is_null()
  }

  /// [glSampleMaski](http://docs.gl/gl3/glSampleMask)(maskNumber, mask)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSampleMaski(maskNumber: GLuint, mask: GLbitfield) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glSampleMaski({:?}, {:?});", maskNumber, mask);
    }
    let out =
      call_atomic_ptr_2arg("glSampleMaski", &glSampleMaski_p, maskNumber, mask);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glSampleMaski");
    }
    out
  }
  static glSampleMaski_p: APcv = ap_null();
  /// Tries to load [`glSampleMaski`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glSampleMaski_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glSampleMaski\0",
      &glSampleMaski_p,
    )
  }
  /// Checks if the pointer for [`glSampleMaski`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSampleMaski_is_loaded() -> bool {
    !glSampleMaski_p.load(RELAX).is_null()
  }

  /// [glSamplerParameterIiv](http://docs.gl/gl3/glSamplerParameter)(sampler, pname, param)
  /// * `pname` group: SamplerParameterI
  /// * `param` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSamplerParameterIiv(
    sampler: GLuint, pname: GLenum, param: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSamplerParameterIiv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        param
      );
    }
    let out = call_atomic_ptr_3arg(
      "glSamplerParameterIiv",
      &glSamplerParameterIiv_p,
      sampler,
      pname,
      param,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glSamplerParameterIiv");
    }
    out
  }
  static glSamplerParameterIiv_p: APcv = ap_null();
  /// Tries to load [`glSamplerParameterIiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glSamplerParameterIiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glSamplerParameterIiv\0",
      &glSamplerParameterIiv_p,
    )
  }
  /// Checks if the pointer for [`glSamplerParameterIiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSamplerParameterIiv_is_loaded() -> bool {
    !glSamplerParameterIiv_p.load(RELAX).is_null()
  }

  /// [glSamplerParameterIuiv](http://docs.gl/gl3/glSamplerParameter)(sampler, pname, param)
  /// * `pname` group: SamplerParameterI
  /// * `param` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSamplerParameterIuiv(
    sampler: GLuint, pname: GLenum, param: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSamplerParameterIuiv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        param
      );
    }
    let out = call_atomic_ptr_3arg(
      "glSamplerParameterIuiv",
      &glSamplerParameterIuiv_p,
      sampler,
      pname,
      param,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glSamplerParameterIuiv");
    }
    out
  }
  static glSamplerParameterIuiv_p: APcv = ap_null();
  /// Tries to load [`glSamplerParameterIuiv`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glSamplerParameterIuiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glSamplerParameterIuiv\0",
      &glSamplerParameterIuiv_p,
    )
  }
  /// Checks if the pointer for [`glSamplerParameterIuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSamplerParameterIuiv_is_loaded() -> bool {
    !glSamplerParameterIuiv_p.load(RELAX).is_null()
  }

  /// [glSamplerParameterf](http://docs.gl/gl3/glSamplerParameter)(sampler, pname, param)
  /// * `pname` group: SamplerParameterF
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSamplerParameterf(
    sampler: GLuint, pname: GLenum, param: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSamplerParameterf({:?}, {:#X}, {:?});",
        sampler,
        pname,
        param
      );
    }
    let out = call_atomic_ptr_3arg(
      "glSamplerParameterf",
      &glSamplerParameterf_p,
      sampler,
      pname,
      param,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glSamplerParameterf");
    }
    out
  }
  static glSamplerParameterf_p: APcv = ap_null();
  /// Tries to load [`glSamplerParameterf`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glSamplerParameterf_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glSamplerParameterf\0",
      &glSamplerParameterf_p,
    )
  }
  /// Checks if the pointer for [`glSamplerParameterf`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSamplerParameterf_is_loaded() -> bool {
    !glSamplerParameterf_p.load(RELAX).is_null()
  }

  /// [glSamplerParameterfv](http://docs.gl/gl3/glSamplerParameter)(sampler, pname, param)
  /// * `pname` group: SamplerParameterF
  /// * `param` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSamplerParameterfv(
    sampler: GLuint, pname: GLenum, param: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSamplerParameterfv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        param
      );
    }
    let out = call_atomic_ptr_3arg(
      "glSamplerParameterfv",
      &glSamplerParameterfv_p,
      sampler,
      pname,
      param,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glSamplerParameterfv");
    }
    out
  }
  static glSamplerParameterfv_p: APcv = ap_null();
  /// Tries to load [`glSamplerParameterfv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glSamplerParameterfv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glSamplerParameterfv\0",
      &glSamplerParameterfv_p,
    )
  }
  /// Checks if the pointer for [`glSamplerParameterfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSamplerParameterfv_is_loaded() -> bool {
    !glSamplerParameterfv_p.load(RELAX).is_null()
  }

  /// [glSamplerParameteri](http://docs.gl/gl3/glSamplerParameter)(sampler, pname, param)
  /// * `pname` group: SamplerParameterI
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSamplerParameteri(
    sampler: GLuint, pname: GLenum, param: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSamplerParameteri({:?}, {:#X}, {:?});",
        sampler,
        pname,
        param
      );
    }
    let out = call_atomic_ptr_3arg(
      "glSamplerParameteri",
      &glSamplerParameteri_p,
      sampler,
      pname,
      param,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glSamplerParameteri");
    }
    out
  }
  static glSamplerParameteri_p: APcv = ap_null();
  /// Tries to load [`glSamplerParameteri`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glSamplerParameteri_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glSamplerParameteri\0",
      &glSamplerParameteri_p,
    )
  }
  /// Checks if the pointer for [`glSamplerParameteri`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSamplerParameteri_is_loaded() -> bool {
    !glSamplerParameteri_p.load(RELAX).is_null()
  }

  /// [glSamplerParameteriv](http://docs.gl/gl3/glSamplerParameter)(sampler, pname, param)
  /// * `pname` group: SamplerParameterI
  /// * `param` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSamplerParameteriv(
    sampler: GLuint, pname: GLenum, param: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSamplerParameteriv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        param
      );
    }
    let out = call_atomic_ptr_3arg(
      "glSamplerParameteriv",
      &glSamplerParameteriv_p,
      sampler,
      pname,
      param,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glSamplerParameteriv");
    }
    out
  }
  static glSamplerParameteriv_p: APcv = ap_null();
  /// Tries to load [`glSamplerParameteriv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glSamplerParameteriv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glSamplerParameteriv\0",
      &glSamplerParameteriv_p,
    )
  }
  /// Checks if the pointer for [`glSamplerParameteriv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSamplerParameteriv_is_loaded() -> bool {
    !glSamplerParameteriv_p.load(RELAX).is_null()
  }

  /// [glScissor](http://docs.gl/gl3/glScissor)(x, y, width, height)
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glScissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glScissor({:?}, {:?}, {:?}, {:?});", x, y, width, height);
    }
    let out =
      call_atomic_ptr_4arg("glScissor", &glScissor_p, x, y, width, height);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glScissor");
    }
    out
  }
  static glScissor_p: APcv = ap_null();
  /// Tries to load [`glScissor`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glScissor_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glScissor\0", &glScissor_p)
  }
  /// Checks if the pointer for [`glScissor`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glScissor_is_loaded() -> bool {
    !glScissor_p.load(RELAX).is_null()
  }

  /// [glShaderSource](http://docs.gl/gl3/glShaderSource)(shader, count, string, length)
  /// * `string` len: count
  /// * `length` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glShaderSource(
    shader: GLuint, count: GLsizei, string: *const *const GLchar,
    length: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glShaderSource({:?}, {:?}, {:p}, {:p});",
        shader,
        count,
        string,
        length
      );
    }
    let out = call_atomic_ptr_4arg(
      "glShaderSource",
      &glShaderSource_p,
      shader,
      count,
      string,
      length,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glShaderSource");
    }
    out
  }
  static glShaderSource_p: APcv = ap_null();
  /// Tries to load [`glShaderSource`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glShaderSource_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glShaderSource\0",
      &glShaderSource_p,
    )
  }
  /// Checks if the pointer for [`glShaderSource`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glShaderSource_is_loaded() -> bool {
    !glShaderSource_p.load(RELAX).is_null()
  }

  /// [glStencilFunc](http://docs.gl/gl3/glStencilFunc)(func, ref_, mask)
  /// * `func` group: StencilFunction
  /// * `ref_` group: StencilValue
  /// * `mask` group: MaskedStencilValue
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glStencilFunc(func: GLenum, ref_: GLint, mask: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glStencilFunc({:#X}, {:?}, {:?});", func, ref_, mask);
    }
    let out =
      call_atomic_ptr_3arg("glStencilFunc", &glStencilFunc_p, func, ref_, mask);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glStencilFunc");
    }
    out
  }
  static glStencilFunc_p: APcv = ap_null();
  /// Tries to load [`glStencilFunc`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glStencilFunc_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glStencilFunc\0",
      &glStencilFunc_p,
    )
  }
  /// Checks if the pointer for [`glStencilFunc`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glStencilFunc_is_loaded() -> bool {
    !glStencilFunc_p.load(RELAX).is_null()
  }

  /// [glStencilFuncSeparate](http://docs.gl/gl3/glStencilFuncSeparate)(face, func, ref_, mask)
  /// * `face` group: StencilFaceDirection
  /// * `func` group: StencilFunction
  /// * `ref_` group: StencilValue
  /// * `mask` group: MaskedStencilValue
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glStencilFuncSeparate(
    face: GLenum, func: GLenum, ref_: GLint, mask: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glStencilFuncSeparate({:#X}, {:#X}, {:?}, {:?});",
        face,
        func,
        ref_,
        mask
      );
    }
    let out = call_atomic_ptr_4arg(
      "glStencilFuncSeparate",
      &glStencilFuncSeparate_p,
      face,
      func,
      ref_,
      mask,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glStencilFuncSeparate");
    }
    out
  }
  static glStencilFuncSeparate_p: APcv = ap_null();
  /// Tries to load [`glStencilFuncSeparate`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glStencilFuncSeparate_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glStencilFuncSeparate\0",
      &glStencilFuncSeparate_p,
    )
  }
  /// Checks if the pointer for [`glStencilFuncSeparate`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glStencilFuncSeparate_is_loaded() -> bool {
    !glStencilFuncSeparate_p.load(RELAX).is_null()
  }

  /// [glStencilMask](http://docs.gl/gl3/glStencilMask)(mask)
  /// * `mask` group: MaskedStencilValue
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glStencilMask(mask: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glStencilMask({:?});", mask);
    }
    let out = call_atomic_ptr_1arg("glStencilMask", &glStencilMask_p, mask);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glStencilMask");
    }
    out
  }
  static glStencilMask_p: APcv = ap_null();
  /// Tries to load [`glStencilMask`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glStencilMask_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glStencilMask\0",
      &glStencilMask_p,
    )
  }
  /// Checks if the pointer for [`glStencilMask`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glStencilMask_is_loaded() -> bool {
    !glStencilMask_p.load(RELAX).is_null()
  }

  /// [glStencilMaskSeparate](http://docs.gl/gl3/glStencilMaskSeparate)(face, mask)
  /// * `face` group: StencilFaceDirection
  /// * `mask` group: MaskedStencilValue
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glStencilMaskSeparate(face: GLenum, mask: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glStencilMaskSeparate({:#X}, {:?});", face, mask);
    }
    let out = call_atomic_ptr_2arg(
      "glStencilMaskSeparate",
      &glStencilMaskSeparate_p,
      face,
      mask,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glStencilMaskSeparate");
    }
    out
  }
  static glStencilMaskSeparate_p: APcv = ap_null();
  /// Tries to load [`glStencilMaskSeparate`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glStencilMaskSeparate_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glStencilMaskSeparate\0",
      &glStencilMaskSeparate_p,
    )
  }
  /// Checks if the pointer for [`glStencilMaskSeparate`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glStencilMaskSeparate_is_loaded() -> bool {
    !glStencilMaskSeparate_p.load(RELAX).is_null()
  }

  /// [glStencilOp](http://docs.gl/gl3/glStencilOp)(fail, zfail, zpass)
  /// * `fail` group: StencilOp
  /// * `zfail` group: StencilOp
  /// * `zpass` group: StencilOp
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glStencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glStencilOp({:#X}, {:#X}, {:#X});", fail, zfail, zpass);
    }
    let out =
      call_atomic_ptr_3arg("glStencilOp", &glStencilOp_p, fail, zfail, zpass);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glStencilOp");
    }
    out
  }
  static glStencilOp_p: APcv = ap_null();
  /// Tries to load [`glStencilOp`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glStencilOp_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glStencilOp\0", &glStencilOp_p)
  }
  /// Checks if the pointer for [`glStencilOp`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glStencilOp_is_loaded() -> bool {
    !glStencilOp_p.load(RELAX).is_null()
  }

  /// [glStencilOpSeparate](http://docs.gl/gl3/glStencilOpSeparate)(face, sfail, dpfail, dppass)
  /// * `face` group: StencilFaceDirection
  /// * `sfail` group: StencilOp
  /// * `dpfail` group: StencilOp
  /// * `dppass` group: StencilOp
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glStencilOpSeparate(
    face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glStencilOpSeparate({:#X}, {:#X}, {:#X}, {:#X});",
        face,
        sfail,
        dpfail,
        dppass
      );
    }
    let out = call_atomic_ptr_4arg(
      "glStencilOpSeparate",
      &glStencilOpSeparate_p,
      face,
      sfail,
      dpfail,
      dppass,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glStencilOpSeparate");
    }
    out
  }
  static glStencilOpSeparate_p: APcv = ap_null();
  /// Tries to load [`glStencilOpSeparate`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glStencilOpSeparate_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glStencilOpSeparate\0",
      &glStencilOpSeparate_p,
    )
  }
  /// Checks if the pointer for [`glStencilOpSeparate`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glStencilOpSeparate_is_loaded() -> bool {
    !glStencilOpSeparate_p.load(RELAX).is_null()
  }

  /// [glTexBuffer](http://docs.gl/gl3/glTexBuffer)(target, internalformat, buffer)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexBuffer(
    target: GLenum, internalformat: GLenum, buffer: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexBuffer({:#X}, {:#X}, {:?});",
        target,
        internalformat,
        buffer
      );
    }
    let out = call_atomic_ptr_3arg(
      "glTexBuffer",
      &glTexBuffer_p,
      target,
      internalformat,
      buffer,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexBuffer");
    }
    out
  }
  static glTexBuffer_p: APcv = ap_null();
  /// Tries to load [`glTexBuffer`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glTexBuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glTexBuffer\0", &glTexBuffer_p)
  }
  /// Checks if the pointer for [`glTexBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexBuffer_is_loaded() -> bool {
    !glTexBuffer_p.load(RELAX).is_null()
  }

  /// [glTexImage1D](http://docs.gl/gl3/glTexImage1D)(target, level, internalformat, width, border, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `border` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexImage1D(
    target: GLenum, level: GLint, internalformat: GLint, width: GLsizei,
    border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexImage1D({:#X}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, border, format, type_, pixels);
    }
    let out = call_atomic_ptr_8arg(
      "glTexImage1D",
      &glTexImage1D_p,
      target,
      level,
      internalformat,
      width,
      border,
      format,
      type_,
      pixels,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexImage1D");
    }
    out
  }
  static glTexImage1D_p: APcv = ap_null();
  /// Tries to load [`glTexImage1D`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glTexImage1D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexImage1D\0",
      &glTexImage1D_p,
    )
  }
  /// Checks if the pointer for [`glTexImage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexImage1D_is_loaded() -> bool {
    !glTexImage1D_p.load(RELAX).is_null()
  }

  /// [glTexImage2D](http://docs.gl/gl3/glTexImage2D)(target, level, internalformat, width, height, border, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `border` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width,height)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexImage2D(
    target: GLenum, level: GLint, internalformat: GLint, width: GLsizei,
    height: GLsizei, border: GLint, format: GLenum, type_: GLenum,
    pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, height, border, format, type_, pixels);
    }
    let out = call_atomic_ptr_9arg(
      "glTexImage2D",
      &glTexImage2D_p,
      target,
      level,
      internalformat,
      width,
      height,
      border,
      format,
      type_,
      pixels,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexImage2D");
    }
    out
  }
  static glTexImage2D_p: APcv = ap_null();
  /// Tries to load [`glTexImage2D`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glTexImage2D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexImage2D\0",
      &glTexImage2D_p,
    )
  }
  /// Checks if the pointer for [`glTexImage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexImage2D_is_loaded() -> bool {
    !glTexImage2D_p.load(RELAX).is_null()
  }

  /// [glTexImage2DMultisample](http://docs.gl/gl3/glTexImage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexImage2DMultisample(
    target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei,
    height: GLsizei, fixedsamplelocations: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexImage2DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, fixedsamplelocations);
    }
    let out = call_atomic_ptr_6arg(
      "glTexImage2DMultisample",
      &glTexImage2DMultisample_p,
      target,
      samples,
      internalformat,
      width,
      height,
      fixedsamplelocations,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexImage2DMultisample");
    }
    out
  }
  static glTexImage2DMultisample_p: APcv = ap_null();
  /// Tries to load [`glTexImage2DMultisample`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glTexImage2DMultisample_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexImage2DMultisample\0",
      &glTexImage2DMultisample_p,
    )
  }
  /// Checks if the pointer for [`glTexImage2DMultisample`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexImage2DMultisample_is_loaded() -> bool {
    !glTexImage2DMultisample_p.load(RELAX).is_null()
  }

  /// [glTexImage3D](http://docs.gl/gl3/glTexImage3D)(target, level, internalformat, width, height, depth, border, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `border` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width,height,depth)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexImage3D(
    target: GLenum, level: GLint, internalformat: GLint, width: GLsizei,
    height: GLsizei, depth: GLsizei, border: GLint, format: GLenum,
    type_: GLenum, pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, height, depth, border, format, type_, pixels);
    }
    let out = call_atomic_ptr_10arg(
      "glTexImage3D",
      &glTexImage3D_p,
      target,
      level,
      internalformat,
      width,
      height,
      depth,
      border,
      format,
      type_,
      pixels,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexImage3D");
    }
    out
  }
  static glTexImage3D_p: APcv = ap_null();
  /// Tries to load [`glTexImage3D`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glTexImage3D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexImage3D\0",
      &glTexImage3D_p,
    )
  }
  /// Checks if the pointer for [`glTexImage3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexImage3D_is_loaded() -> bool {
    !glTexImage3D_p.load(RELAX).is_null()
  }

  /// [glTexImage3DMultisample](http://docs.gl/gl3/glTexImage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexImage3DMultisample(
    target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei,
    height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexImage3DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, depth, fixedsamplelocations);
    }
    let out = call_atomic_ptr_7arg(
      "glTexImage3DMultisample",
      &glTexImage3DMultisample_p,
      target,
      samples,
      internalformat,
      width,
      height,
      depth,
      fixedsamplelocations,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexImage3DMultisample");
    }
    out
  }
  static glTexImage3DMultisample_p: APcv = ap_null();
  /// Tries to load [`glTexImage3DMultisample`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glTexImage3DMultisample_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexImage3DMultisample\0",
      &glTexImage3DMultisample_p,
    )
  }
  /// Checks if the pointer for [`glTexImage3DMultisample`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexImage3DMultisample_is_loaded() -> bool {
    !glTexImage3DMultisample_p.load(RELAX).is_null()
  }

  /// [glTexParameterIiv](http://docs.gl/gl3/glTexParameter)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: TextureParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexParameterIiv(
    target: GLenum, pname: GLenum, params: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexParameterIiv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glTexParameterIiv",
      &glTexParameterIiv_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexParameterIiv");
    }
    out
  }
  static glTexParameterIiv_p: APcv = ap_null();
  /// Tries to load [`glTexParameterIiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glTexParameterIiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexParameterIiv\0",
      &glTexParameterIiv_p,
    )
  }
  /// Checks if the pointer for [`glTexParameterIiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexParameterIiv_is_loaded() -> bool {
    !glTexParameterIiv_p.load(RELAX).is_null()
  }

  /// [glTexParameterIuiv](http://docs.gl/gl3/glTexParameter)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: TextureParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexParameterIuiv(
    target: GLenum, pname: GLenum, params: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexParameterIuiv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glTexParameterIuiv",
      &glTexParameterIuiv_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexParameterIuiv");
    }
    out
  }
  static glTexParameterIuiv_p: APcv = ap_null();
  /// Tries to load [`glTexParameterIuiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glTexParameterIuiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexParameterIuiv\0",
      &glTexParameterIuiv_p,
    )
  }
  /// Checks if the pointer for [`glTexParameterIuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexParameterIuiv_is_loaded() -> bool {
    !glTexParameterIuiv_p.load(RELAX).is_null()
  }

  /// [glTexParameterf](http://docs.gl/gl3/glTexParameter)(target, pname, param)
  /// * `target` group: TextureTarget
  /// * `pname` group: TextureParameterName
  /// * `param` group: CheckedFloat32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexParameterf(target: GLenum, pname: GLenum, param: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexParameterf({:#X}, {:#X}, {:?});",
        target,
        pname,
        param
      );
    }
    let out = call_atomic_ptr_3arg(
      "glTexParameterf",
      &glTexParameterf_p,
      target,
      pname,
      param,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexParameterf");
    }
    out
  }
  static glTexParameterf_p: APcv = ap_null();
  /// Tries to load [`glTexParameterf`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glTexParameterf_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexParameterf\0",
      &glTexParameterf_p,
    )
  }
  /// Checks if the pointer for [`glTexParameterf`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexParameterf_is_loaded() -> bool {
    !glTexParameterf_p.load(RELAX).is_null()
  }

  /// [glTexParameterfv](http://docs.gl/gl3/glTexParameter)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: TextureParameterName
  /// * `params` group: CheckedFloat32
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexParameterfv(
    target: GLenum, pname: GLenum, params: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexParameterfv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glTexParameterfv",
      &glTexParameterfv_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexParameterfv");
    }
    out
  }
  static glTexParameterfv_p: APcv = ap_null();
  /// Tries to load [`glTexParameterfv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glTexParameterfv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexParameterfv\0",
      &glTexParameterfv_p,
    )
  }
  /// Checks if the pointer for [`glTexParameterfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexParameterfv_is_loaded() -> bool {
    !glTexParameterfv_p.load(RELAX).is_null()
  }

  /// [glTexParameteri](http://docs.gl/gl3/glTexParameter)(target, pname, param)
  /// * `target` group: TextureTarget
  /// * `pname` group: TextureParameterName
  /// * `param` group: CheckedInt32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexParameteri(target: GLenum, pname: GLenum, param: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexParameteri({:#X}, {:#X}, {:?});",
        target,
        pname,
        param
      );
    }
    let out = call_atomic_ptr_3arg(
      "glTexParameteri",
      &glTexParameteri_p,
      target,
      pname,
      param,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexParameteri");
    }
    out
  }
  static glTexParameteri_p: APcv = ap_null();
  /// Tries to load [`glTexParameteri`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glTexParameteri_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexParameteri\0",
      &glTexParameteri_p,
    )
  }
  /// Checks if the pointer for [`glTexParameteri`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexParameteri_is_loaded() -> bool {
    !glTexParameteri_p.load(RELAX).is_null()
  }

  /// [glTexParameteriv](http://docs.gl/gl3/glTexParameter)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: TextureParameterName
  /// * `params` group: CheckedInt32
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexParameteriv(
    target: GLenum, pname: GLenum, params: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexParameteriv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let out = call_atomic_ptr_3arg(
      "glTexParameteriv",
      &glTexParameteriv_p,
      target,
      pname,
      params,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexParameteriv");
    }
    out
  }
  static glTexParameteriv_p: APcv = ap_null();
  /// Tries to load [`glTexParameteriv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glTexParameteriv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexParameteriv\0",
      &glTexParameteriv_p,
    )
  }
  /// Checks if the pointer for [`glTexParameteriv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexParameteriv_is_loaded() -> bool {
    !glTexParameteriv_p.load(RELAX).is_null()
  }

  /// [glTexSubImage1D](http://docs.gl/gl3/glTexSubImage1D)(target, level, xoffset, width, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexSubImage1D(
    target: GLenum, level: GLint, xoffset: GLint, width: GLsizei,
    format: GLenum, type_: GLenum, pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
        target,
        level,
        xoffset,
        width,
        format,
        type_,
        pixels
      );
    }
    let out = call_atomic_ptr_7arg(
      "glTexSubImage1D",
      &glTexSubImage1D_p,
      target,
      level,
      xoffset,
      width,
      format,
      type_,
      pixels,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexSubImage1D");
    }
    out
  }
  static glTexSubImage1D_p: APcv = ap_null();
  /// Tries to load [`glTexSubImage1D`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glTexSubImage1D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexSubImage1D\0",
      &glTexSubImage1D_p,
    )
  }
  /// Checks if the pointer for [`glTexSubImage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexSubImage1D_is_loaded() -> bool {
    !glTexSubImage1D_p.load(RELAX).is_null()
  }

  /// [glTexSubImage2D](http://docs.gl/gl3/glTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `yoffset` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width,height)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexSubImage2D(
    target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,
    width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum,
    pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, xoffset, yoffset, width, height, format, type_, pixels);
    }
    let out = call_atomic_ptr_9arg(
      "glTexSubImage2D",
      &glTexSubImage2D_p,
      target,
      level,
      xoffset,
      yoffset,
      width,
      height,
      format,
      type_,
      pixels,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexSubImage2D");
    }
    out
  }
  static glTexSubImage2D_p: APcv = ap_null();
  /// Tries to load [`glTexSubImage2D`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glTexSubImage2D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexSubImage2D\0",
      &glTexSubImage2D_p,
    )
  }
  /// Checks if the pointer for [`glTexSubImage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexSubImage2D_is_loaded() -> bool {
    !glTexSubImage2D_p.load(RELAX).is_null()
  }

  /// [glTexSubImage3D](http://docs.gl/gl3/glTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `yoffset` group: CheckedInt32
  /// * `zoffset` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width,height,depth)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexSubImage3D(
    target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,
    zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei,
    format: GLenum, type_: GLenum, pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels);
    }
    let out = call_atomic_ptr_11arg(
      "glTexSubImage3D",
      &glTexSubImage3D_p,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      width,
      height,
      depth,
      format,
      type_,
      pixels,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTexSubImage3D");
    }
    out
  }
  static glTexSubImage3D_p: APcv = ap_null();
  /// Tries to load [`glTexSubImage3D`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glTexSubImage3D_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTexSubImage3D\0",
      &glTexSubImage3D_p,
    )
  }
  /// Checks if the pointer for [`glTexSubImage3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexSubImage3D_is_loaded() -> bool {
    !glTexSubImage3D_p.load(RELAX).is_null()
  }

  /// [glTransformFeedbackVaryings](http://docs.gl/gl3/glTransformFeedbackVaryings)(program, count, varyings, bufferMode)
  /// * `varyings` len: count
  /// * `bufferMode` group: TransformFeedbackBufferMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTransformFeedbackVaryings(
    program: GLuint, count: GLsizei, varyings: *const *const GLchar,
    bufferMode: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTransformFeedbackVaryings({:?}, {:?}, {:p}, {:#X});",
        program,
        count,
        varyings,
        bufferMode
      );
    }
    let out = call_atomic_ptr_4arg(
      "glTransformFeedbackVaryings",
      &glTransformFeedbackVaryings_p,
      program,
      count,
      varyings,
      bufferMode,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glTransformFeedbackVaryings");
    }
    out
  }
  static glTransformFeedbackVaryings_p: APcv = ap_null();
  /// Tries to load [`glTransformFeedbackVaryings`], returns if a non-null
  /// pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glTransformFeedbackVaryings_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glTransformFeedbackVaryings\0",
      &glTransformFeedbackVaryings_p,
    )
  }
  /// Checks if the pointer for [`glTransformFeedbackVaryings`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTransformFeedbackVaryings_is_loaded() -> bool {
    !glTransformFeedbackVaryings_p.load(RELAX).is_null()
  }

  /// [glUniform1f](http://docs.gl/gl3/glUniform)(location, v0)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1f(location: GLint, v0: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform1f({:?}, {:?});", location, v0);
    }
    let out = call_atomic_ptr_2arg("glUniform1f", &glUniform1f_p, location, v0);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform1f");
    }
    out
  }
  static glUniform1f_p: APcv = ap_null();
  /// Tries to load [`glUniform1f`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform1f_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1f\0", &glUniform1f_p)
  }
  /// Checks if the pointer for [`glUniform1f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1f_is_loaded() -> bool {
    !glUniform1f_p.load(RELAX).is_null()
  }

  /// [glUniform1fv](http://docs.gl/gl3/glUniform)(location, count, value)
  /// * `value` len: count*1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1fv(
    location: GLint, count: GLsizei, value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform1fv({:?}, {:?}, {:p});", location, count, value);
    }
    let out = call_atomic_ptr_3arg(
      "glUniform1fv",
      &glUniform1fv_p,
      location,
      count,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform1fv");
    }
    out
  }
  static glUniform1fv_p: APcv = ap_null();
  /// Tries to load [`glUniform1fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform1fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform1fv\0",
      &glUniform1fv_p,
    )
  }
  /// Checks if the pointer for [`glUniform1fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1fv_is_loaded() -> bool {
    !glUniform1fv_p.load(RELAX).is_null()
  }

  /// [glUniform1i](http://docs.gl/gl3/glUniform)(location, v0)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1i(location: GLint, v0: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform1i({:?}, {:?});", location, v0);
    }
    let out = call_atomic_ptr_2arg("glUniform1i", &glUniform1i_p, location, v0);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform1i");
    }
    out
  }
  static glUniform1i_p: APcv = ap_null();
  /// Tries to load [`glUniform1i`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform1i_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1i\0", &glUniform1i_p)
  }
  /// Checks if the pointer for [`glUniform1i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1i_is_loaded() -> bool {
    !glUniform1i_p.load(RELAX).is_null()
  }

  /// [glUniform1iv](http://docs.gl/gl3/glUniform)(location, count, value)
  /// * `value` len: count*1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1iv(
    location: GLint, count: GLsizei, value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform1iv({:?}, {:?}, {:p});", location, count, value);
    }
    let out = call_atomic_ptr_3arg(
      "glUniform1iv",
      &glUniform1iv_p,
      location,
      count,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform1iv");
    }
    out
  }
  static glUniform1iv_p: APcv = ap_null();
  /// Tries to load [`glUniform1iv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform1iv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform1iv\0",
      &glUniform1iv_p,
    )
  }
  /// Checks if the pointer for [`glUniform1iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1iv_is_loaded() -> bool {
    !glUniform1iv_p.load(RELAX).is_null()
  }

  /// [glUniform1ui](http://docs.gl/gl3/glUniform)(location, v0)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1ui(location: GLint, v0: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform1ui({:?}, {:?});", location, v0);
    }
    let out =
      call_atomic_ptr_2arg("glUniform1ui", &glUniform1ui_p, location, v0);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform1ui");
    }
    out
  }
  static glUniform1ui_p: APcv = ap_null();
  /// Tries to load [`glUniform1ui`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform1ui_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform1ui\0",
      &glUniform1ui_p,
    )
  }
  /// Checks if the pointer for [`glUniform1ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1ui_is_loaded() -> bool {
    !glUniform1ui_p.load(RELAX).is_null()
  }

  /// [glUniform1uiv](http://docs.gl/gl3/glUniform)(location, count, value)
  /// * `value` len: count*1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1uiv(
    location: GLint, count: GLsizei, value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform1uiv({:?}, {:?}, {:p});",
        location,
        count,
        value
      );
    }
    let out = call_atomic_ptr_3arg(
      "glUniform1uiv",
      &glUniform1uiv_p,
      location,
      count,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform1uiv");
    }
    out
  }
  static glUniform1uiv_p: APcv = ap_null();
  /// Tries to load [`glUniform1uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform1uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform1uiv\0",
      &glUniform1uiv_p,
    )
  }
  /// Checks if the pointer for [`glUniform1uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1uiv_is_loaded() -> bool {
    !glUniform1uiv_p.load(RELAX).is_null()
  }

  /// [glUniform2f](http://docs.gl/gl3/glUniform)(location, v0, v1)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2f(location: GLint, v0: GLfloat, v1: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform2f({:?}, {:?}, {:?});", location, v0, v1);
    }
    let out =
      call_atomic_ptr_3arg("glUniform2f", &glUniform2f_p, location, v0, v1);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform2f");
    }
    out
  }
  static glUniform2f_p: APcv = ap_null();
  /// Tries to load [`glUniform2f`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform2f_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2f\0", &glUniform2f_p)
  }
  /// Checks if the pointer for [`glUniform2f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2f_is_loaded() -> bool {
    !glUniform2f_p.load(RELAX).is_null()
  }

  /// [glUniform2fv](http://docs.gl/gl3/glUniform)(location, count, value)
  /// * `value` len: count*2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2fv(
    location: GLint, count: GLsizei, value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform2fv({:?}, {:?}, {:p});", location, count, value);
    }
    let out = call_atomic_ptr_3arg(
      "glUniform2fv",
      &glUniform2fv_p,
      location,
      count,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform2fv");
    }
    out
  }
  static glUniform2fv_p: APcv = ap_null();
  /// Tries to load [`glUniform2fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform2fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform2fv\0",
      &glUniform2fv_p,
    )
  }
  /// Checks if the pointer for [`glUniform2fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2fv_is_loaded() -> bool {
    !glUniform2fv_p.load(RELAX).is_null()
  }

  /// [glUniform2i](http://docs.gl/gl3/glUniform)(location, v0, v1)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2i(location: GLint, v0: GLint, v1: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform2i({:?}, {:?}, {:?});", location, v0, v1);
    }
    let out =
      call_atomic_ptr_3arg("glUniform2i", &glUniform2i_p, location, v0, v1);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform2i");
    }
    out
  }
  static glUniform2i_p: APcv = ap_null();
  /// Tries to load [`glUniform2i`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform2i_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2i\0", &glUniform2i_p)
  }
  /// Checks if the pointer for [`glUniform2i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2i_is_loaded() -> bool {
    !glUniform2i_p.load(RELAX).is_null()
  }

  /// [glUniform2iv](http://docs.gl/gl3/glUniform)(location, count, value)
  /// * `value` len: count*2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2iv(
    location: GLint, count: GLsizei, value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform2iv({:?}, {:?}, {:p});", location, count, value);
    }
    let out = call_atomic_ptr_3arg(
      "glUniform2iv",
      &glUniform2iv_p,
      location,
      count,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform2iv");
    }
    out
  }
  static glUniform2iv_p: APcv = ap_null();
  /// Tries to load [`glUniform2iv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform2iv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform2iv\0",
      &glUniform2iv_p,
    )
  }
  /// Checks if the pointer for [`glUniform2iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2iv_is_loaded() -> bool {
    !glUniform2iv_p.load(RELAX).is_null()
  }

  /// [glUniform2ui](http://docs.gl/gl3/glUniform)(location, v0, v1)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2ui(location: GLint, v0: GLuint, v1: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform2ui({:?}, {:?}, {:?});", location, v0, v1);
    }
    let out =
      call_atomic_ptr_3arg("glUniform2ui", &glUniform2ui_p, location, v0, v1);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform2ui");
    }
    out
  }
  static glUniform2ui_p: APcv = ap_null();
  /// Tries to load [`glUniform2ui`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform2ui_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform2ui\0",
      &glUniform2ui_p,
    )
  }
  /// Checks if the pointer for [`glUniform2ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2ui_is_loaded() -> bool {
    !glUniform2ui_p.load(RELAX).is_null()
  }

  /// [glUniform2uiv](http://docs.gl/gl3/glUniform)(location, count, value)
  /// * `value` len: count*2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2uiv(
    location: GLint, count: GLsizei, value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform2uiv({:?}, {:?}, {:p});",
        location,
        count,
        value
      );
    }
    let out = call_atomic_ptr_3arg(
      "glUniform2uiv",
      &glUniform2uiv_p,
      location,
      count,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform2uiv");
    }
    out
  }
  static glUniform2uiv_p: APcv = ap_null();
  /// Tries to load [`glUniform2uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform2uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform2uiv\0",
      &glUniform2uiv_p,
    )
  }
  /// Checks if the pointer for [`glUniform2uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2uiv_is_loaded() -> bool {
    !glUniform2uiv_p.load(RELAX).is_null()
  }

  /// [glUniform3f](http://docs.gl/gl3/glUniform)(location, v0, v1, v2)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3f(
    location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform3f({:?}, {:?}, {:?}, {:?});",
        location,
        v0,
        v1,
        v2
      );
    }
    let out =
      call_atomic_ptr_4arg("glUniform3f", &glUniform3f_p, location, v0, v1, v2);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform3f");
    }
    out
  }
  static glUniform3f_p: APcv = ap_null();
  /// Tries to load [`glUniform3f`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform3f_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3f\0", &glUniform3f_p)
  }
  /// Checks if the pointer for [`glUniform3f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3f_is_loaded() -> bool {
    !glUniform3f_p.load(RELAX).is_null()
  }

  /// [glUniform3fv](http://docs.gl/gl3/glUniform)(location, count, value)
  /// * `value` len: count*3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3fv(
    location: GLint, count: GLsizei, value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform3fv({:?}, {:?}, {:p});", location, count, value);
    }
    let out = call_atomic_ptr_3arg(
      "glUniform3fv",
      &glUniform3fv_p,
      location,
      count,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform3fv");
    }
    out
  }
  static glUniform3fv_p: APcv = ap_null();
  /// Tries to load [`glUniform3fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform3fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform3fv\0",
      &glUniform3fv_p,
    )
  }
  /// Checks if the pointer for [`glUniform3fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3fv_is_loaded() -> bool {
    !glUniform3fv_p.load(RELAX).is_null()
  }

  /// [glUniform3i](http://docs.gl/gl3/glUniform)(location, v0, v1, v2)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3i(location: GLint, v0: GLint, v1: GLint, v2: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform3i({:?}, {:?}, {:?}, {:?});",
        location,
        v0,
        v1,
        v2
      );
    }
    let out =
      call_atomic_ptr_4arg("glUniform3i", &glUniform3i_p, location, v0, v1, v2);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform3i");
    }
    out
  }
  static glUniform3i_p: APcv = ap_null();
  /// Tries to load [`glUniform3i`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform3i_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3i\0", &glUniform3i_p)
  }
  /// Checks if the pointer for [`glUniform3i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3i_is_loaded() -> bool {
    !glUniform3i_p.load(RELAX).is_null()
  }

  /// [glUniform3iv](http://docs.gl/gl3/glUniform)(location, count, value)
  /// * `value` len: count*3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3iv(
    location: GLint, count: GLsizei, value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform3iv({:?}, {:?}, {:p});", location, count, value);
    }
    let out = call_atomic_ptr_3arg(
      "glUniform3iv",
      &glUniform3iv_p,
      location,
      count,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform3iv");
    }
    out
  }
  static glUniform3iv_p: APcv = ap_null();
  /// Tries to load [`glUniform3iv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform3iv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform3iv\0",
      &glUniform3iv_p,
    )
  }
  /// Checks if the pointer for [`glUniform3iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3iv_is_loaded() -> bool {
    !glUniform3iv_p.load(RELAX).is_null()
  }

  /// [glUniform3ui](http://docs.gl/gl3/glUniform)(location, v0, v1, v2)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3ui(
    location: GLint, v0: GLuint, v1: GLuint, v2: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform3ui({:?}, {:?}, {:?}, {:?});",
        location,
        v0,
        v1,
        v2
      );
    }
    let out = call_atomic_ptr_4arg(
      "glUniform3ui",
      &glUniform3ui_p,
      location,
      v0,
      v1,
      v2,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform3ui");
    }
    out
  }
  static glUniform3ui_p: APcv = ap_null();
  /// Tries to load [`glUniform3ui`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform3ui_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform3ui\0",
      &glUniform3ui_p,
    )
  }
  /// Checks if the pointer for [`glUniform3ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3ui_is_loaded() -> bool {
    !glUniform3ui_p.load(RELAX).is_null()
  }

  /// [glUniform3uiv](http://docs.gl/gl3/glUniform)(location, count, value)
  /// * `value` len: count*3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3uiv(
    location: GLint, count: GLsizei, value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform3uiv({:?}, {:?}, {:p});",
        location,
        count,
        value
      );
    }
    let out = call_atomic_ptr_3arg(
      "glUniform3uiv",
      &glUniform3uiv_p,
      location,
      count,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform3uiv");
    }
    out
  }
  static glUniform3uiv_p: APcv = ap_null();
  /// Tries to load [`glUniform3uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform3uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform3uiv\0",
      &glUniform3uiv_p,
    )
  }
  /// Checks if the pointer for [`glUniform3uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3uiv_is_loaded() -> bool {
    !glUniform3uiv_p.load(RELAX).is_null()
  }

  /// [glUniform4f](http://docs.gl/gl3/glUniform)(location, v0, v1, v2, v3)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4f(
    location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform4f({:?}, {:?}, {:?}, {:?}, {:?});",
        location,
        v0,
        v1,
        v2,
        v3
      );
    }
    let out = call_atomic_ptr_5arg(
      "glUniform4f",
      &glUniform4f_p,
      location,
      v0,
      v1,
      v2,
      v3,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform4f");
    }
    out
  }
  static glUniform4f_p: APcv = ap_null();
  /// Tries to load [`glUniform4f`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform4f_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4f\0", &glUniform4f_p)
  }
  /// Checks if the pointer for [`glUniform4f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4f_is_loaded() -> bool {
    !glUniform4f_p.load(RELAX).is_null()
  }

  /// [glUniform4fv](http://docs.gl/gl3/glUniform)(location, count, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4fv(
    location: GLint, count: GLsizei, value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform4fv({:?}, {:?}, {:p});", location, count, value);
    }
    let out = call_atomic_ptr_3arg(
      "glUniform4fv",
      &glUniform4fv_p,
      location,
      count,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform4fv");
    }
    out
  }
  static glUniform4fv_p: APcv = ap_null();
  /// Tries to load [`glUniform4fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform4fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform4fv\0",
      &glUniform4fv_p,
    )
  }
  /// Checks if the pointer for [`glUniform4fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4fv_is_loaded() -> bool {
    !glUniform4fv_p.load(RELAX).is_null()
  }

  /// [glUniform4i](http://docs.gl/gl3/glUniform)(location, v0, v1, v2, v3)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4i(
    location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform4i({:?}, {:?}, {:?}, {:?}, {:?});",
        location,
        v0,
        v1,
        v2,
        v3
      );
    }
    let out = call_atomic_ptr_5arg(
      "glUniform4i",
      &glUniform4i_p,
      location,
      v0,
      v1,
      v2,
      v3,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform4i");
    }
    out
  }
  static glUniform4i_p: APcv = ap_null();
  /// Tries to load [`glUniform4i`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform4i_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4i\0", &glUniform4i_p)
  }
  /// Checks if the pointer for [`glUniform4i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4i_is_loaded() -> bool {
    !glUniform4i_p.load(RELAX).is_null()
  }

  /// [glUniform4iv](http://docs.gl/gl3/glUniform)(location, count, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4iv(
    location: GLint, count: GLsizei, value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform4iv({:?}, {:?}, {:p});", location, count, value);
    }
    let out = call_atomic_ptr_3arg(
      "glUniform4iv",
      &glUniform4iv_p,
      location,
      count,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform4iv");
    }
    out
  }
  static glUniform4iv_p: APcv = ap_null();
  /// Tries to load [`glUniform4iv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform4iv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform4iv\0",
      &glUniform4iv_p,
    )
  }
  /// Checks if the pointer for [`glUniform4iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4iv_is_loaded() -> bool {
    !glUniform4iv_p.load(RELAX).is_null()
  }

  /// [glUniform4ui](http://docs.gl/gl3/glUniform)(location, v0, v1, v2, v3)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4ui(
    location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform4ui({:?}, {:?}, {:?}, {:?}, {:?});",
        location,
        v0,
        v1,
        v2,
        v3
      );
    }
    let out = call_atomic_ptr_5arg(
      "glUniform4ui",
      &glUniform4ui_p,
      location,
      v0,
      v1,
      v2,
      v3,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform4ui");
    }
    out
  }
  static glUniform4ui_p: APcv = ap_null();
  /// Tries to load [`glUniform4ui`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform4ui_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform4ui\0",
      &glUniform4ui_p,
    )
  }
  /// Checks if the pointer for [`glUniform4ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4ui_is_loaded() -> bool {
    !glUniform4ui_p.load(RELAX).is_null()
  }

  /// [glUniform4uiv](http://docs.gl/gl3/glUniform)(location, count, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4uiv(
    location: GLint, count: GLsizei, value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform4uiv({:?}, {:?}, {:p});",
        location,
        count,
        value
      );
    }
    let out = call_atomic_ptr_3arg(
      "glUniform4uiv",
      &glUniform4uiv_p,
      location,
      count,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniform4uiv");
    }
    out
  }
  static glUniform4uiv_p: APcv = ap_null();
  /// Tries to load [`glUniform4uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniform4uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniform4uiv\0",
      &glUniform4uiv_p,
    )
  }
  /// Checks if the pointer for [`glUniform4uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4uiv_is_loaded() -> bool {
    !glUniform4uiv_p.load(RELAX).is_null()
  }

  /// [glUniformBlockBinding](http://docs.gl/gl3/glUniformBlockBinding)(program, uniformBlockIndex, uniformBlockBinding)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformBlockBinding(
    program: GLuint, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformBlockBinding({:?}, {:?}, {:?});",
        program,
        uniformBlockIndex,
        uniformBlockBinding
      );
    }
    let out = call_atomic_ptr_3arg(
      "glUniformBlockBinding",
      &glUniformBlockBinding_p,
      program,
      uniformBlockIndex,
      uniformBlockBinding,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniformBlockBinding");
    }
    out
  }
  static glUniformBlockBinding_p: APcv = ap_null();
  /// Tries to load [`glUniformBlockBinding`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniformBlockBinding_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniformBlockBinding\0",
      &glUniformBlockBinding_p,
    )
  }
  /// Checks if the pointer for [`glUniformBlockBinding`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformBlockBinding_is_loaded() -> bool {
    !glUniformBlockBinding_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix2fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix2fv(
    location: GLint, count: GLsizei, transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix2fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glUniformMatrix2fv",
      &glUniformMatrix2fv_p,
      location,
      count,
      transpose,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniformMatrix2fv");
    }
    out
  }
  static glUniformMatrix2fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix2fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniformMatrix2fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniformMatrix2fv\0",
      &glUniformMatrix2fv_p,
    )
  }
  /// Checks if the pointer for [`glUniformMatrix2fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix2fv_is_loaded() -> bool {
    !glUniformMatrix2fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix2x3fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
  /// * `value` len: count*6
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix2x3fv(
    location: GLint, count: GLsizei, transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix2x3fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glUniformMatrix2x3fv",
      &glUniformMatrix2x3fv_p,
      location,
      count,
      transpose,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniformMatrix2x3fv");
    }
    out
  }
  static glUniformMatrix2x3fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix2x3fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniformMatrix2x3fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniformMatrix2x3fv\0",
      &glUniformMatrix2x3fv_p,
    )
  }
  /// Checks if the pointer for [`glUniformMatrix2x3fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix2x3fv_is_loaded() -> bool {
    !glUniformMatrix2x3fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix2x4fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
  /// * `value` len: count*8
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix2x4fv(
    location: GLint, count: GLsizei, transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix2x4fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glUniformMatrix2x4fv",
      &glUniformMatrix2x4fv_p,
      location,
      count,
      transpose,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniformMatrix2x4fv");
    }
    out
  }
  static glUniformMatrix2x4fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix2x4fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniformMatrix2x4fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniformMatrix2x4fv\0",
      &glUniformMatrix2x4fv_p,
    )
  }
  /// Checks if the pointer for [`glUniformMatrix2x4fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix2x4fv_is_loaded() -> bool {
    !glUniformMatrix2x4fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix3fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
  /// * `value` len: count*9
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix3fv(
    location: GLint, count: GLsizei, transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix3fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glUniformMatrix3fv",
      &glUniformMatrix3fv_p,
      location,
      count,
      transpose,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniformMatrix3fv");
    }
    out
  }
  static glUniformMatrix3fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix3fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniformMatrix3fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniformMatrix3fv\0",
      &glUniformMatrix3fv_p,
    )
  }
  /// Checks if the pointer for [`glUniformMatrix3fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix3fv_is_loaded() -> bool {
    !glUniformMatrix3fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix3x2fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
  /// * `value` len: count*6
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix3x2fv(
    location: GLint, count: GLsizei, transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix3x2fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glUniformMatrix3x2fv",
      &glUniformMatrix3x2fv_p,
      location,
      count,
      transpose,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniformMatrix3x2fv");
    }
    out
  }
  static glUniformMatrix3x2fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix3x2fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniformMatrix3x2fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniformMatrix3x2fv\0",
      &glUniformMatrix3x2fv_p,
    )
  }
  /// Checks if the pointer for [`glUniformMatrix3x2fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix3x2fv_is_loaded() -> bool {
    !glUniformMatrix3x2fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix3x4fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
  /// * `value` len: count*12
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix3x4fv(
    location: GLint, count: GLsizei, transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix3x4fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glUniformMatrix3x4fv",
      &glUniformMatrix3x4fv_p,
      location,
      count,
      transpose,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniformMatrix3x4fv");
    }
    out
  }
  static glUniformMatrix3x4fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix3x4fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniformMatrix3x4fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniformMatrix3x4fv\0",
      &glUniformMatrix3x4fv_p,
    )
  }
  /// Checks if the pointer for [`glUniformMatrix3x4fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix3x4fv_is_loaded() -> bool {
    !glUniformMatrix3x4fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix4fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
  /// * `value` len: count*16
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix4fv(
    location: GLint, count: GLsizei, transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix4fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glUniformMatrix4fv",
      &glUniformMatrix4fv_p,
      location,
      count,
      transpose,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniformMatrix4fv");
    }
    out
  }
  static glUniformMatrix4fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix4fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniformMatrix4fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniformMatrix4fv\0",
      &glUniformMatrix4fv_p,
    )
  }
  /// Checks if the pointer for [`glUniformMatrix4fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix4fv_is_loaded() -> bool {
    !glUniformMatrix4fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix4x2fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
  /// * `value` len: count*8
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix4x2fv(
    location: GLint, count: GLsizei, transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix4x2fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glUniformMatrix4x2fv",
      &glUniformMatrix4x2fv_p,
      location,
      count,
      transpose,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniformMatrix4x2fv");
    }
    out
  }
  static glUniformMatrix4x2fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix4x2fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniformMatrix4x2fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniformMatrix4x2fv\0",
      &glUniformMatrix4x2fv_p,
    )
  }
  /// Checks if the pointer for [`glUniformMatrix4x2fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix4x2fv_is_loaded() -> bool {
    !glUniformMatrix4x2fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix4x3fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
  /// * `value` len: count*12
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix4x3fv(
    location: GLint, count: GLsizei, transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix4x3fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glUniformMatrix4x3fv",
      &glUniformMatrix4x3fv_p,
      location,
      count,
      transpose,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUniformMatrix4x3fv");
    }
    out
  }
  static glUniformMatrix4x3fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix4x3fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUniformMatrix4x3fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUniformMatrix4x3fv\0",
      &glUniformMatrix4x3fv_p,
    )
  }
  /// Checks if the pointer for [`glUniformMatrix4x3fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix4x3fv_is_loaded() -> bool {
    !glUniformMatrix4x3fv_p.load(RELAX).is_null()
  }

  /// [glUnmapBuffer](http://docs.gl/gl3/glUnmapBuffer)(target)
  /// * `target` group: BufferTargetARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUnmapBuffer(target: GLenum) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUnmapBuffer({:#X});", target);
    }
    let out = call_atomic_ptr_1arg("glUnmapBuffer", &glUnmapBuffer_p, target);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUnmapBuffer");
    }
    out
  }
  static glUnmapBuffer_p: APcv = ap_null();
  /// Tries to load [`glUnmapBuffer`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUnmapBuffer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUnmapBuffer\0",
      &glUnmapBuffer_p,
    )
  }
  /// Checks if the pointer for [`glUnmapBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUnmapBuffer_is_loaded() -> bool {
    !glUnmapBuffer_p.load(RELAX).is_null()
  }

  /// [glUseProgram](http://docs.gl/gl3/glUseProgram)(program)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUseProgram(program: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUseProgram({:?});", program);
    }
    let out = call_atomic_ptr_1arg("glUseProgram", &glUseProgram_p, program);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glUseProgram");
    }
    out
  }
  static glUseProgram_p: APcv = ap_null();
  /// Tries to load [`glUseProgram`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glUseProgram_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glUseProgram\0",
      &glUseProgram_p,
    )
  }
  /// Checks if the pointer for [`glUseProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUseProgram_is_loaded() -> bool {
    !glUseProgram_p.load(RELAX).is_null()
  }

  /// [glValidateProgram](http://docs.gl/gl3/glValidateProgram)(program)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glValidateProgram(program: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glValidateProgram({:?});", program);
    }
    let out =
      call_atomic_ptr_1arg("glValidateProgram", &glValidateProgram_p, program);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glValidateProgram");
    }
    out
  }
  static glValidateProgram_p: APcv = ap_null();
  /// Tries to load [`glValidateProgram`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glValidateProgram_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glValidateProgram\0",
      &glValidateProgram_p,
    )
  }
  /// Checks if the pointer for [`glValidateProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glValidateProgram_is_loaded() -> bool {
    !glValidateProgram_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib1d](http://docs.gl/gl3/glVertexAttrib1d)(index, x)
  /// * vector equivalent: [`glVertexAttrib1dv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib1d(index: GLuint, x: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib1d({:?}, {:?});", index, x);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib1d", &glVertexAttrib1d_p, index, x);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib1d");
    }
    out
  }
  static glVertexAttrib1d_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib1d`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib1d_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib1d\0",
      &glVertexAttrib1d_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib1d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib1d_is_loaded() -> bool {
    !glVertexAttrib1d_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib1dv](http://docs.gl/gl3/glVertexAttrib1dv)(index, v)
  /// * `v` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib1dv(index: GLuint, v: *const GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib1dv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib1dv", &glVertexAttrib1dv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib1dv");
    }
    out
  }
  static glVertexAttrib1dv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib1dv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib1dv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib1dv\0",
      &glVertexAttrib1dv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib1dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib1dv_is_loaded() -> bool {
    !glVertexAttrib1dv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib1f](http://docs.gl/gl3/glVertexAttrib)(index, x)
  /// * vector equivalent: [`glVertexAttrib1fv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib1f(index: GLuint, x: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib1f({:?}, {:?});", index, x);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib1f", &glVertexAttrib1f_p, index, x);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib1f");
    }
    out
  }
  static glVertexAttrib1f_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib1f`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib1f_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib1f\0",
      &glVertexAttrib1f_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib1f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib1f_is_loaded() -> bool {
    !glVertexAttrib1f_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib1fv](http://docs.gl/gl3/glVertexAttrib)(index, v)
  /// * `v` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib1fv(index: GLuint, v: *const GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib1fv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib1fv", &glVertexAttrib1fv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib1fv");
    }
    out
  }
  static glVertexAttrib1fv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib1fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib1fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib1fv\0",
      &glVertexAttrib1fv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib1fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib1fv_is_loaded() -> bool {
    !glVertexAttrib1fv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib1s](http://docs.gl/gl3/glVertexAttrib1s)(index, x)
  /// * vector equivalent: [`glVertexAttrib1sv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib1s(index: GLuint, x: GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib1s({:?}, {:?});", index, x);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib1s", &glVertexAttrib1s_p, index, x);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib1s");
    }
    out
  }
  static glVertexAttrib1s_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib1s`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib1s_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib1s\0",
      &glVertexAttrib1s_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib1s`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib1s_is_loaded() -> bool {
    !glVertexAttrib1s_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib1sv](http://docs.gl/gl3/glVertexAttrib1sv)(index, v)
  /// * `v` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib1sv(index: GLuint, v: *const GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib1sv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib1sv", &glVertexAttrib1sv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib1sv");
    }
    out
  }
  static glVertexAttrib1sv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib1sv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib1sv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib1sv\0",
      &glVertexAttrib1sv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib1sv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib1sv_is_loaded() -> bool {
    !glVertexAttrib1sv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib2d](http://docs.gl/gl3/glVertexAttrib2d)(index, x, y)
  /// * vector equivalent: [`glVertexAttrib2dv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib2d(index: GLuint, x: GLdouble, y: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib2d({:?}, {:?}, {:?});", index, x, y);
    }
    let out = call_atomic_ptr_3arg(
      "glVertexAttrib2d",
      &glVertexAttrib2d_p,
      index,
      x,
      y,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib2d");
    }
    out
  }
  static glVertexAttrib2d_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib2d`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib2d_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib2d\0",
      &glVertexAttrib2d_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib2d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib2d_is_loaded() -> bool {
    !glVertexAttrib2d_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib2dv](http://docs.gl/gl3/glVertexAttrib2dv)(index, v)
  /// * `v` len: 2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib2dv(index: GLuint, v: *const GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib2dv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib2dv", &glVertexAttrib2dv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib2dv");
    }
    out
  }
  static glVertexAttrib2dv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib2dv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib2dv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib2dv\0",
      &glVertexAttrib2dv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib2dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib2dv_is_loaded() -> bool {
    !glVertexAttrib2dv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib2f](http://docs.gl/gl3/glVertexAttrib)(index, x, y)
  /// * vector equivalent: [`glVertexAttrib2fv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib2f({:?}, {:?}, {:?});", index, x, y);
    }
    let out = call_atomic_ptr_3arg(
      "glVertexAttrib2f",
      &glVertexAttrib2f_p,
      index,
      x,
      y,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib2f");
    }
    out
  }
  static glVertexAttrib2f_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib2f`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib2f_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib2f\0",
      &glVertexAttrib2f_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib2f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib2f_is_loaded() -> bool {
    !glVertexAttrib2f_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib2fv](http://docs.gl/gl3/glVertexAttrib)(index, v)
  /// * `v` len: 2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib2fv(index: GLuint, v: *const GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib2fv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib2fv", &glVertexAttrib2fv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib2fv");
    }
    out
  }
  static glVertexAttrib2fv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib2fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib2fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib2fv\0",
      &glVertexAttrib2fv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib2fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib2fv_is_loaded() -> bool {
    !glVertexAttrib2fv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib2s](http://docs.gl/gl3/glVertexAttrib2s)(index, x, y)
  /// * vector equivalent: [`glVertexAttrib2sv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib2s(index: GLuint, x: GLshort, y: GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib2s({:?}, {:?}, {:?});", index, x, y);
    }
    let out = call_atomic_ptr_3arg(
      "glVertexAttrib2s",
      &glVertexAttrib2s_p,
      index,
      x,
      y,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib2s");
    }
    out
  }
  static glVertexAttrib2s_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib2s`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib2s_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib2s\0",
      &glVertexAttrib2s_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib2s`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib2s_is_loaded() -> bool {
    !glVertexAttrib2s_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib2sv](http://docs.gl/gl3/glVertexAttrib2sv)(index, v)
  /// * `v` len: 2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib2sv(index: GLuint, v: *const GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib2sv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib2sv", &glVertexAttrib2sv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib2sv");
    }
    out
  }
  static glVertexAttrib2sv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib2sv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib2sv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib2sv\0",
      &glVertexAttrib2sv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib2sv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib2sv_is_loaded() -> bool {
    !glVertexAttrib2sv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib3d](http://docs.gl/gl3/glVertexAttrib3d)(index, x, y, z)
  /// * vector equivalent: [`glVertexAttrib3dv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib3d(
    index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib3d({:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttrib3d",
      &glVertexAttrib3d_p,
      index,
      x,
      y,
      z,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib3d");
    }
    out
  }
  static glVertexAttrib3d_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib3d`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib3d_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib3d\0",
      &glVertexAttrib3d_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib3d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib3d_is_loaded() -> bool {
    !glVertexAttrib3d_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib3dv](http://docs.gl/gl3/glVertexAttrib3dv)(index, v)
  /// * `v` len: 3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib3dv(index: GLuint, v: *const GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib3dv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib3dv", &glVertexAttrib3dv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib3dv");
    }
    out
  }
  static glVertexAttrib3dv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib3dv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib3dv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib3dv\0",
      &glVertexAttrib3dv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib3dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib3dv_is_loaded() -> bool {
    !glVertexAttrib3dv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib3f](http://docs.gl/gl3/glVertexAttrib)(index, x, y, z)
  /// * vector equivalent: [`glVertexAttrib3fv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib3f(
    index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib3f({:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttrib3f",
      &glVertexAttrib3f_p,
      index,
      x,
      y,
      z,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib3f");
    }
    out
  }
  static glVertexAttrib3f_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib3f`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib3f_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib3f\0",
      &glVertexAttrib3f_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib3f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib3f_is_loaded() -> bool {
    !glVertexAttrib3f_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib3fv](http://docs.gl/gl3/glVertexAttrib)(index, v)
  /// * `v` len: 3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib3fv(index: GLuint, v: *const GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib3fv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib3fv", &glVertexAttrib3fv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib3fv");
    }
    out
  }
  static glVertexAttrib3fv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib3fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib3fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib3fv\0",
      &glVertexAttrib3fv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib3fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib3fv_is_loaded() -> bool {
    !glVertexAttrib3fv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib3s](http://docs.gl/gl3/glVertexAttrib3s)(index, x, y, z)
  /// * vector equivalent: [`glVertexAttrib3sv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib3s(
    index: GLuint, x: GLshort, y: GLshort, z: GLshort,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib3s({:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttrib3s",
      &glVertexAttrib3s_p,
      index,
      x,
      y,
      z,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib3s");
    }
    out
  }
  static glVertexAttrib3s_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib3s`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib3s_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib3s\0",
      &glVertexAttrib3s_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib3s`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib3s_is_loaded() -> bool {
    !glVertexAttrib3s_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib3sv](http://docs.gl/gl3/glVertexAttrib3sv)(index, v)
  /// * `v` len: 3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib3sv(index: GLuint, v: *const GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib3sv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib3sv", &glVertexAttrib3sv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib3sv");
    }
    out
  }
  static glVertexAttrib3sv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib3sv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib3sv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib3sv\0",
      &glVertexAttrib3sv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib3sv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib3sv_is_loaded() -> bool {
    !glVertexAttrib3sv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Nbv](http://docs.gl/gl3/glVertexAttrib4Nbv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Nbv(index: GLuint, v: *const GLbyte) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4Nbv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttrib4Nbv",
      &glVertexAttrib4Nbv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4Nbv");
    }
    out
  }
  static glVertexAttrib4Nbv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Nbv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4Nbv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4Nbv\0",
      &glVertexAttrib4Nbv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4Nbv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Nbv_is_loaded() -> bool {
    !glVertexAttrib4Nbv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Niv](http://docs.gl/gl3/glVertexAttrib4N)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Niv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4Niv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttrib4Niv",
      &glVertexAttrib4Niv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4Niv");
    }
    out
  }
  static glVertexAttrib4Niv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Niv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4Niv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4Niv\0",
      &glVertexAttrib4Niv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4Niv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Niv_is_loaded() -> bool {
    !glVertexAttrib4Niv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Nsv](http://docs.gl/gl3/glVertexAttrib4Nsv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Nsv(index: GLuint, v: *const GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4Nsv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttrib4Nsv",
      &glVertexAttrib4Nsv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4Nsv");
    }
    out
  }
  static glVertexAttrib4Nsv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Nsv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4Nsv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4Nsv\0",
      &glVertexAttrib4Nsv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4Nsv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Nsv_is_loaded() -> bool {
    !glVertexAttrib4Nsv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Nub](http://docs.gl/gl3/glVertexAttrib4Nub)(index, x, y, z, w)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Nub(
    index: GLuint, x: GLubyte, y: GLubyte, z: GLubyte, w: GLubyte,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib4Nub({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let out = call_atomic_ptr_5arg(
      "glVertexAttrib4Nub",
      &glVertexAttrib4Nub_p,
      index,
      x,
      y,
      z,
      w,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4Nub");
    }
    out
  }
  static glVertexAttrib4Nub_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Nub`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4Nub_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4Nub\0",
      &glVertexAttrib4Nub_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4Nub`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Nub_is_loaded() -> bool {
    !glVertexAttrib4Nub_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Nubv](http://docs.gl/gl3/glVertexAttrib4Nubv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Nubv(index: GLuint, v: *const GLubyte) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4Nubv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttrib4Nubv",
      &glVertexAttrib4Nubv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4Nubv");
    }
    out
  }
  static glVertexAttrib4Nubv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Nubv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4Nubv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4Nubv\0",
      &glVertexAttrib4Nubv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4Nubv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Nubv_is_loaded() -> bool {
    !glVertexAttrib4Nubv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Nuiv](http://docs.gl/gl3/glVertexAttrib4N)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Nuiv(index: GLuint, v: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4Nuiv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttrib4Nuiv",
      &glVertexAttrib4Nuiv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4Nuiv");
    }
    out
  }
  static glVertexAttrib4Nuiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Nuiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4Nuiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4Nuiv\0",
      &glVertexAttrib4Nuiv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4Nuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Nuiv_is_loaded() -> bool {
    !glVertexAttrib4Nuiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Nusv](http://docs.gl/gl3/glVertexAttrib4Nusv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Nusv(index: GLuint, v: *const GLushort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4Nusv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttrib4Nusv",
      &glVertexAttrib4Nusv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4Nusv");
    }
    out
  }
  static glVertexAttrib4Nusv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Nusv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4Nusv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4Nusv\0",
      &glVertexAttrib4Nusv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4Nusv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Nusv_is_loaded() -> bool {
    !glVertexAttrib4Nusv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4bv](http://docs.gl/gl3/glVertexAttrib4bv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4bv(index: GLuint, v: *const GLbyte) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4bv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib4bv", &glVertexAttrib4bv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4bv");
    }
    out
  }
  static glVertexAttrib4bv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4bv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4bv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4bv\0",
      &glVertexAttrib4bv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4bv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4bv_is_loaded() -> bool {
    !glVertexAttrib4bv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4d](http://docs.gl/gl3/glVertexAttrib4d)(index, x, y, z, w)
  /// * vector equivalent: [`glVertexAttrib4dv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4d(
    index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib4d({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let out = call_atomic_ptr_5arg(
      "glVertexAttrib4d",
      &glVertexAttrib4d_p,
      index,
      x,
      y,
      z,
      w,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4d");
    }
    out
  }
  static glVertexAttrib4d_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4d`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4d_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4d\0",
      &glVertexAttrib4d_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4d_is_loaded() -> bool {
    !glVertexAttrib4d_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4dv](http://docs.gl/gl3/glVertexAttrib4dv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4dv(index: GLuint, v: *const GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4dv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib4dv", &glVertexAttrib4dv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4dv");
    }
    out
  }
  static glVertexAttrib4dv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4dv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4dv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4dv\0",
      &glVertexAttrib4dv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4dv_is_loaded() -> bool {
    !glVertexAttrib4dv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4f](http://docs.gl/gl3/glVertexAttrib)(index, x, y, z, w)
  /// * vector equivalent: [`glVertexAttrib4fv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4f(
    index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib4f({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let out = call_atomic_ptr_5arg(
      "glVertexAttrib4f",
      &glVertexAttrib4f_p,
      index,
      x,
      y,
      z,
      w,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4f");
    }
    out
  }
  static glVertexAttrib4f_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4f`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4f_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4f\0",
      &glVertexAttrib4f_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4f_is_loaded() -> bool {
    !glVertexAttrib4f_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4fv](http://docs.gl/gl3/glVertexAttrib)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4fv(index: GLuint, v: *const GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4fv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib4fv", &glVertexAttrib4fv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4fv");
    }
    out
  }
  static glVertexAttrib4fv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4fv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4fv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4fv\0",
      &glVertexAttrib4fv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4fv_is_loaded() -> bool {
    !glVertexAttrib4fv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4iv](http://docs.gl/gl3/glVertexAttrib)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4iv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4iv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib4iv", &glVertexAttrib4iv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4iv");
    }
    out
  }
  static glVertexAttrib4iv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4iv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4iv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4iv\0",
      &glVertexAttrib4iv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4iv_is_loaded() -> bool {
    !glVertexAttrib4iv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4s](http://docs.gl/gl3/glVertexAttrib4s)(index, x, y, z, w)
  /// * vector equivalent: [`glVertexAttrib4sv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4s(
    index: GLuint, x: GLshort, y: GLshort, z: GLshort, w: GLshort,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib4s({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let out = call_atomic_ptr_5arg(
      "glVertexAttrib4s",
      &glVertexAttrib4s_p,
      index,
      x,
      y,
      z,
      w,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4s");
    }
    out
  }
  static glVertexAttrib4s_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4s`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4s_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4s\0",
      &glVertexAttrib4s_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4s`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4s_is_loaded() -> bool {
    !glVertexAttrib4s_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4sv](http://docs.gl/gl3/glVertexAttrib4sv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4sv(index: GLuint, v: *const GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4sv({:?}, {:p});", index, v);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttrib4sv", &glVertexAttrib4sv_p, index, v);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4sv");
    }
    out
  }
  static glVertexAttrib4sv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4sv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4sv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4sv\0",
      &glVertexAttrib4sv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4sv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4sv_is_loaded() -> bool {
    !glVertexAttrib4sv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4ubv](http://docs.gl/gl3/glVertexAttrib4ubv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4ubv(index: GLuint, v: *const GLubyte) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4ubv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttrib4ubv",
      &glVertexAttrib4ubv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4ubv");
    }
    out
  }
  static glVertexAttrib4ubv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4ubv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4ubv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4ubv\0",
      &glVertexAttrib4ubv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4ubv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4ubv_is_loaded() -> bool {
    !glVertexAttrib4ubv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4uiv](http://docs.gl/gl3/glVertexAttrib)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4uiv(index: GLuint, v: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4uiv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttrib4uiv",
      &glVertexAttrib4uiv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4uiv");
    }
    out
  }
  static glVertexAttrib4uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4uiv\0",
      &glVertexAttrib4uiv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4uiv_is_loaded() -> bool {
    !glVertexAttrib4uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4usv](http://docs.gl/gl3/glVertexAttrib4usv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4usv(index: GLuint, v: *const GLushort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4usv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttrib4usv",
      &glVertexAttrib4usv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttrib4usv");
    }
    out
  }
  static glVertexAttrib4usv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4usv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttrib4usv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttrib4usv\0",
      &glVertexAttrib4usv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttrib4usv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4usv_is_loaded() -> bool {
    !glVertexAttrib4usv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribDivisor](http://docs.gl/gl3/glVertexAttribDivisor)(index, divisor)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribDivisor(index: GLuint, divisor: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribDivisor({:?}, {:?});", index, divisor);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribDivisor",
      &glVertexAttribDivisor_p,
      index,
      divisor,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribDivisor");
    }
    out
  }
  static glVertexAttribDivisor_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribDivisor`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribDivisor_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribDivisor\0",
      &glVertexAttribDivisor_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribDivisor`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribDivisor_is_loaded() -> bool {
    !glVertexAttribDivisor_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI1i](http://docs.gl/gl3/glVertexAttribI)(index, x)
  /// * vector equivalent: [`glVertexAttribI1iv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI1i(index: GLuint, x: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI1i({:?}, {:?});", index, x);
    }
    let out =
      call_atomic_ptr_2arg("glVertexAttribI1i", &glVertexAttribI1i_p, index, x);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI1i");
    }
    out
  }
  static glVertexAttribI1i_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI1i`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI1i_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI1i\0",
      &glVertexAttribI1i_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI1i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI1i_is_loaded() -> bool {
    !glVertexAttribI1i_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI1iv](http://docs.gl/gl3/glVertexAttribI)(index, v)
  /// * `v` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI1iv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI1iv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI1iv",
      &glVertexAttribI1iv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI1iv");
    }
    out
  }
  static glVertexAttribI1iv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI1iv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI1iv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI1iv\0",
      &glVertexAttribI1iv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI1iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI1iv_is_loaded() -> bool {
    !glVertexAttribI1iv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI1ui](http://docs.gl/gl3/glVertexAttribI)(index, x)
  /// * vector equivalent: [`glVertexAttribI1uiv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI1ui(index: GLuint, x: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI1ui({:?}, {:?});", index, x);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI1ui",
      &glVertexAttribI1ui_p,
      index,
      x,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI1ui");
    }
    out
  }
  static glVertexAttribI1ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI1ui`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI1ui_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI1ui\0",
      &glVertexAttribI1ui_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI1ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI1ui_is_loaded() -> bool {
    !glVertexAttribI1ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI1uiv](http://docs.gl/gl3/glVertexAttribI)(index, v)
  /// * `v` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI1uiv(index: GLuint, v: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI1uiv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI1uiv",
      &glVertexAttribI1uiv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI1uiv");
    }
    out
  }
  static glVertexAttribI1uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI1uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI1uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI1uiv\0",
      &glVertexAttribI1uiv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI1uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI1uiv_is_loaded() -> bool {
    !glVertexAttribI1uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI2i](http://docs.gl/gl3/glVertexAttribI)(index, x, y)
  /// * vector equivalent: [`glVertexAttribI2iv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI2i(index: GLuint, x: GLint, y: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI2i({:?}, {:?}, {:?});", index, x, y);
    }
    let out = call_atomic_ptr_3arg(
      "glVertexAttribI2i",
      &glVertexAttribI2i_p,
      index,
      x,
      y,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI2i");
    }
    out
  }
  static glVertexAttribI2i_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI2i`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI2i_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI2i\0",
      &glVertexAttribI2i_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI2i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI2i_is_loaded() -> bool {
    !glVertexAttribI2i_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI2iv](http://docs.gl/gl3/glVertexAttribI)(index, v)
  /// * `v` len: 2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI2iv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI2iv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI2iv",
      &glVertexAttribI2iv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI2iv");
    }
    out
  }
  static glVertexAttribI2iv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI2iv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI2iv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI2iv\0",
      &glVertexAttribI2iv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI2iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI2iv_is_loaded() -> bool {
    !glVertexAttribI2iv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI2ui](http://docs.gl/gl3/glVertexAttribI)(index, x, y)
  /// * vector equivalent: [`glVertexAttribI2uiv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI2ui(index: GLuint, x: GLuint, y: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI2ui({:?}, {:?}, {:?});", index, x, y);
    }
    let out = call_atomic_ptr_3arg(
      "glVertexAttribI2ui",
      &glVertexAttribI2ui_p,
      index,
      x,
      y,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI2ui");
    }
    out
  }
  static glVertexAttribI2ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI2ui`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI2ui_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI2ui\0",
      &glVertexAttribI2ui_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI2ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI2ui_is_loaded() -> bool {
    !glVertexAttribI2ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI2uiv](http://docs.gl/gl3/glVertexAttribI)(index, v)
  /// * `v` len: 2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI2uiv(index: GLuint, v: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI2uiv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI2uiv",
      &glVertexAttribI2uiv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI2uiv");
    }
    out
  }
  static glVertexAttribI2uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI2uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI2uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI2uiv\0",
      &glVertexAttribI2uiv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI2uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI2uiv_is_loaded() -> bool {
    !glVertexAttribI2uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI3i](http://docs.gl/gl3/glVertexAttribI)(index, x, y, z)
  /// * vector equivalent: [`glVertexAttribI3iv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI3i(index: GLuint, x: GLint, y: GLint, z: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribI3i({:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttribI3i",
      &glVertexAttribI3i_p,
      index,
      x,
      y,
      z,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI3i");
    }
    out
  }
  static glVertexAttribI3i_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI3i`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI3i_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI3i\0",
      &glVertexAttribI3i_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI3i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI3i_is_loaded() -> bool {
    !glVertexAttribI3i_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI3iv](http://docs.gl/gl3/glVertexAttribI)(index, v)
  /// * `v` len: 3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI3iv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI3iv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI3iv",
      &glVertexAttribI3iv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI3iv");
    }
    out
  }
  static glVertexAttribI3iv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI3iv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI3iv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI3iv\0",
      &glVertexAttribI3iv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI3iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI3iv_is_loaded() -> bool {
    !glVertexAttribI3iv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI3ui](http://docs.gl/gl3/glVertexAttribI)(index, x, y, z)
  /// * vector equivalent: [`glVertexAttribI3uiv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI3ui(
    index: GLuint, x: GLuint, y: GLuint, z: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribI3ui({:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttribI3ui",
      &glVertexAttribI3ui_p,
      index,
      x,
      y,
      z,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI3ui");
    }
    out
  }
  static glVertexAttribI3ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI3ui`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI3ui_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI3ui\0",
      &glVertexAttribI3ui_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI3ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI3ui_is_loaded() -> bool {
    !glVertexAttribI3ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI3uiv](http://docs.gl/gl3/glVertexAttribI)(index, v)
  /// * `v` len: 3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI3uiv(index: GLuint, v: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI3uiv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI3uiv",
      &glVertexAttribI3uiv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI3uiv");
    }
    out
  }
  static glVertexAttribI3uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI3uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI3uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI3uiv\0",
      &glVertexAttribI3uiv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI3uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI3uiv_is_loaded() -> bool {
    !glVertexAttribI3uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4bv](http://docs.gl/gl3/glVertexAttribI4bv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4bv(index: GLuint, v: *const GLbyte) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI4bv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI4bv",
      &glVertexAttribI4bv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI4bv");
    }
    out
  }
  static glVertexAttribI4bv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4bv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI4bv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI4bv\0",
      &glVertexAttribI4bv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI4bv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4bv_is_loaded() -> bool {
    !glVertexAttribI4bv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4i](http://docs.gl/gl3/glVertexAttribI)(index, x, y, z, w)
  /// * vector equivalent: [`glVertexAttribI4iv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4i(
    index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribI4i({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let out = call_atomic_ptr_5arg(
      "glVertexAttribI4i",
      &glVertexAttribI4i_p,
      index,
      x,
      y,
      z,
      w,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI4i");
    }
    out
  }
  static glVertexAttribI4i_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4i`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI4i_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI4i\0",
      &glVertexAttribI4i_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI4i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4i_is_loaded() -> bool {
    !glVertexAttribI4i_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4iv](http://docs.gl/gl3/glVertexAttrib)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4iv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI4iv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI4iv",
      &glVertexAttribI4iv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI4iv");
    }
    out
  }
  static glVertexAttribI4iv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4iv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI4iv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI4iv\0",
      &glVertexAttribI4iv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI4iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4iv_is_loaded() -> bool {
    !glVertexAttribI4iv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4sv](http://docs.gl/gl3/glVertexAttribI4sv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4sv(index: GLuint, v: *const GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI4sv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI4sv",
      &glVertexAttribI4sv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI4sv");
    }
    out
  }
  static glVertexAttribI4sv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4sv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI4sv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI4sv\0",
      &glVertexAttribI4sv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI4sv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4sv_is_loaded() -> bool {
    !glVertexAttribI4sv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4ubv](http://docs.gl/gl3/glVertexAttribI4ubv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4ubv(index: GLuint, v: *const GLubyte) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI4ubv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI4ubv",
      &glVertexAttribI4ubv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI4ubv");
    }
    out
  }
  static glVertexAttribI4ubv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4ubv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI4ubv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI4ubv\0",
      &glVertexAttribI4ubv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI4ubv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4ubv_is_loaded() -> bool {
    !glVertexAttribI4ubv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4ui](http://docs.gl/gl3/glVertexAttrib)(index, x, y, z, w)
  /// * vector equivalent: [`glVertexAttribI4uiv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4ui(
    index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribI4ui({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let out = call_atomic_ptr_5arg(
      "glVertexAttribI4ui",
      &glVertexAttribI4ui_p,
      index,
      x,
      y,
      z,
      w,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI4ui");
    }
    out
  }
  static glVertexAttribI4ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4ui`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI4ui_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI4ui\0",
      &glVertexAttribI4ui_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI4ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4ui_is_loaded() -> bool {
    !glVertexAttribI4ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4uiv](http://docs.gl/gl3/glVertexAttrib)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4uiv(index: GLuint, v: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI4uiv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI4uiv",
      &glVertexAttribI4uiv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI4uiv");
    }
    out
  }
  static glVertexAttribI4uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI4uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI4uiv\0",
      &glVertexAttribI4uiv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI4uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4uiv_is_loaded() -> bool {
    !glVertexAttribI4uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4usv](http://docs.gl/gl3/glVertexAttribI4usv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4usv(index: GLuint, v: *const GLushort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI4usv({:?}, {:p});", index, v);
    }
    let out = call_atomic_ptr_2arg(
      "glVertexAttribI4usv",
      &glVertexAttribI4usv_p,
      index,
      v,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribI4usv");
    }
    out
  }
  static glVertexAttribI4usv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4usv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribI4usv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribI4usv\0",
      &glVertexAttribI4usv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribI4usv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4usv_is_loaded() -> bool {
    !glVertexAttribI4usv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribIPointer](http://docs.gl/gl3/glVertexAttribPointer)(index, size, type_, stride, pointer)
  /// * `type_` group: VertexAttribIType
  /// * `pointer` len: COMPSIZE(size,type,stride)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribIPointer(
    index: GLuint, size: GLint, type_: GLenum, stride: GLsizei,
    pointer: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribIPointer({:?}, {:?}, {:#X}, {:?}, {:p});",
        index,
        size,
        type_,
        stride,
        pointer
      );
    }
    let out = call_atomic_ptr_5arg(
      "glVertexAttribIPointer",
      &glVertexAttribIPointer_p,
      index,
      size,
      type_,
      stride,
      pointer,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribIPointer");
    }
    out
  }
  static glVertexAttribIPointer_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribIPointer`], returns if a non-null pointer
  /// was obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribIPointer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribIPointer\0",
      &glVertexAttribIPointer_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribIPointer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribIPointer_is_loaded() -> bool {
    !glVertexAttribIPointer_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP1ui](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP1ui(
    index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP1ui({:?}, {:#X}, {:?}, {:?});",
        index,
        type_,
        normalized,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttribP1ui",
      &glVertexAttribP1ui_p,
      index,
      type_,
      normalized,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribP1ui");
    }
    out
  }
  static glVertexAttribP1ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP1ui`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribP1ui_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribP1ui\0",
      &glVertexAttribP1ui_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribP1ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP1ui_is_loaded() -> bool {
    !glVertexAttribP1ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP1uiv](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  /// * `value` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP1uiv(
    index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP1uiv({:?}, {:#X}, {:?}, {:p});",
        index,
        type_,
        normalized,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttribP1uiv",
      &glVertexAttribP1uiv_p,
      index,
      type_,
      normalized,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribP1uiv");
    }
    out
  }
  static glVertexAttribP1uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP1uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribP1uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribP1uiv\0",
      &glVertexAttribP1uiv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribP1uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP1uiv_is_loaded() -> bool {
    !glVertexAttribP1uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP2ui](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP2ui(
    index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP2ui({:?}, {:#X}, {:?}, {:?});",
        index,
        type_,
        normalized,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttribP2ui",
      &glVertexAttribP2ui_p,
      index,
      type_,
      normalized,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribP2ui");
    }
    out
  }
  static glVertexAttribP2ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP2ui`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribP2ui_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribP2ui\0",
      &glVertexAttribP2ui_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribP2ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP2ui_is_loaded() -> bool {
    !glVertexAttribP2ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP2uiv](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  /// * `value` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP2uiv(
    index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP2uiv({:?}, {:#X}, {:?}, {:p});",
        index,
        type_,
        normalized,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttribP2uiv",
      &glVertexAttribP2uiv_p,
      index,
      type_,
      normalized,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribP2uiv");
    }
    out
  }
  static glVertexAttribP2uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP2uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribP2uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribP2uiv\0",
      &glVertexAttribP2uiv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribP2uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP2uiv_is_loaded() -> bool {
    !glVertexAttribP2uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP3ui](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP3ui(
    index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP3ui({:?}, {:#X}, {:?}, {:?});",
        index,
        type_,
        normalized,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttribP3ui",
      &glVertexAttribP3ui_p,
      index,
      type_,
      normalized,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribP3ui");
    }
    out
  }
  static glVertexAttribP3ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP3ui`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribP3ui_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribP3ui\0",
      &glVertexAttribP3ui_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribP3ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP3ui_is_loaded() -> bool {
    !glVertexAttribP3ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP3uiv](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  /// * `value` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP3uiv(
    index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP3uiv({:?}, {:#X}, {:?}, {:p});",
        index,
        type_,
        normalized,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttribP3uiv",
      &glVertexAttribP3uiv_p,
      index,
      type_,
      normalized,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribP3uiv");
    }
    out
  }
  static glVertexAttribP3uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP3uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribP3uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribP3uiv\0",
      &glVertexAttribP3uiv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribP3uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP3uiv_is_loaded() -> bool {
    !glVertexAttribP3uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP4ui](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP4ui(
    index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP4ui({:?}, {:#X}, {:?}, {:?});",
        index,
        type_,
        normalized,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttribP4ui",
      &glVertexAttribP4ui_p,
      index,
      type_,
      normalized,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribP4ui");
    }
    out
  }
  static glVertexAttribP4ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP4ui`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribP4ui_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribP4ui\0",
      &glVertexAttribP4ui_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribP4ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP4ui_is_loaded() -> bool {
    !glVertexAttribP4ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP4uiv](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  /// * `value` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP4uiv(
    index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP4uiv({:?}, {:#X}, {:?}, {:p});",
        index,
        type_,
        normalized,
        value
      );
    }
    let out = call_atomic_ptr_4arg(
      "glVertexAttribP4uiv",
      &glVertexAttribP4uiv_p,
      index,
      type_,
      normalized,
      value,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribP4uiv");
    }
    out
  }
  static glVertexAttribP4uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP4uiv`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribP4uiv_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribP4uiv\0",
      &glVertexAttribP4uiv_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribP4uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP4uiv_is_loaded() -> bool {
    !glVertexAttribP4uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribPointer](http://docs.gl/gl3/glVertexAttribPointer)(index, size, type_, normalized, stride, pointer)
  /// * `type_` group: VertexAttribPointerType
  /// * `pointer` len: COMPSIZE(size,type,stride)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribPointer(
    index: GLuint, size: GLint, type_: GLenum, normalized: GLboolean,
    stride: GLsizei, pointer: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribPointer({:?}, {:?}, {:#X}, {:?}, {:?}, {:p});",
        index,
        size,
        type_,
        normalized,
        stride,
        pointer
      );
    }
    let out = call_atomic_ptr_6arg(
      "glVertexAttribPointer",
      &glVertexAttribPointer_p,
      index,
      size,
      type_,
      normalized,
      stride,
      pointer,
    );
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glVertexAttribPointer");
    }
    out
  }
  static glVertexAttribPointer_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribPointer`], returns if a non-null pointer was
  /// obtained.
  #[doc(hidden)]
  pub unsafe fn glVertexAttribPointer_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(
      get_proc_address,
      b"glVertexAttribPointer\0",
      &glVertexAttribPointer_p,
    )
  }
  /// Checks if the pointer for [`glVertexAttribPointer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribPointer_is_loaded() -> bool {
    !glVertexAttribPointer_p.load(RELAX).is_null()
  }

  /// [glViewport](http://docs.gl/gl3/glViewport)(x, y, width, height)
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glViewport(
    x: GLint, y: GLint, width: GLsizei, height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glViewport({:?}, {:?}, {:?}, {:?});",
        x,
        y,
        width,
        height
      );
    }
    let out =
      call_atomic_ptr_4arg("glViewport", &glViewport_p, x, y, width, height);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glViewport");
    }
    out
  }
  static glViewport_p: APcv = ap_null();
  /// Tries to load [`glViewport`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glViewport_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glViewport\0", &glViewport_p)
  }
  /// Checks if the pointer for [`glViewport`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glViewport_is_loaded() -> bool {
    !glViewport_p.load(RELAX).is_null()
  }

  /// [glWaitSync](http://docs.gl/gl3/glWaitSync)(sync, flags, timeout)
  /// * `sync` group: sync
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glWaitSync(sync: GLsync, flags: GLbitfield, timeout: GLuint64) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glWaitSync({:p}, {:?}, {:?});", sync, flags, timeout);
    }
    let out =
      call_atomic_ptr_3arg("glWaitSync", &glWaitSync_p, sync, flags, timeout);
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      global_automatic_glGetError("glWaitSync");
    }
    out
  }
  static glWaitSync_p: APcv = ap_null();
  /// Tries to load [`glWaitSync`], returns if a non-null pointer was obtained.
  #[doc(hidden)]
  pub unsafe fn glWaitSync_load_with_dyn(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
  ) -> bool {
    load_dyn_name_atomic_ptr(get_proc_address, b"glWaitSync\0", &glWaitSync_p)
  }
  /// Checks if the pointer for [`glWaitSync`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glWaitSync_is_loaded() -> bool {
    !glWaitSync_p.load(RELAX).is_null()
  }
}

#[cfg(feature = "struct_loader")]
pub use struct_commands::*;
#[cfg(feature = "struct_loader")]
pub mod struct_commands {
  //! Contains the [`GlFns`] type for using the struct GL loader.
  use super::*;
  impl GlFns {
    /// Constructs a new struct with all pointers loaded by the
    /// `get_proc_address` given.
    pub unsafe fn load_with<F>(mut get_proc_address: F) -> Self
    where
      F: FnMut(*const c_char) -> *mut c_void,
    {
      // Safety: The `GlFns` struct is nothing but `AtomicPtr` fields,
      // which can be safely constructed with `zeroed`.
      let out: Self = core::mem::zeroed();
      out.load_all_with_dyn(&mut get_proc_address);
      out
    }

    #[cfg(feature = "debug_automatic_glGetError")]
    #[inline(never)]
    unsafe fn automatic_glGetError(&self, name: &str) {
      let mut err = self.GetError();
      while err != GL_NO_ERROR {
        report_error_code_from(name, err);
        err = self.GetError();
      }
    }

    /// Loads all pointers using the `get_proc_address` given.
    #[doc(hidden)]
    #[inline(never)]
    pub unsafe fn load_all_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) {
      self.ActiveTexture_load_with_dyn(get_proc_address);
      self.AttachShader_load_with_dyn(get_proc_address);
      self.BeginConditionalRender_load_with_dyn(get_proc_address);
      self.BeginQuery_load_with_dyn(get_proc_address);
      self.BeginTransformFeedback_load_with_dyn(get_proc_address);
      self.BindAttribLocation_load_with_dyn(get_proc_address);
      self.BindBuffer_load_with_dyn(get_proc_address);
      self.BindBufferBase_load_with_dyn(get_proc_address);
      self.BindBufferRange_load_with_dyn(get_proc_address);
      self.BindFragDataLocation_load_with_dyn(get_proc_address);
      self.BindFragDataLocationIndexed_load_with_dyn(get_proc_address);
      self.BindFramebuffer_load_with_dyn(get_proc_address);
      self.BindRenderbuffer_load_with_dyn(get_proc_address);
      self.BindSampler_load_with_dyn(get_proc_address);
      self.BindTexture_load_with_dyn(get_proc_address);
      self.BindVertexArray_load_with_dyn(get_proc_address);
      self.BlendColor_load_with_dyn(get_proc_address);
      self.BlendEquation_load_with_dyn(get_proc_address);
      self.BlendEquationSeparate_load_with_dyn(get_proc_address);
      self.BlendFunc_load_with_dyn(get_proc_address);
      self.BlendFuncSeparate_load_with_dyn(get_proc_address);
      self.BlitFramebuffer_load_with_dyn(get_proc_address);
      self.BufferData_load_with_dyn(get_proc_address);
      self.BufferSubData_load_with_dyn(get_proc_address);
      self.CheckFramebufferStatus_load_with_dyn(get_proc_address);
      self.ClampColor_load_with_dyn(get_proc_address);
      self.Clear_load_with_dyn(get_proc_address);
      self.ClearBufferfi_load_with_dyn(get_proc_address);
      self.ClearBufferfv_load_with_dyn(get_proc_address);
      self.ClearBufferiv_load_with_dyn(get_proc_address);
      self.ClearBufferuiv_load_with_dyn(get_proc_address);
      self.ClearColor_load_with_dyn(get_proc_address);
      self.ClearDepth_load_with_dyn(get_proc_address);
      self.ClearStencil_load_with_dyn(get_proc_address);
      self.ClientWaitSync_load_with_dyn(get_proc_address);
      self.ColorMask_load_with_dyn(get_proc_address);
      self.ColorMaski_load_with_dyn(get_proc_address);
      self.CompileShader_load_with_dyn(get_proc_address);
      self.CompressedTexImage1D_load_with_dyn(get_proc_address);
      self.CompressedTexImage2D_load_with_dyn(get_proc_address);
      self.CompressedTexImage3D_load_with_dyn(get_proc_address);
      self.CompressedTexSubImage1D_load_with_dyn(get_proc_address);
      self.CompressedTexSubImage2D_load_with_dyn(get_proc_address);
      self.CompressedTexSubImage3D_load_with_dyn(get_proc_address);
      self.CopyBufferSubData_load_with_dyn(get_proc_address);
      self.CopyTexImage1D_load_with_dyn(get_proc_address);
      self.CopyTexImage2D_load_with_dyn(get_proc_address);
      self.CopyTexSubImage1D_load_with_dyn(get_proc_address);
      self.CopyTexSubImage2D_load_with_dyn(get_proc_address);
      self.CopyTexSubImage3D_load_with_dyn(get_proc_address);
      self.CreateProgram_load_with_dyn(get_proc_address);
      self.CreateShader_load_with_dyn(get_proc_address);
      self.CullFace_load_with_dyn(get_proc_address);
      #[cfg(any(feature = "GL_KHR_debug"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
      {
        self.DebugMessageCallback_load_with_dyn(get_proc_address);
      }
      #[cfg(any(feature = "GL_ARB_debug_output"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
      {
        self.DebugMessageCallbackARB_load_with_dyn(get_proc_address);
      }
      #[cfg(any(feature = "GL_KHR_debug"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
      {
        self.DebugMessageControl_load_with_dyn(get_proc_address);
      }
      #[cfg(any(feature = "GL_ARB_debug_output"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
      {
        self.DebugMessageControlARB_load_with_dyn(get_proc_address);
      }
      #[cfg(any(feature = "GL_KHR_debug"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
      {
        self.DebugMessageInsert_load_with_dyn(get_proc_address);
      }
      #[cfg(any(feature = "GL_ARB_debug_output"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
      {
        self.DebugMessageInsertARB_load_with_dyn(get_proc_address);
      }
      self.DeleteBuffers_load_with_dyn(get_proc_address);
      self.DeleteFramebuffers_load_with_dyn(get_proc_address);
      self.DeleteProgram_load_with_dyn(get_proc_address);
      self.DeleteQueries_load_with_dyn(get_proc_address);
      self.DeleteRenderbuffers_load_with_dyn(get_proc_address);
      self.DeleteSamplers_load_with_dyn(get_proc_address);
      self.DeleteShader_load_with_dyn(get_proc_address);
      self.DeleteSync_load_with_dyn(get_proc_address);
      self.DeleteTextures_load_with_dyn(get_proc_address);
      self.DeleteVertexArrays_load_with_dyn(get_proc_address);
      self.DepthFunc_load_with_dyn(get_proc_address);
      self.DepthMask_load_with_dyn(get_proc_address);
      self.DepthRange_load_with_dyn(get_proc_address);
      self.DetachShader_load_with_dyn(get_proc_address);
      self.Disable_load_with_dyn(get_proc_address);
      self.DisableVertexAttribArray_load_with_dyn(get_proc_address);
      self.Disablei_load_with_dyn(get_proc_address);
      self.DrawArrays_load_with_dyn(get_proc_address);
      self.DrawArraysInstanced_load_with_dyn(get_proc_address);
      self.DrawBuffer_load_with_dyn(get_proc_address);
      self.DrawBuffers_load_with_dyn(get_proc_address);
      self.DrawElements_load_with_dyn(get_proc_address);
      self.DrawElementsBaseVertex_load_with_dyn(get_proc_address);
      self.DrawElementsInstanced_load_with_dyn(get_proc_address);
      self.DrawElementsInstancedBaseVertex_load_with_dyn(get_proc_address);
      self.DrawRangeElements_load_with_dyn(get_proc_address);
      self.DrawRangeElementsBaseVertex_load_with_dyn(get_proc_address);
      self.Enable_load_with_dyn(get_proc_address);
      self.EnableVertexAttribArray_load_with_dyn(get_proc_address);
      self.Enablei_load_with_dyn(get_proc_address);
      self.EndConditionalRender_load_with_dyn(get_proc_address);
      self.EndQuery_load_with_dyn(get_proc_address);
      self.EndTransformFeedback_load_with_dyn(get_proc_address);
      self.FenceSync_load_with_dyn(get_proc_address);
      self.Finish_load_with_dyn(get_proc_address);
      self.Flush_load_with_dyn(get_proc_address);
      self.FlushMappedBufferRange_load_with_dyn(get_proc_address);
      self.FramebufferRenderbuffer_load_with_dyn(get_proc_address);
      self.FramebufferTexture_load_with_dyn(get_proc_address);
      self.FramebufferTexture1D_load_with_dyn(get_proc_address);
      self.FramebufferTexture2D_load_with_dyn(get_proc_address);
      self.FramebufferTexture3D_load_with_dyn(get_proc_address);
      self.FramebufferTextureLayer_load_with_dyn(get_proc_address);
      self.FrontFace_load_with_dyn(get_proc_address);
      self.GenBuffers_load_with_dyn(get_proc_address);
      self.GenFramebuffers_load_with_dyn(get_proc_address);
      self.GenQueries_load_with_dyn(get_proc_address);
      self.GenRenderbuffers_load_with_dyn(get_proc_address);
      self.GenSamplers_load_with_dyn(get_proc_address);
      self.GenTextures_load_with_dyn(get_proc_address);
      self.GenVertexArrays_load_with_dyn(get_proc_address);
      self.GenerateMipmap_load_with_dyn(get_proc_address);
      self.GetActiveAttrib_load_with_dyn(get_proc_address);
      self.GetActiveUniform_load_with_dyn(get_proc_address);
      self.GetActiveUniformBlockName_load_with_dyn(get_proc_address);
      self.GetActiveUniformBlockiv_load_with_dyn(get_proc_address);
      self.GetActiveUniformName_load_with_dyn(get_proc_address);
      self.GetActiveUniformsiv_load_with_dyn(get_proc_address);
      self.GetAttachedShaders_load_with_dyn(get_proc_address);
      self.GetAttribLocation_load_with_dyn(get_proc_address);
      self.GetBooleani_v_load_with_dyn(get_proc_address);
      self.GetBooleanv_load_with_dyn(get_proc_address);
      self.GetBufferParameteri64v_load_with_dyn(get_proc_address);
      self.GetBufferParameteriv_load_with_dyn(get_proc_address);
      self.GetBufferPointerv_load_with_dyn(get_proc_address);
      self.GetBufferSubData_load_with_dyn(get_proc_address);
      self.GetCompressedTexImage_load_with_dyn(get_proc_address);
      #[cfg(any(feature = "GL_KHR_debug"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
      {
        self.GetDebugMessageLog_load_with_dyn(get_proc_address);
      }
      #[cfg(any(feature = "GL_ARB_debug_output"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
      {
        self.GetDebugMessageLogARB_load_with_dyn(get_proc_address);
      }
      self.GetDoublev_load_with_dyn(get_proc_address);
      self.GetError_load_with_dyn(get_proc_address);
      self.GetFloatv_load_with_dyn(get_proc_address);
      self.GetFragDataIndex_load_with_dyn(get_proc_address);
      self.GetFragDataLocation_load_with_dyn(get_proc_address);
      self.GetFramebufferAttachmentParameteriv_load_with_dyn(get_proc_address);
      self.GetInteger64i_v_load_with_dyn(get_proc_address);
      self.GetInteger64v_load_with_dyn(get_proc_address);
      self.GetIntegeri_v_load_with_dyn(get_proc_address);
      self.GetIntegerv_load_with_dyn(get_proc_address);
      self.GetMultisamplefv_load_with_dyn(get_proc_address);
      #[cfg(any(feature = "GL_KHR_debug"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
      {
        self.GetObjectLabel_load_with_dyn(get_proc_address);
      }
      #[cfg(any(feature = "GL_KHR_debug"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
      {
        self.GetObjectPtrLabel_load_with_dyn(get_proc_address);
      }
      #[cfg(any(feature = "GL_KHR_debug"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
      {
        self.GetPointerv_load_with_dyn(get_proc_address);
      }
      self.GetProgramInfoLog_load_with_dyn(get_proc_address);
      self.GetProgramiv_load_with_dyn(get_proc_address);
      self.GetQueryObjecti64v_load_with_dyn(get_proc_address);
      self.GetQueryObjectiv_load_with_dyn(get_proc_address);
      self.GetQueryObjectui64v_load_with_dyn(get_proc_address);
      self.GetQueryObjectuiv_load_with_dyn(get_proc_address);
      self.GetQueryiv_load_with_dyn(get_proc_address);
      self.GetRenderbufferParameteriv_load_with_dyn(get_proc_address);
      self.GetSamplerParameterIiv_load_with_dyn(get_proc_address);
      self.GetSamplerParameterIuiv_load_with_dyn(get_proc_address);
      self.GetSamplerParameterfv_load_with_dyn(get_proc_address);
      self.GetSamplerParameteriv_load_with_dyn(get_proc_address);
      self.GetShaderInfoLog_load_with_dyn(get_proc_address);
      self.GetShaderSource_load_with_dyn(get_proc_address);
      self.GetShaderiv_load_with_dyn(get_proc_address);
      self.GetString_load_with_dyn(get_proc_address);
      self.GetStringi_load_with_dyn(get_proc_address);
      self.GetSynciv_load_with_dyn(get_proc_address);
      self.GetTexImage_load_with_dyn(get_proc_address);
      self.GetTexLevelParameterfv_load_with_dyn(get_proc_address);
      self.GetTexLevelParameteriv_load_with_dyn(get_proc_address);
      self.GetTexParameterIiv_load_with_dyn(get_proc_address);
      self.GetTexParameterIuiv_load_with_dyn(get_proc_address);
      self.GetTexParameterfv_load_with_dyn(get_proc_address);
      self.GetTexParameteriv_load_with_dyn(get_proc_address);
      self.GetTransformFeedbackVarying_load_with_dyn(get_proc_address);
      self.GetUniformBlockIndex_load_with_dyn(get_proc_address);
      self.GetUniformIndices_load_with_dyn(get_proc_address);
      self.GetUniformLocation_load_with_dyn(get_proc_address);
      self.GetUniformfv_load_with_dyn(get_proc_address);
      self.GetUniformiv_load_with_dyn(get_proc_address);
      self.GetUniformuiv_load_with_dyn(get_proc_address);
      self.GetVertexAttribIiv_load_with_dyn(get_proc_address);
      self.GetVertexAttribIuiv_load_with_dyn(get_proc_address);
      self.GetVertexAttribPointerv_load_with_dyn(get_proc_address);
      self.GetVertexAttribdv_load_with_dyn(get_proc_address);
      self.GetVertexAttribfv_load_with_dyn(get_proc_address);
      self.GetVertexAttribiv_load_with_dyn(get_proc_address);
      self.Hint_load_with_dyn(get_proc_address);
      self.IsBuffer_load_with_dyn(get_proc_address);
      self.IsEnabled_load_with_dyn(get_proc_address);
      self.IsEnabledi_load_with_dyn(get_proc_address);
      self.IsFramebuffer_load_with_dyn(get_proc_address);
      self.IsProgram_load_with_dyn(get_proc_address);
      self.IsQuery_load_with_dyn(get_proc_address);
      self.IsRenderbuffer_load_with_dyn(get_proc_address);
      self.IsSampler_load_with_dyn(get_proc_address);
      self.IsShader_load_with_dyn(get_proc_address);
      self.IsSync_load_with_dyn(get_proc_address);
      self.IsTexture_load_with_dyn(get_proc_address);
      self.IsVertexArray_load_with_dyn(get_proc_address);
      self.LineWidth_load_with_dyn(get_proc_address);
      self.LinkProgram_load_with_dyn(get_proc_address);
      self.LogicOp_load_with_dyn(get_proc_address);
      self.MapBuffer_load_with_dyn(get_proc_address);
      self.MapBufferRange_load_with_dyn(get_proc_address);
      self.MultiDrawArrays_load_with_dyn(get_proc_address);
      self.MultiDrawElements_load_with_dyn(get_proc_address);
      self.MultiDrawElementsBaseVertex_load_with_dyn(get_proc_address);
      #[cfg(any(feature = "GL_KHR_debug"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
      {
        self.ObjectLabel_load_with_dyn(get_proc_address);
      }
      #[cfg(any(feature = "GL_KHR_debug"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
      {
        self.ObjectPtrLabel_load_with_dyn(get_proc_address);
      }
      self.PixelStoref_load_with_dyn(get_proc_address);
      self.PixelStorei_load_with_dyn(get_proc_address);
      self.PointParameterf_load_with_dyn(get_proc_address);
      self.PointParameterfv_load_with_dyn(get_proc_address);
      self.PointParameteri_load_with_dyn(get_proc_address);
      self.PointParameteriv_load_with_dyn(get_proc_address);
      self.PointSize_load_with_dyn(get_proc_address);
      self.PolygonMode_load_with_dyn(get_proc_address);
      self.PolygonOffset_load_with_dyn(get_proc_address);
      #[cfg(any(feature = "GL_KHR_debug"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
      {
        self.PopDebugGroup_load_with_dyn(get_proc_address);
      }
      self.PrimitiveRestartIndex_load_with_dyn(get_proc_address);
      self.ProvokingVertex_load_with_dyn(get_proc_address);
      #[cfg(any(feature = "GL_KHR_debug"))]
      #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
      {
        self.PushDebugGroup_load_with_dyn(get_proc_address);
      }
      self.QueryCounter_load_with_dyn(get_proc_address);
      self.ReadBuffer_load_with_dyn(get_proc_address);
      self.ReadPixels_load_with_dyn(get_proc_address);
      self.RenderbufferStorage_load_with_dyn(get_proc_address);
      self.RenderbufferStorageMultisample_load_with_dyn(get_proc_address);
      self.SampleCoverage_load_with_dyn(get_proc_address);
      self.SampleMaski_load_with_dyn(get_proc_address);
      self.SamplerParameterIiv_load_with_dyn(get_proc_address);
      self.SamplerParameterIuiv_load_with_dyn(get_proc_address);
      self.SamplerParameterf_load_with_dyn(get_proc_address);
      self.SamplerParameterfv_load_with_dyn(get_proc_address);
      self.SamplerParameteri_load_with_dyn(get_proc_address);
      self.SamplerParameteriv_load_with_dyn(get_proc_address);
      self.Scissor_load_with_dyn(get_proc_address);
      self.ShaderSource_load_with_dyn(get_proc_address);
      self.StencilFunc_load_with_dyn(get_proc_address);
      self.StencilFuncSeparate_load_with_dyn(get_proc_address);
      self.StencilMask_load_with_dyn(get_proc_address);
      self.StencilMaskSeparate_load_with_dyn(get_proc_address);
      self.StencilOp_load_with_dyn(get_proc_address);
      self.StencilOpSeparate_load_with_dyn(get_proc_address);
      self.TexBuffer_load_with_dyn(get_proc_address);
      self.TexImage1D_load_with_dyn(get_proc_address);
      self.TexImage2D_load_with_dyn(get_proc_address);
      self.TexImage2DMultisample_load_with_dyn(get_proc_address);
      self.TexImage3D_load_with_dyn(get_proc_address);
      self.TexImage3DMultisample_load_with_dyn(get_proc_address);
      self.TexParameterIiv_load_with_dyn(get_proc_address);
      self.TexParameterIuiv_load_with_dyn(get_proc_address);
      self.TexParameterf_load_with_dyn(get_proc_address);
      self.TexParameterfv_load_with_dyn(get_proc_address);
      self.TexParameteri_load_with_dyn(get_proc_address);
      self.TexParameteriv_load_with_dyn(get_proc_address);
      self.TexSubImage1D_load_with_dyn(get_proc_address);
      self.TexSubImage2D_load_with_dyn(get_proc_address);
      self.TexSubImage3D_load_with_dyn(get_proc_address);
      self.TransformFeedbackVaryings_load_with_dyn(get_proc_address);
      self.Uniform1f_load_with_dyn(get_proc_address);
      self.Uniform1fv_load_with_dyn(get_proc_address);
      self.Uniform1i_load_with_dyn(get_proc_address);
      self.Uniform1iv_load_with_dyn(get_proc_address);
      self.Uniform1ui_load_with_dyn(get_proc_address);
      self.Uniform1uiv_load_with_dyn(get_proc_address);
      self.Uniform2f_load_with_dyn(get_proc_address);
      self.Uniform2fv_load_with_dyn(get_proc_address);
      self.Uniform2i_load_with_dyn(get_proc_address);
      self.Uniform2iv_load_with_dyn(get_proc_address);
      self.Uniform2ui_load_with_dyn(get_proc_address);
      self.Uniform2uiv_load_with_dyn(get_proc_address);
      self.Uniform3f_load_with_dyn(get_proc_address);
      self.Uniform3fv_load_with_dyn(get_proc_address);
      self.Uniform3i_load_with_dyn(get_proc_address);
      self.Uniform3iv_load_with_dyn(get_proc_address);
      self.Uniform3ui_load_with_dyn(get_proc_address);
      self.Uniform3uiv_load_with_dyn(get_proc_address);
      self.Uniform4f_load_with_dyn(get_proc_address);
      self.Uniform4fv_load_with_dyn(get_proc_address);
      self.Uniform4i_load_with_dyn(get_proc_address);
      self.Uniform4iv_load_with_dyn(get_proc_address);
      self.Uniform4ui_load_with_dyn(get_proc_address);
      self.Uniform4uiv_load_with_dyn(get_proc_address);
      self.UniformBlockBinding_load_with_dyn(get_proc_address);
      self.UniformMatrix2fv_load_with_dyn(get_proc_address);
      self.UniformMatrix2x3fv_load_with_dyn(get_proc_address);
      self.UniformMatrix2x4fv_load_with_dyn(get_proc_address);
      self.UniformMatrix3fv_load_with_dyn(get_proc_address);
      self.UniformMatrix3x2fv_load_with_dyn(get_proc_address);
      self.UniformMatrix3x4fv_load_with_dyn(get_proc_address);
      self.UniformMatrix4fv_load_with_dyn(get_proc_address);
      self.UniformMatrix4x2fv_load_with_dyn(get_proc_address);
      self.UniformMatrix4x3fv_load_with_dyn(get_proc_address);
      self.UnmapBuffer_load_with_dyn(get_proc_address);
      self.UseProgram_load_with_dyn(get_proc_address);
      self.ValidateProgram_load_with_dyn(get_proc_address);
      self.VertexAttrib1d_load_with_dyn(get_proc_address);
      self.VertexAttrib1dv_load_with_dyn(get_proc_address);
      self.VertexAttrib1f_load_with_dyn(get_proc_address);
      self.VertexAttrib1fv_load_with_dyn(get_proc_address);
      self.VertexAttrib1s_load_with_dyn(get_proc_address);
      self.VertexAttrib1sv_load_with_dyn(get_proc_address);
      self.VertexAttrib2d_load_with_dyn(get_proc_address);
      self.VertexAttrib2dv_load_with_dyn(get_proc_address);
      self.VertexAttrib2f_load_with_dyn(get_proc_address);
      self.VertexAttrib2fv_load_with_dyn(get_proc_address);
      self.VertexAttrib2s_load_with_dyn(get_proc_address);
      self.VertexAttrib2sv_load_with_dyn(get_proc_address);
      self.VertexAttrib3d_load_with_dyn(get_proc_address);
      self.VertexAttrib3dv_load_with_dyn(get_proc_address);
      self.VertexAttrib3f_load_with_dyn(get_proc_address);
      self.VertexAttrib3fv_load_with_dyn(get_proc_address);
      self.VertexAttrib3s_load_with_dyn(get_proc_address);
      self.VertexAttrib3sv_load_with_dyn(get_proc_address);
      self.VertexAttrib4Nbv_load_with_dyn(get_proc_address);
      self.VertexAttrib4Niv_load_with_dyn(get_proc_address);
      self.VertexAttrib4Nsv_load_with_dyn(get_proc_address);
      self.VertexAttrib4Nub_load_with_dyn(get_proc_address);
      self.VertexAttrib4Nubv_load_with_dyn(get_proc_address);
      self.VertexAttrib4Nuiv_load_with_dyn(get_proc_address);
      self.VertexAttrib4Nusv_load_with_dyn(get_proc_address);
      self.VertexAttrib4bv_load_with_dyn(get_proc_address);
      self.VertexAttrib4d_load_with_dyn(get_proc_address);
      self.VertexAttrib4dv_load_with_dyn(get_proc_address);
      self.VertexAttrib4f_load_with_dyn(get_proc_address);
      self.VertexAttrib4fv_load_with_dyn(get_proc_address);
      self.VertexAttrib4iv_load_with_dyn(get_proc_address);
      self.VertexAttrib4s_load_with_dyn(get_proc_address);
      self.VertexAttrib4sv_load_with_dyn(get_proc_address);
      self.VertexAttrib4ubv_load_with_dyn(get_proc_address);
      self.VertexAttrib4uiv_load_with_dyn(get_proc_address);
      self.VertexAttrib4usv_load_with_dyn(get_proc_address);
      self.VertexAttribDivisor_load_with_dyn(get_proc_address);
      self.VertexAttribI1i_load_with_dyn(get_proc_address);
      self.VertexAttribI1iv_load_with_dyn(get_proc_address);
      self.VertexAttribI1ui_load_with_dyn(get_proc_address);
      self.VertexAttribI1uiv_load_with_dyn(get_proc_address);
      self.VertexAttribI2i_load_with_dyn(get_proc_address);
      self.VertexAttribI2iv_load_with_dyn(get_proc_address);
      self.VertexAttribI2ui_load_with_dyn(get_proc_address);
      self.VertexAttribI2uiv_load_with_dyn(get_proc_address);
      self.VertexAttribI3i_load_with_dyn(get_proc_address);
      self.VertexAttribI3iv_load_with_dyn(get_proc_address);
      self.VertexAttribI3ui_load_with_dyn(get_proc_address);
      self.VertexAttribI3uiv_load_with_dyn(get_proc_address);
      self.VertexAttribI4bv_load_with_dyn(get_proc_address);
      self.VertexAttribI4i_load_with_dyn(get_proc_address);
      self.VertexAttribI4iv_load_with_dyn(get_proc_address);
      self.VertexAttribI4sv_load_with_dyn(get_proc_address);
      self.VertexAttribI4ubv_load_with_dyn(get_proc_address);
      self.VertexAttribI4ui_load_with_dyn(get_proc_address);
      self.VertexAttribI4uiv_load_with_dyn(get_proc_address);
      self.VertexAttribI4usv_load_with_dyn(get_proc_address);
      self.VertexAttribIPointer_load_with_dyn(get_proc_address);
      self.VertexAttribP1ui_load_with_dyn(get_proc_address);
      self.VertexAttribP1uiv_load_with_dyn(get_proc_address);
      self.VertexAttribP2ui_load_with_dyn(get_proc_address);
      self.VertexAttribP2uiv_load_with_dyn(get_proc_address);
      self.VertexAttribP3ui_load_with_dyn(get_proc_address);
      self.VertexAttribP3uiv_load_with_dyn(get_proc_address);
      self.VertexAttribP4ui_load_with_dyn(get_proc_address);
      self.VertexAttribP4uiv_load_with_dyn(get_proc_address);
      self.VertexAttribPointer_load_with_dyn(get_proc_address);
      self.Viewport_load_with_dyn(get_proc_address);
      self.WaitSync_load_with_dyn(get_proc_address);
    }
    /// [glActiveTexture](http://docs.gl/gl3/glActiveTexture)(texture)
    /// * `texture` group: TextureUnit
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ActiveTexture(&self, texture: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ActiveTexture({:#X});", texture);
      }
      let out = call_atomic_ptr_1arg(
        "glActiveTexture",
        &self.glActiveTexture_p,
        texture,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glActiveTexture");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ActiveTexture_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glActiveTexture\0",
        &self.glActiveTexture_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ActiveTexture_is_loaded(&self) -> bool {
      !self.glActiveTexture_p.load(RELAX).is_null()
    }
    /// [glAttachShader](http://docs.gl/gl3/glAttachShader)(program, shader)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn AttachShader(&self, program: GLuint, shader: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.AttachShader({:?}, {:?});", program, shader);
      }
      let out = call_atomic_ptr_2arg(
        "glAttachShader",
        &self.glAttachShader_p,
        program,
        shader,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glAttachShader");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn AttachShader_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glAttachShader\0",
        &self.glAttachShader_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn AttachShader_is_loaded(&self) -> bool {
      !self.glAttachShader_p.load(RELAX).is_null()
    }
    /// [glBeginConditionalRender](http://docs.gl/gl3/glBeginConditionalRender)(id, mode)
    /// * `mode` group: ConditionalRenderMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BeginConditionalRender(&self, id: GLuint, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BeginConditionalRender({:?}, {:#X});", id, mode);
      }
      let out = call_atomic_ptr_2arg(
        "glBeginConditionalRender",
        &self.glBeginConditionalRender_p,
        id,
        mode,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBeginConditionalRender");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BeginConditionalRender_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBeginConditionalRender\0",
        &self.glBeginConditionalRender_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BeginConditionalRender_is_loaded(&self) -> bool {
      !self.glBeginConditionalRender_p.load(RELAX).is_null()
    }
    /// [glBeginQuery](http://docs.gl/gl3/glBeginQuery)(target, id)
    /// * `target` group: QueryTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BeginQuery(&self, target: GLenum, id: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BeginQuery({:#X}, {:?});", target, id);
      }
      let out =
        call_atomic_ptr_2arg("glBeginQuery", &self.glBeginQuery_p, target, id);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBeginQuery");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BeginQuery_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBeginQuery\0",
        &self.glBeginQuery_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BeginQuery_is_loaded(&self) -> bool {
      !self.glBeginQuery_p.load(RELAX).is_null()
    }
    /// [glBeginTransformFeedback](http://docs.gl/gl3/glBeginTransformFeedback)(primitiveMode)
    /// * `primitiveMode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BeginTransformFeedback(&self, primitiveMode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BeginTransformFeedback({:#X});", primitiveMode);
      }
      let out = call_atomic_ptr_1arg(
        "glBeginTransformFeedback",
        &self.glBeginTransformFeedback_p,
        primitiveMode,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBeginTransformFeedback");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BeginTransformFeedback_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBeginTransformFeedback\0",
        &self.glBeginTransformFeedback_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BeginTransformFeedback_is_loaded(&self) -> bool {
      !self.glBeginTransformFeedback_p.load(RELAX).is_null()
    }
    /// [glBindAttribLocation](http://docs.gl/gl3/glBindAttribLocation)(program, index, name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindAttribLocation(
      &self, program: GLuint, index: GLuint, name: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindAttribLocation({:?}, {:?}, {:p});",
          program,
          index,
          name
        );
      }
      let out = call_atomic_ptr_3arg(
        "glBindAttribLocation",
        &self.glBindAttribLocation_p,
        program,
        index,
        name,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBindAttribLocation");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BindAttribLocation_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBindAttribLocation\0",
        &self.glBindAttribLocation_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindAttribLocation_is_loaded(&self) -> bool {
      !self.glBindAttribLocation_p.load(RELAX).is_null()
    }
    /// [glBindBuffer](http://docs.gl/gl3/glBindBuffer)(target, buffer)
    /// * `target` group: BufferTargetARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindBuffer(&self, target: GLenum, buffer: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindBuffer({:#X}, {:?});", target, buffer);
      }
      let out = call_atomic_ptr_2arg(
        "glBindBuffer",
        &self.glBindBuffer_p,
        target,
        buffer,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBindBuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BindBuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBindBuffer\0",
        &self.glBindBuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindBuffer_is_loaded(&self) -> bool {
      !self.glBindBuffer_p.load(RELAX).is_null()
    }
    /// [glBindBufferBase](http://docs.gl/gl3/glBindBufferBase)(target, index, buffer)
    /// * `target` group: BufferTargetARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindBufferBase(
      &self, target: GLenum, index: GLuint, buffer: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindBufferBase({:#X}, {:?}, {:?});",
          target,
          index,
          buffer
        );
      }
      let out = call_atomic_ptr_3arg(
        "glBindBufferBase",
        &self.glBindBufferBase_p,
        target,
        index,
        buffer,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBindBufferBase");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BindBufferBase_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBindBufferBase\0",
        &self.glBindBufferBase_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindBufferBase_is_loaded(&self) -> bool {
      !self.glBindBufferBase_p.load(RELAX).is_null()
    }
    /// [glBindBufferRange](http://docs.gl/gl3/glBindBufferRange)(target, index, buffer, offset, size)
    /// * `target` group: BufferTargetARB
    /// * `offset` group: BufferOffset
    /// * `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindBufferRange(
      &self, target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr,
      size: GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindBufferRange({:#X}, {:?}, {:?}, {:?}, {:?});",
          target,
          index,
          buffer,
          offset,
          size
        );
      }
      let out = call_atomic_ptr_5arg(
        "glBindBufferRange",
        &self.glBindBufferRange_p,
        target,
        index,
        buffer,
        offset,
        size,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBindBufferRange");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BindBufferRange_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBindBufferRange\0",
        &self.glBindBufferRange_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindBufferRange_is_loaded(&self) -> bool {
      !self.glBindBufferRange_p.load(RELAX).is_null()
    }
    /// [glBindFragDataLocation](http://docs.gl/gl3/glBindFragDataLocation)(program, color, name)
    /// * `name` len: COMPSIZE(name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindFragDataLocation(
      &self, program: GLuint, color: GLuint, name: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindFragDataLocation({:?}, {:?}, {:p});",
          program,
          color,
          name
        );
      }
      let out = call_atomic_ptr_3arg(
        "glBindFragDataLocation",
        &self.glBindFragDataLocation_p,
        program,
        color,
        name,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBindFragDataLocation");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BindFragDataLocation_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBindFragDataLocation\0",
        &self.glBindFragDataLocation_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindFragDataLocation_is_loaded(&self) -> bool {
      !self.glBindFragDataLocation_p.load(RELAX).is_null()
    }
    /// [glBindFragDataLocationIndexed](http://docs.gl/gl3/glBindFragDataLocationIndexed)(program, colorNumber, index, name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindFragDataLocationIndexed(
      &self, program: GLuint, colorNumber: GLuint, index: GLuint,
      name: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindFragDataLocationIndexed({:?}, {:?}, {:?}, {:p});",
          program,
          colorNumber,
          index,
          name
        );
      }
      let out = call_atomic_ptr_4arg(
        "glBindFragDataLocationIndexed",
        &self.glBindFragDataLocationIndexed_p,
        program,
        colorNumber,
        index,
        name,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBindFragDataLocationIndexed");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BindFragDataLocationIndexed_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBindFragDataLocationIndexed\0",
        &self.glBindFragDataLocationIndexed_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindFragDataLocationIndexed_is_loaded(&self) -> bool {
      !self.glBindFragDataLocationIndexed_p.load(RELAX).is_null()
    }
    /// [glBindFramebuffer](http://docs.gl/gl3/glBindFramebuffer)(target, framebuffer)
    /// * `target` group: FramebufferTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindFramebuffer(&self, target: GLenum, framebuffer: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindFramebuffer({:#X}, {:?});", target, framebuffer);
      }
      let out = call_atomic_ptr_2arg(
        "glBindFramebuffer",
        &self.glBindFramebuffer_p,
        target,
        framebuffer,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBindFramebuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BindFramebuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBindFramebuffer\0",
        &self.glBindFramebuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindFramebuffer_is_loaded(&self) -> bool {
      !self.glBindFramebuffer_p.load(RELAX).is_null()
    }
    /// [glBindRenderbuffer](http://docs.gl/gl3/glBindRenderbuffer)(target, renderbuffer)
    /// * `target` group: RenderbufferTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindRenderbuffer(
      &self, target: GLenum, renderbuffer: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindRenderbuffer({:#X}, {:?});",
          target,
          renderbuffer
        );
      }
      let out = call_atomic_ptr_2arg(
        "glBindRenderbuffer",
        &self.glBindRenderbuffer_p,
        target,
        renderbuffer,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBindRenderbuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BindRenderbuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBindRenderbuffer\0",
        &self.glBindRenderbuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindRenderbuffer_is_loaded(&self) -> bool {
      !self.glBindRenderbuffer_p.load(RELAX).is_null()
    }
    /// [glBindSampler](http://docs.gl/gl3/glBindSampler)(unit, sampler)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindSampler(&self, unit: GLuint, sampler: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindSampler({:?}, {:?});", unit, sampler);
      }
      let out = call_atomic_ptr_2arg(
        "glBindSampler",
        &self.glBindSampler_p,
        unit,
        sampler,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBindSampler");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BindSampler_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBindSampler\0",
        &self.glBindSampler_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindSampler_is_loaded(&self) -> bool {
      !self.glBindSampler_p.load(RELAX).is_null()
    }
    /// [glBindTexture](http://docs.gl/gl3/glBindTexture)(target, texture)
    /// * `target` group: TextureTarget
    /// * `texture` group: Texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindTexture(&self, target: GLenum, texture: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindTexture({:#X}, {:?});", target, texture);
      }
      let out = call_atomic_ptr_2arg(
        "glBindTexture",
        &self.glBindTexture_p,
        target,
        texture,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBindTexture");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BindTexture_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBindTexture\0",
        &self.glBindTexture_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindTexture_is_loaded(&self) -> bool {
      !self.glBindTexture_p.load(RELAX).is_null()
    }
    /// [glBindVertexArray](http://docs.gl/gl3/glBindVertexArray)(array)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindVertexArray(&self, array: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindVertexArray({:?});", array);
      }
      let out = call_atomic_ptr_1arg(
        "glBindVertexArray",
        &self.glBindVertexArray_p,
        array,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBindVertexArray");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BindVertexArray_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBindVertexArray\0",
        &self.glBindVertexArray_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindVertexArray_is_loaded(&self) -> bool {
      !self.glBindVertexArray_p.load(RELAX).is_null()
    }
    /// [glBlendColor](http://docs.gl/gl3/glBlendColor)(red, green, blue, alpha)
    /// * `red` group: ColorF
    /// * `green` group: ColorF
    /// * `blue` group: ColorF
    /// * `alpha` group: ColorF
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendColor(
      &self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BlendColor({:?}, {:?}, {:?}, {:?});",
          red,
          green,
          blue,
          alpha
        );
      }
      let out = call_atomic_ptr_4arg(
        "glBlendColor",
        &self.glBlendColor_p,
        red,
        green,
        blue,
        alpha,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBlendColor");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BlendColor_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBlendColor\0",
        &self.glBlendColor_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendColor_is_loaded(&self) -> bool {
      !self.glBlendColor_p.load(RELAX).is_null()
    }
    /// [glBlendEquation](http://docs.gl/gl3/glBlendEquation)(mode)
    /// * `mode` group: BlendEquationModeEXT
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendEquation(&self, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BlendEquation({:#X});", mode);
      }
      let out =
        call_atomic_ptr_1arg("glBlendEquation", &self.glBlendEquation_p, mode);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBlendEquation");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BlendEquation_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBlendEquation\0",
        &self.glBlendEquation_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendEquation_is_loaded(&self) -> bool {
      !self.glBlendEquation_p.load(RELAX).is_null()
    }
    /// [glBlendEquationSeparate](http://docs.gl/gl3/glBlendEquationSeparate)(modeRGB, modeAlpha)
    /// * `modeRGB` group: BlendEquationModeEXT
    /// * `modeAlpha` group: BlendEquationModeEXT
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendEquationSeparate(
      &self, modeRGB: GLenum, modeAlpha: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BlendEquationSeparate({:#X}, {:#X});",
          modeRGB,
          modeAlpha
        );
      }
      let out = call_atomic_ptr_2arg(
        "glBlendEquationSeparate",
        &self.glBlendEquationSeparate_p,
        modeRGB,
        modeAlpha,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBlendEquationSeparate");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BlendEquationSeparate_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBlendEquationSeparate\0",
        &self.glBlendEquationSeparate_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendEquationSeparate_is_loaded(&self) -> bool {
      !self.glBlendEquationSeparate_p.load(RELAX).is_null()
    }
    /// [glBlendFunc](http://docs.gl/gl3/glBlendFunc)(sfactor, dfactor)
    /// * `sfactor` group: BlendingFactor
    /// * `dfactor` group: BlendingFactor
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendFunc(&self, sfactor: GLenum, dfactor: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BlendFunc({:#X}, {:#X});", sfactor, dfactor);
      }
      let out = call_atomic_ptr_2arg(
        "glBlendFunc",
        &self.glBlendFunc_p,
        sfactor,
        dfactor,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBlendFunc");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BlendFunc_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBlendFunc\0",
        &self.glBlendFunc_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendFunc_is_loaded(&self) -> bool {
      !self.glBlendFunc_p.load(RELAX).is_null()
    }
    /// [glBlendFuncSeparate](http://docs.gl/gl3/glBlendFuncSeparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)
    /// * `sfactorRGB` group: BlendingFactor
    /// * `dfactorRGB` group: BlendingFactor
    /// * `sfactorAlpha` group: BlendingFactor
    /// * `dfactorAlpha` group: BlendingFactor
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendFuncSeparate(
      &self, sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum,
      dfactorAlpha: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BlendFuncSeparate({:#X}, {:#X}, {:#X}, {:#X});",
          sfactorRGB,
          dfactorRGB,
          sfactorAlpha,
          dfactorAlpha
        );
      }
      let out = call_atomic_ptr_4arg(
        "glBlendFuncSeparate",
        &self.glBlendFuncSeparate_p,
        sfactorRGB,
        dfactorRGB,
        sfactorAlpha,
        dfactorAlpha,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBlendFuncSeparate");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BlendFuncSeparate_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBlendFuncSeparate\0",
        &self.glBlendFuncSeparate_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendFuncSeparate_is_loaded(&self) -> bool {
      !self.glBlendFuncSeparate_p.load(RELAX).is_null()
    }
    /// [glBlitFramebuffer](http://docs.gl/gl3/glBlitFramebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
    /// * `mask` group: ClearBufferMask
    /// * `filter` group: BlitFramebufferFilter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlitFramebuffer(
      &self, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint,
      dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield,
      filter: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BlitFramebuffer({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X});", srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
      }
      let out = call_atomic_ptr_10arg(
        "glBlitFramebuffer",
        &self.glBlitFramebuffer_p,
        srcX0,
        srcY0,
        srcX1,
        srcY1,
        dstX0,
        dstY0,
        dstX1,
        dstY1,
        mask,
        filter,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBlitFramebuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BlitFramebuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBlitFramebuffer\0",
        &self.glBlitFramebuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlitFramebuffer_is_loaded(&self) -> bool {
      !self.glBlitFramebuffer_p.load(RELAX).is_null()
    }
    /// [glBufferData](http://docs.gl/gl3/glBufferData)(target, size, data, usage)
    /// * `target` group: BufferTargetARB
    /// * `size` group: BufferSize
    /// * `data` len: size
    /// * `usage` group: BufferUsageARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BufferData(
      &self, target: GLenum, size: GLsizeiptr, data: *const c_void,
      usage: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BufferData({:#X}, {:?}, {:p}, {:#X});",
          target,
          size,
          data,
          usage
        );
      }
      let out = call_atomic_ptr_4arg(
        "glBufferData",
        &self.glBufferData_p,
        target,
        size,
        data,
        usage,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBufferData");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BufferData_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBufferData\0",
        &self.glBufferData_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BufferData_is_loaded(&self) -> bool {
      !self.glBufferData_p.load(RELAX).is_null()
    }
    /// [glBufferSubData](http://docs.gl/gl3/glBufferSubData)(target, offset, size, data)
    /// * `target` group: BufferTargetARB
    /// * `offset` group: BufferOffset
    /// * `size` group: BufferSize
    /// * `data` len: size
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BufferSubData(
      &self, target: GLenum, offset: GLintptr, size: GLsizeiptr,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BufferSubData({:#X}, {:?}, {:?}, {:p});",
          target,
          offset,
          size,
          data
        );
      }
      let out = call_atomic_ptr_4arg(
        "glBufferSubData",
        &self.glBufferSubData_p,
        target,
        offset,
        size,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glBufferSubData");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn BufferSubData_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glBufferSubData\0",
        &self.glBufferSubData_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn BufferSubData_is_loaded(&self) -> bool {
      !self.glBufferSubData_p.load(RELAX).is_null()
    }
    /// [glCheckFramebufferStatus](http://docs.gl/gl3/glCheckFramebufferStatus)(target)
    /// * `target` group: FramebufferTarget
    /// * return value group: FramebufferStatus
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CheckFramebufferStatus(&self, target: GLenum) -> GLenum {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CheckFramebufferStatus({:#X});", target);
      }
      let out = call_atomic_ptr_1arg(
        "glCheckFramebufferStatus",
        &self.glCheckFramebufferStatus_p,
        target,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCheckFramebufferStatus");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CheckFramebufferStatus_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCheckFramebufferStatus\0",
        &self.glCheckFramebufferStatus_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CheckFramebufferStatus_is_loaded(&self) -> bool {
      !self.glCheckFramebufferStatus_p.load(RELAX).is_null()
    }
    /// [glClampColor](http://docs.gl/gl3/glClampColor)(target, clamp)
    /// * `target` group: ClampColorTargetARB
    /// * `clamp` group: ClampColorModeARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClampColor(&self, target: GLenum, clamp: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ClampColor({:#X}, {:#X});", target, clamp);
      }
      let out = call_atomic_ptr_2arg(
        "glClampColor",
        &self.glClampColor_p,
        target,
        clamp,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glClampColor");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ClampColor_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glClampColor\0",
        &self.glClampColor_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClampColor_is_loaded(&self) -> bool {
      !self.glClampColor_p.load(RELAX).is_null()
    }
    /// [glClear](http://docs.gl/gl3/glClear)(mask)
    /// * `mask` group: ClearBufferMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Clear(&self, mask: GLbitfield) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Clear({:?});", mask);
      }
      let out = call_atomic_ptr_1arg("glClear", &self.glClear_p, mask);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glClear");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Clear_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(get_proc_address, b"glClear\0", &self.glClear_p)
    }
    #[inline]
    #[doc(hidden)]
    pub fn Clear_is_loaded(&self) -> bool {
      !self.glClear_p.load(RELAX).is_null()
    }
    /// [glClearBufferfi](http://docs.gl/gl3/glClearBuffer)(buffer, drawbuffer, depth, stencil)
    /// * `buffer` group: Buffer
    /// * `drawbuffer` group: DrawBufferName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearBufferfi(
      &self, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearBufferfi({:#X}, {:?}, {:?}, {:?});",
          buffer,
          drawbuffer,
          depth,
          stencil
        );
      }
      let out = call_atomic_ptr_4arg(
        "glClearBufferfi",
        &self.glClearBufferfi_p,
        buffer,
        drawbuffer,
        depth,
        stencil,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glClearBufferfi");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ClearBufferfi_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glClearBufferfi\0",
        &self.glClearBufferfi_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearBufferfi_is_loaded(&self) -> bool {
      !self.glClearBufferfi_p.load(RELAX).is_null()
    }
    /// [glClearBufferfv](http://docs.gl/gl3/glClearBuffer)(buffer, drawbuffer, value)
    /// * `buffer` group: Buffer
    /// * `drawbuffer` group: DrawBufferName
    /// * `value` len: COMPSIZE(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearBufferfv(
      &self, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearBufferfv({:#X}, {:?}, {:p});",
          buffer,
          drawbuffer,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glClearBufferfv",
        &self.glClearBufferfv_p,
        buffer,
        drawbuffer,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glClearBufferfv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ClearBufferfv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glClearBufferfv\0",
        &self.glClearBufferfv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearBufferfv_is_loaded(&self) -> bool {
      !self.glClearBufferfv_p.load(RELAX).is_null()
    }
    /// [glClearBufferiv](http://docs.gl/gl3/glClearBuffer)(buffer, drawbuffer, value)
    /// * `buffer` group: Buffer
    /// * `drawbuffer` group: DrawBufferName
    /// * `value` len: COMPSIZE(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearBufferiv(
      &self, buffer: GLenum, drawbuffer: GLint, value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearBufferiv({:#X}, {:?}, {:p});",
          buffer,
          drawbuffer,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glClearBufferiv",
        &self.glClearBufferiv_p,
        buffer,
        drawbuffer,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glClearBufferiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ClearBufferiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glClearBufferiv\0",
        &self.glClearBufferiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearBufferiv_is_loaded(&self) -> bool {
      !self.glClearBufferiv_p.load(RELAX).is_null()
    }
    /// [glClearBufferuiv](http://docs.gl/gl3/glClearBuffer)(buffer, drawbuffer, value)
    /// * `buffer` group: Buffer
    /// * `drawbuffer` group: DrawBufferName
    /// * `value` len: COMPSIZE(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearBufferuiv(
      &self, buffer: GLenum, drawbuffer: GLint, value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearBufferuiv({:#X}, {:?}, {:p});",
          buffer,
          drawbuffer,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glClearBufferuiv",
        &self.glClearBufferuiv_p,
        buffer,
        drawbuffer,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glClearBufferuiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ClearBufferuiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glClearBufferuiv\0",
        &self.glClearBufferuiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearBufferuiv_is_loaded(&self) -> bool {
      !self.glClearBufferuiv_p.load(RELAX).is_null()
    }
    /// [glClearColor](http://docs.gl/gl3/glClearColor)(red, green, blue, alpha)
    /// * `red` group: ColorF
    /// * `green` group: ColorF
    /// * `blue` group: ColorF
    /// * `alpha` group: ColorF
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearColor(
      &self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearColor({:?}, {:?}, {:?}, {:?});",
          red,
          green,
          blue,
          alpha
        );
      }
      let out = call_atomic_ptr_4arg(
        "glClearColor",
        &self.glClearColor_p,
        red,
        green,
        blue,
        alpha,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glClearColor");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ClearColor_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glClearColor\0",
        &self.glClearColor_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearColor_is_loaded(&self) -> bool {
      !self.glClearColor_p.load(RELAX).is_null()
    }
    /// [glClearDepth](http://docs.gl/gl3/glClearDepth)(depth)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearDepth(&self, depth: GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ClearDepth({:?});", depth);
      }
      let out =
        call_atomic_ptr_1arg("glClearDepth", &self.glClearDepth_p, depth);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glClearDepth");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ClearDepth_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glClearDepth\0",
        &self.glClearDepth_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearDepth_is_loaded(&self) -> bool {
      !self.glClearDepth_p.load(RELAX).is_null()
    }
    /// [glClearStencil](http://docs.gl/gl3/glClearStencil)(s)
    /// * `s` group: StencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearStencil(&self, s: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ClearStencil({:?});", s);
      }
      let out =
        call_atomic_ptr_1arg("glClearStencil", &self.glClearStencil_p, s);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glClearStencil");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ClearStencil_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glClearStencil\0",
        &self.glClearStencil_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearStencil_is_loaded(&self) -> bool {
      !self.glClearStencil_p.load(RELAX).is_null()
    }
    /// [glClientWaitSync](http://docs.gl/gl3/glClientWaitSync)(sync, flags, timeout)
    /// * `sync` group: sync
    /// * `flags` group: SyncObjectMask
    /// * return value group: SyncStatus
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClientWaitSync(
      &self, sync: GLsync, flags: GLbitfield, timeout: GLuint64,
    ) -> GLenum {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClientWaitSync({:p}, {:?}, {:?});",
          sync,
          flags,
          timeout
        );
      }
      let out = call_atomic_ptr_3arg(
        "glClientWaitSync",
        &self.glClientWaitSync_p,
        sync,
        flags,
        timeout,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glClientWaitSync");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ClientWaitSync_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glClientWaitSync\0",
        &self.glClientWaitSync_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClientWaitSync_is_loaded(&self) -> bool {
      !self.glClientWaitSync_p.load(RELAX).is_null()
    }
    /// [glColorMask](http://docs.gl/gl3/glColorMask)(red, green, blue, alpha)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ColorMask(
      &self, red: GLboolean, green: GLboolean, blue: GLboolean,
      alpha: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ColorMask({:?}, {:?}, {:?}, {:?});",
          red,
          green,
          blue,
          alpha
        );
      }
      let out = call_atomic_ptr_4arg(
        "glColorMask",
        &self.glColorMask_p,
        red,
        green,
        blue,
        alpha,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glColorMask");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ColorMask_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glColorMask\0",
        &self.glColorMask_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ColorMask_is_loaded(&self) -> bool {
      !self.glColorMask_p.load(RELAX).is_null()
    }
    /// [glColorMaski](http://docs.gl/gl3/glColorMask)(index, r, g, b, a)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ColorMaski(
      &self, index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean,
      a: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ColorMaski({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          r,
          g,
          b,
          a
        );
      }
      let out = call_atomic_ptr_5arg(
        "glColorMaski",
        &self.glColorMaski_p,
        index,
        r,
        g,
        b,
        a,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glColorMaski");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ColorMaski_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glColorMaski\0",
        &self.glColorMaski_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ColorMaski_is_loaded(&self) -> bool {
      !self.glColorMaski_p.load(RELAX).is_null()
    }
    /// [glCompileShader](http://docs.gl/gl3/glCompileShader)(shader)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompileShader(&self, shader: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompileShader({:?});", shader);
      }
      let out = call_atomic_ptr_1arg(
        "glCompileShader",
        &self.glCompileShader_p,
        shader,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCompileShader");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CompileShader_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCompileShader\0",
        &self.glCompileShader_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompileShader_is_loaded(&self) -> bool {
      !self.glCompileShader_p.load(RELAX).is_null()
    }
    /// [glCompressedTexImage1D](http://docs.gl/gl3/glCompressedTexImage1D)(target, level, internalformat, width, border, imageSize, data)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `border` group: CheckedInt32
    /// * `data` group: CompressedTextureARB
    /// * `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTexImage1D(
      &self, target: GLenum, level: GLint, internalformat: GLenum,
      width: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTexImage1D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, border, imageSize, data);
      }
      let out = call_atomic_ptr_7arg(
        "glCompressedTexImage1D",
        &self.glCompressedTexImage1D_p,
        target,
        level,
        internalformat,
        width,
        border,
        imageSize,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCompressedTexImage1D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CompressedTexImage1D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCompressedTexImage1D\0",
        &self.glCompressedTexImage1D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTexImage1D_is_loaded(&self) -> bool {
      !self.glCompressedTexImage1D_p.load(RELAX).is_null()
    }
    /// [glCompressedTexImage2D](http://docs.gl/gl3/glCompressedTexImage2D)(target, level, internalformat, width, height, border, imageSize, data)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `border` group: CheckedInt32
    /// * `data` group: CompressedTextureARB
    /// * `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTexImage2D(
      &self, target: GLenum, level: GLint, internalformat: GLenum,
      width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTexImage2D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, height, border, imageSize, data);
      }
      let out = call_atomic_ptr_8arg(
        "glCompressedTexImage2D",
        &self.glCompressedTexImage2D_p,
        target,
        level,
        internalformat,
        width,
        height,
        border,
        imageSize,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCompressedTexImage2D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CompressedTexImage2D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCompressedTexImage2D\0",
        &self.glCompressedTexImage2D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTexImage2D_is_loaded(&self) -> bool {
      !self.glCompressedTexImage2D_p.load(RELAX).is_null()
    }
    /// [glCompressedTexImage3D](http://docs.gl/gl3/glCompressedTexImage3D)(target, level, internalformat, width, height, depth, border, imageSize, data)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `border` group: CheckedInt32
    /// * `data` group: CompressedTextureARB
    /// * `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTexImage3D(
      &self, target: GLenum, level: GLint, internalformat: GLenum,
      width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint,
      imageSize: GLsizei, data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTexImage3D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, height, depth, border, imageSize, data);
      }
      let out = call_atomic_ptr_9arg(
        "glCompressedTexImage3D",
        &self.glCompressedTexImage3D_p,
        target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        imageSize,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCompressedTexImage3D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CompressedTexImage3D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCompressedTexImage3D\0",
        &self.glCompressedTexImage3D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTexImage3D_is_loaded(&self) -> bool {
      !self.glCompressedTexImage3D_p.load(RELAX).is_null()
    }
    /// [glCompressedTexSubImage1D](http://docs.gl/gl3/glCompressedTexSubImage1D)(target, level, xoffset, width, format, imageSize, data)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `data` group: CompressedTextureARB
    /// * `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTexSubImage1D(
      &self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei,
      format: GLenum, imageSize: GLsizei, data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, width, format, imageSize, data);
      }
      let out = call_atomic_ptr_7arg(
        "glCompressedTexSubImage1D",
        &self.glCompressedTexSubImage1D_p,
        target,
        level,
        xoffset,
        width,
        format,
        imageSize,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCompressedTexSubImage1D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CompressedTexSubImage1D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCompressedTexSubImage1D\0",
        &self.glCompressedTexSubImage1D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTexSubImage1D_is_loaded(&self) -> bool {
      !self.glCompressedTexSubImage1D_p.load(RELAX).is_null()
    }
    /// [glCompressedTexSubImage2D](http://docs.gl/gl3/glCompressedTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, imageSize, data)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `yoffset` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `data` group: CompressedTextureARB
    /// * `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTexSubImage2D(
      &self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,
      width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, yoffset, width, height, format, imageSize, data);
      }
      let out = call_atomic_ptr_9arg(
        "glCompressedTexSubImage2D",
        &self.glCompressedTexSubImage2D_p,
        target,
        level,
        xoffset,
        yoffset,
        width,
        height,
        format,
        imageSize,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCompressedTexSubImage2D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CompressedTexSubImage2D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCompressedTexSubImage2D\0",
        &self.glCompressedTexSubImage2D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTexSubImage2D_is_loaded(&self) -> bool {
      !self.glCompressedTexSubImage2D_p.load(RELAX).is_null()
    }
    /// [glCompressedTexSubImage3D](http://docs.gl/gl3/glCompressedTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `yoffset` group: CheckedInt32
    /// * `zoffset` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `data` group: CompressedTextureARB
    /// * `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTexSubImage3D(
      &self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,
      zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei,
      format: GLenum, imageSize: GLsizei, data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
      }
      let out = call_atomic_ptr_11arg(
        "glCompressedTexSubImage3D",
        &self.glCompressedTexSubImage3D_p,
        target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        imageSize,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCompressedTexSubImage3D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CompressedTexSubImage3D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCompressedTexSubImage3D\0",
        &self.glCompressedTexSubImage3D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTexSubImage3D_is_loaded(&self) -> bool {
      !self.glCompressedTexSubImage3D_p.load(RELAX).is_null()
    }
    /// [glCopyBufferSubData](http://docs.gl/gl3/glCopyBufferSubData)(readTarget, writeTarget, readOffset, writeOffset, size)
    /// * `readTarget` group: CopyBufferSubDataTarget
    /// * `writeTarget` group: CopyBufferSubDataTarget
    /// * `readOffset` group: BufferOffset
    /// * `writeOffset` group: BufferOffset
    /// * `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyBufferSubData(
      &self, readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr,
      writeOffset: GLintptr, size: GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.CopyBufferSubData({:#X}, {:#X}, {:?}, {:?}, {:?});",
          readTarget,
          writeTarget,
          readOffset,
          writeOffset,
          size
        );
      }
      let out = call_atomic_ptr_5arg(
        "glCopyBufferSubData",
        &self.glCopyBufferSubData_p,
        readTarget,
        writeTarget,
        readOffset,
        writeOffset,
        size,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCopyBufferSubData");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CopyBufferSubData_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCopyBufferSubData\0",
        &self.glCopyBufferSubData_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyBufferSubData_is_loaded(&self) -> bool {
      !self.glCopyBufferSubData_p.load(RELAX).is_null()
    }
    /// [glCopyTexImage1D](http://docs.gl/gl3/glCopyTexImage1D)(target, level, internalformat, x, y, width, border)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    /// * `border` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTexImage1D(
      &self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint,
      y: GLint, width: GLsizei, border: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CopyTexImage1D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", target, level, internalformat, x, y, width, border);
      }
      let out = call_atomic_ptr_7arg(
        "glCopyTexImage1D",
        &self.glCopyTexImage1D_p,
        target,
        level,
        internalformat,
        x,
        y,
        width,
        border,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCopyTexImage1D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CopyTexImage1D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCopyTexImage1D\0",
        &self.glCopyTexImage1D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTexImage1D_is_loaded(&self) -> bool {
      !self.glCopyTexImage1D_p.load(RELAX).is_null()
    }
    /// [glCopyTexImage2D](http://docs.gl/gl3/glCopyTexImage2D)(target, level, internalformat, x, y, width, height, border)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    /// * `border` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTexImage2D(
      &self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint,
      y: GLint, width: GLsizei, height: GLsizei, border: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CopyTexImage2D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, internalformat, x, y, width, height, border);
      }
      let out = call_atomic_ptr_8arg(
        "glCopyTexImage2D",
        &self.glCopyTexImage2D_p,
        target,
        level,
        internalformat,
        x,
        y,
        width,
        height,
        border,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCopyTexImage2D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CopyTexImage2D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCopyTexImage2D\0",
        &self.glCopyTexImage2D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTexImage2D_is_loaded(&self) -> bool {
      !self.glCopyTexImage2D_p.load(RELAX).is_null()
    }
    /// [glCopyTexSubImage1D](http://docs.gl/gl3/glCopyTexSubImage1D)(target, level, xoffset, x, y, width)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTexSubImage1D(
      &self, target: GLenum, level: GLint, xoffset: GLint, x: GLint, y: GLint,
      width: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.CopyTexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
          target,
          level,
          xoffset,
          x,
          y,
          width
        );
      }
      let out = call_atomic_ptr_6arg(
        "glCopyTexSubImage1D",
        &self.glCopyTexSubImage1D_p,
        target,
        level,
        xoffset,
        x,
        y,
        width,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCopyTexSubImage1D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CopyTexSubImage1D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCopyTexSubImage1D\0",
        &self.glCopyTexSubImage1D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTexSubImage1D_is_loaded(&self) -> bool {
      !self.glCopyTexSubImage1D_p.load(RELAX).is_null()
    }
    /// [glCopyTexSubImage2D](http://docs.gl/gl3/glCopyTexSubImage2D)(target, level, xoffset, yoffset, x, y, width, height)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `yoffset` group: CheckedInt32
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTexSubImage2D(
      &self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,
      x: GLint, y: GLint, width: GLsizei, height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CopyTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, xoffset, yoffset, x, y, width, height);
      }
      let out = call_atomic_ptr_8arg(
        "glCopyTexSubImage2D",
        &self.glCopyTexSubImage2D_p,
        target,
        level,
        xoffset,
        yoffset,
        x,
        y,
        width,
        height,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCopyTexSubImage2D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CopyTexSubImage2D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCopyTexSubImage2D\0",
        &self.glCopyTexSubImage2D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTexSubImage2D_is_loaded(&self) -> bool {
      !self.glCopyTexSubImage2D_p.load(RELAX).is_null()
    }
    /// [glCopyTexSubImage3D](http://docs.gl/gl3/glCopyTexSubImage3D)(target, level, xoffset, yoffset, zoffset, x, y, width, height)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `yoffset` group: CheckedInt32
    /// * `zoffset` group: CheckedInt32
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTexSubImage3D(
      &self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,
      zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CopyTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, xoffset, yoffset, zoffset, x, y, width, height);
      }
      let out = call_atomic_ptr_9arg(
        "glCopyTexSubImage3D",
        &self.glCopyTexSubImage3D_p,
        target,
        level,
        xoffset,
        yoffset,
        zoffset,
        x,
        y,
        width,
        height,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCopyTexSubImage3D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CopyTexSubImage3D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCopyTexSubImage3D\0",
        &self.glCopyTexSubImage3D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTexSubImage3D_is_loaded(&self) -> bool {
      !self.glCopyTexSubImage3D_p.load(RELAX).is_null()
    }
    /// [glCreateProgram](http://docs.gl/gl3/glCreateProgram)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateProgram(&self) -> GLuint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CreateProgram();",);
      }
      let out =
        call_atomic_ptr_0arg("glCreateProgram", &self.glCreateProgram_p);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCreateProgram");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CreateProgram_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCreateProgram\0",
        &self.glCreateProgram_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateProgram_is_loaded(&self) -> bool {
      !self.glCreateProgram_p.load(RELAX).is_null()
    }
    /// [glCreateShader](http://docs.gl/gl3/glCreateShader)(type_)
    /// * `type_` group: ShaderType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateShader(&self, type_: GLenum) -> GLuint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CreateShader({:#X});", type_);
      }
      let out =
        call_atomic_ptr_1arg("glCreateShader", &self.glCreateShader_p, type_);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCreateShader");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CreateShader_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCreateShader\0",
        &self.glCreateShader_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateShader_is_loaded(&self) -> bool {
      !self.glCreateShader_p.load(RELAX).is_null()
    }
    /// [glCullFace](http://docs.gl/gl3/glCullFace)(mode)
    /// * `mode` group: CullFaceMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CullFace(&self, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CullFace({:#X});", mode);
      }
      let out = call_atomic_ptr_1arg("glCullFace", &self.glCullFace_p, mode);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glCullFace");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn CullFace_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glCullFace\0",
        &self.glCullFace_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn CullFace_is_loaded(&self) -> bool {
      !self.glCullFace_p.load(RELAX).is_null()
    }
    /// [glDebugMessageCallback](http://docs.gl/gl3/glDebugMessageCallback)(callback, userParam)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn DebugMessageCallback(
      &self, callback: GLDEBUGPROC, userParam: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DebugMessageCallback({:?}, {:p});",
          transmute::<_, Option<fn()>>(callback),
          userParam
        );
      }
      let out = call_atomic_ptr_2arg(
        "glDebugMessageCallback",
        &self.glDebugMessageCallback_p,
        callback,
        userParam,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDebugMessageCallback");
      }
      out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    #[doc(hidden)]
    pub unsafe fn DebugMessageCallback_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDebugMessageCallback\0",
        &self.glDebugMessageCallback_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn DebugMessageCallback_is_loaded(&self) -> bool {
      !self.glDebugMessageCallback_p.load(RELAX).is_null()
    }
    /// [glDebugMessageCallbackARB](http://docs.gl/gl3/glDebugMessageCallbackARB)(callback, userParam)
    /// * `userParam` len: COMPSIZE(callback)
    /// * alias of: [`glDebugMessageCallback`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    pub unsafe fn DebugMessageCallbackARB(
      &self, callback: GLDEBUGPROCARB, userParam: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DebugMessageCallbackARB({:?}, {:p});",
          transmute::<_, Option<fn()>>(callback),
          userParam
        );
      }
      let out = call_atomic_ptr_2arg(
        "glDebugMessageCallbackARB",
        &self.glDebugMessageCallbackARB_p,
        callback,
        userParam,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDebugMessageCallbackARB");
      }
      out
    }
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    #[doc(hidden)]
    pub unsafe fn DebugMessageCallbackARB_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDebugMessageCallbackARB\0",
        &self.glDebugMessageCallbackARB_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    pub fn DebugMessageCallbackARB_is_loaded(&self) -> bool {
      !self.glDebugMessageCallbackARB_p.load(RELAX).is_null()
    }
    /// [glDebugMessageControl](http://docs.gl/gl3/glDebugMessageControl)(source, type_, severity, count, ids, enabled)
    /// * `source` group: DebugSource
    /// * `type_` group: DebugType
    /// * `severity` group: DebugSeverity
    /// * `ids` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn DebugMessageControl(
      &self, source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei,
      ids: *const GLuint, enabled: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DebugMessageControl({:#X}, {:#X}, {:#X}, {:?}, {:p}, {:?});", source, type_, severity, count, ids, enabled);
      }
      let out = call_atomic_ptr_6arg(
        "glDebugMessageControl",
        &self.glDebugMessageControl_p,
        source,
        type_,
        severity,
        count,
        ids,
        enabled,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDebugMessageControl");
      }
      out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    #[doc(hidden)]
    pub unsafe fn DebugMessageControl_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDebugMessageControl\0",
        &self.glDebugMessageControl_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn DebugMessageControl_is_loaded(&self) -> bool {
      !self.glDebugMessageControl_p.load(RELAX).is_null()
    }
    /// [glDebugMessageControlARB](http://docs.gl/gl3/glDebugMessageControlARB)(source, type_, severity, count, ids, enabled)
    /// * `source` group: DebugSource
    /// * `type_` group: DebugType
    /// * `severity` group: DebugSeverity
    /// * `ids` len: count
    /// * alias of: [`glDebugMessageControl`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    pub unsafe fn DebugMessageControlARB(
      &self, source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei,
      ids: *const GLuint, enabled: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DebugMessageControlARB({:#X}, {:#X}, {:#X}, {:?}, {:p}, {:?});", source, type_, severity, count, ids, enabled);
      }
      let out = call_atomic_ptr_6arg(
        "glDebugMessageControlARB",
        &self.glDebugMessageControlARB_p,
        source,
        type_,
        severity,
        count,
        ids,
        enabled,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDebugMessageControlARB");
      }
      out
    }
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    #[doc(hidden)]
    pub unsafe fn DebugMessageControlARB_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDebugMessageControlARB\0",
        &self.glDebugMessageControlARB_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    pub fn DebugMessageControlARB_is_loaded(&self) -> bool {
      !self.glDebugMessageControlARB_p.load(RELAX).is_null()
    }
    /// [glDebugMessageInsert](http://docs.gl/gl3/glDebugMessageInsert)(source, type_, id, severity, length, buf)
    /// * `source` group: DebugSource
    /// * `type_` group: DebugType
    /// * `severity` group: DebugSeverity
    /// * `buf` len: COMPSIZE(buf,length)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn DebugMessageInsert(
      &self, source: GLenum, type_: GLenum, id: GLuint, severity: GLenum,
      length: GLsizei, buf: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DebugMessageInsert({:#X}, {:#X}, {:?}, {:#X}, {:?}, {:p});", source, type_, id, severity, length, buf);
      }
      let out = call_atomic_ptr_6arg(
        "glDebugMessageInsert",
        &self.glDebugMessageInsert_p,
        source,
        type_,
        id,
        severity,
        length,
        buf,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDebugMessageInsert");
      }
      out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    #[doc(hidden)]
    pub unsafe fn DebugMessageInsert_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDebugMessageInsert\0",
        &self.glDebugMessageInsert_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn DebugMessageInsert_is_loaded(&self) -> bool {
      !self.glDebugMessageInsert_p.load(RELAX).is_null()
    }
    /// [glDebugMessageInsertARB](http://docs.gl/gl3/glDebugMessageInsertARB)(source, type_, id, severity, length, buf)
    /// * `source` group: DebugSource
    /// * `type_` group: DebugType
    /// * `severity` group: DebugSeverity
    /// * `buf` len: length
    /// * alias of: [`glDebugMessageInsert`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    pub unsafe fn DebugMessageInsertARB(
      &self, source: GLenum, type_: GLenum, id: GLuint, severity: GLenum,
      length: GLsizei, buf: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DebugMessageInsertARB({:#X}, {:#X}, {:?}, {:#X}, {:?}, {:p});", source, type_, id, severity, length, buf);
      }
      let out = call_atomic_ptr_6arg(
        "glDebugMessageInsertARB",
        &self.glDebugMessageInsertARB_p,
        source,
        type_,
        id,
        severity,
        length,
        buf,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDebugMessageInsertARB");
      }
      out
    }
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    #[doc(hidden)]
    pub unsafe fn DebugMessageInsertARB_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDebugMessageInsertARB\0",
        &self.glDebugMessageInsertARB_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    pub fn DebugMessageInsertARB_is_loaded(&self) -> bool {
      !self.glDebugMessageInsertARB_p.load(RELAX).is_null()
    }
    /// [glDeleteBuffers](http://docs.gl/gl3/glDeleteBuffers)(n, buffers)
    /// * `buffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteBuffers(&self, n: GLsizei, buffers: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteBuffers({:?}, {:p});", n, buffers);
      }
      let out = call_atomic_ptr_2arg(
        "glDeleteBuffers",
        &self.glDeleteBuffers_p,
        n,
        buffers,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDeleteBuffers");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DeleteBuffers_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDeleteBuffers\0",
        &self.glDeleteBuffers_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteBuffers_is_loaded(&self) -> bool {
      !self.glDeleteBuffers_p.load(RELAX).is_null()
    }
    /// [glDeleteFramebuffers](http://docs.gl/gl3/glDeleteFramebuffers)(n, framebuffers)
    /// * `framebuffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteFramebuffers(
      &self, n: GLsizei, framebuffers: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteFramebuffers({:?}, {:p});", n, framebuffers);
      }
      let out = call_atomic_ptr_2arg(
        "glDeleteFramebuffers",
        &self.glDeleteFramebuffers_p,
        n,
        framebuffers,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDeleteFramebuffers");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DeleteFramebuffers_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDeleteFramebuffers\0",
        &self.glDeleteFramebuffers_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteFramebuffers_is_loaded(&self) -> bool {
      !self.glDeleteFramebuffers_p.load(RELAX).is_null()
    }
    /// [glDeleteProgram](http://docs.gl/gl3/glDeleteProgram)(program)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteProgram(&self, program: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteProgram({:?});", program);
      }
      let out = call_atomic_ptr_1arg(
        "glDeleteProgram",
        &self.glDeleteProgram_p,
        program,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDeleteProgram");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DeleteProgram_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDeleteProgram\0",
        &self.glDeleteProgram_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteProgram_is_loaded(&self) -> bool {
      !self.glDeleteProgram_p.load(RELAX).is_null()
    }
    /// [glDeleteQueries](http://docs.gl/gl3/glDeleteQueries)(n, ids)
    /// * `ids` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteQueries(&self, n: GLsizei, ids: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteQueries({:?}, {:p});", n, ids);
      }
      let out = call_atomic_ptr_2arg(
        "glDeleteQueries",
        &self.glDeleteQueries_p,
        n,
        ids,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDeleteQueries");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DeleteQueries_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDeleteQueries\0",
        &self.glDeleteQueries_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteQueries_is_loaded(&self) -> bool {
      !self.glDeleteQueries_p.load(RELAX).is_null()
    }
    /// [glDeleteRenderbuffers](http://docs.gl/gl3/glDeleteRenderbuffers)(n, renderbuffers)
    /// * `renderbuffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteRenderbuffers(
      &self, n: GLsizei, renderbuffers: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteRenderbuffers({:?}, {:p});", n, renderbuffers);
      }
      let out = call_atomic_ptr_2arg(
        "glDeleteRenderbuffers",
        &self.glDeleteRenderbuffers_p,
        n,
        renderbuffers,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDeleteRenderbuffers");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DeleteRenderbuffers_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDeleteRenderbuffers\0",
        &self.glDeleteRenderbuffers_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteRenderbuffers_is_loaded(&self) -> bool {
      !self.glDeleteRenderbuffers_p.load(RELAX).is_null()
    }
    /// [glDeleteSamplers](http://docs.gl/gl3/glDeleteSamplers)(count, samplers)
    /// * `samplers` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteSamplers(
      &self, count: GLsizei, samplers: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteSamplers({:?}, {:p});", count, samplers);
      }
      let out = call_atomic_ptr_2arg(
        "glDeleteSamplers",
        &self.glDeleteSamplers_p,
        count,
        samplers,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDeleteSamplers");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DeleteSamplers_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDeleteSamplers\0",
        &self.glDeleteSamplers_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteSamplers_is_loaded(&self) -> bool {
      !self.glDeleteSamplers_p.load(RELAX).is_null()
    }
    /// [glDeleteShader](http://docs.gl/gl3/glDeleteShader)(shader)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteShader(&self, shader: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteShader({:?});", shader);
      }
      let out =
        call_atomic_ptr_1arg("glDeleteShader", &self.glDeleteShader_p, shader);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDeleteShader");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DeleteShader_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDeleteShader\0",
        &self.glDeleteShader_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteShader_is_loaded(&self) -> bool {
      !self.glDeleteShader_p.load(RELAX).is_null()
    }
    /// [glDeleteSync](http://docs.gl/gl3/glDeleteSync)(sync)
    /// * `sync` group: sync
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteSync(&self, sync: GLsync) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteSync({:p});", sync);
      }
      let out =
        call_atomic_ptr_1arg("glDeleteSync", &self.glDeleteSync_p, sync);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDeleteSync");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DeleteSync_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDeleteSync\0",
        &self.glDeleteSync_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteSync_is_loaded(&self) -> bool {
      !self.glDeleteSync_p.load(RELAX).is_null()
    }
    /// [glDeleteTextures](http://docs.gl/gl3/glDeleteTextures)(n, textures)
    /// * `textures` group: Texture
    /// * `textures` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteTextures(&self, n: GLsizei, textures: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteTextures({:?}, {:p});", n, textures);
      }
      let out = call_atomic_ptr_2arg(
        "glDeleteTextures",
        &self.glDeleteTextures_p,
        n,
        textures,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDeleteTextures");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DeleteTextures_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDeleteTextures\0",
        &self.glDeleteTextures_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteTextures_is_loaded(&self) -> bool {
      !self.glDeleteTextures_p.load(RELAX).is_null()
    }
    /// [glDeleteVertexArrays](http://docs.gl/gl3/glDeleteVertexArrays)(n, arrays)
    /// * `arrays` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteVertexArrays(&self, n: GLsizei, arrays: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteVertexArrays({:?}, {:p});", n, arrays);
      }
      let out = call_atomic_ptr_2arg(
        "glDeleteVertexArrays",
        &self.glDeleteVertexArrays_p,
        n,
        arrays,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDeleteVertexArrays");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DeleteVertexArrays_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDeleteVertexArrays\0",
        &self.glDeleteVertexArrays_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteVertexArrays_is_loaded(&self) -> bool {
      !self.glDeleteVertexArrays_p.load(RELAX).is_null()
    }
    /// [glDepthFunc](http://docs.gl/gl3/glDepthFunc)(func)
    /// * `func` group: DepthFunction
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DepthFunc(&self, func: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DepthFunc({:#X});", func);
      }
      let out = call_atomic_ptr_1arg("glDepthFunc", &self.glDepthFunc_p, func);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDepthFunc");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DepthFunc_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDepthFunc\0",
        &self.glDepthFunc_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DepthFunc_is_loaded(&self) -> bool {
      !self.glDepthFunc_p.load(RELAX).is_null()
    }
    /// [glDepthMask](http://docs.gl/gl3/glDepthMask)(flag)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DepthMask(&self, flag: GLboolean) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DepthMask({:?});", flag);
      }
      let out = call_atomic_ptr_1arg("glDepthMask", &self.glDepthMask_p, flag);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDepthMask");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DepthMask_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDepthMask\0",
        &self.glDepthMask_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DepthMask_is_loaded(&self) -> bool {
      !self.glDepthMask_p.load(RELAX).is_null()
    }
    /// [glDepthRange](http://docs.gl/gl3/glDepthRange)(n, f)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DepthRange(&self, n: GLdouble, f: GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DepthRange({:?}, {:?});", n, f);
      }
      let out =
        call_atomic_ptr_2arg("glDepthRange", &self.glDepthRange_p, n, f);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDepthRange");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DepthRange_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDepthRange\0",
        &self.glDepthRange_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DepthRange_is_loaded(&self) -> bool {
      !self.glDepthRange_p.load(RELAX).is_null()
    }
    /// [glDetachShader](http://docs.gl/gl3/glDetachShader)(program, shader)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DetachShader(&self, program: GLuint, shader: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DetachShader({:?}, {:?});", program, shader);
      }
      let out = call_atomic_ptr_2arg(
        "glDetachShader",
        &self.glDetachShader_p,
        program,
        shader,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDetachShader");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DetachShader_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDetachShader\0",
        &self.glDetachShader_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DetachShader_is_loaded(&self) -> bool {
      !self.glDetachShader_p.load(RELAX).is_null()
    }
    /// [glDisable](http://docs.gl/gl3/glDisable)(cap)
    /// * `cap` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Disable(&self, cap: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Disable({:#X});", cap);
      }
      let out = call_atomic_ptr_1arg("glDisable", &self.glDisable_p, cap);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDisable");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Disable_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDisable\0",
        &self.glDisable_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Disable_is_loaded(&self) -> bool {
      !self.glDisable_p.load(RELAX).is_null()
    }
    /// [glDisableVertexAttribArray](http://docs.gl/gl3/glDisableVertexAttribArray)(index)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DisableVertexAttribArray(&self, index: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DisableVertexAttribArray({:?});", index);
      }
      let out = call_atomic_ptr_1arg(
        "glDisableVertexAttribArray",
        &self.glDisableVertexAttribArray_p,
        index,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDisableVertexAttribArray");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DisableVertexAttribArray_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDisableVertexAttribArray\0",
        &self.glDisableVertexAttribArray_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DisableVertexAttribArray_is_loaded(&self) -> bool {
      !self.glDisableVertexAttribArray_p.load(RELAX).is_null()
    }
    /// [glDisablei](http://docs.gl/gl3/glDisable)(target, index)
    /// * `target` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Disablei(&self, target: GLenum, index: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Disablei({:#X}, {:?});", target, index);
      }
      let out =
        call_atomic_ptr_2arg("glDisablei", &self.glDisablei_p, target, index);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDisablei");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Disablei_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDisablei\0",
        &self.glDisablei_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Disablei_is_loaded(&self) -> bool {
      !self.glDisablei_p.load(RELAX).is_null()
    }
    /// [glDrawArrays](http://docs.gl/gl3/glDrawArrays)(mode, first, count)
    /// * `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawArrays(
      &self, mode: GLenum, first: GLint, count: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawArrays({:#X}, {:?}, {:?});", mode, first, count);
      }
      let out = call_atomic_ptr_3arg(
        "glDrawArrays",
        &self.glDrawArrays_p,
        mode,
        first,
        count,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDrawArrays");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DrawArrays_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDrawArrays\0",
        &self.glDrawArrays_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawArrays_is_loaded(&self) -> bool {
      !self.glDrawArrays_p.load(RELAX).is_null()
    }
    /// [glDrawArraysInstanced](http://docs.gl/gl3/glDrawArraysInstanced)(mode, first, count, instancecount)
    /// * `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawArraysInstanced(
      &self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawArraysInstanced({:#X}, {:?}, {:?}, {:?});",
          mode,
          first,
          count,
          instancecount
        );
      }
      let out = call_atomic_ptr_4arg(
        "glDrawArraysInstanced",
        &self.glDrawArraysInstanced_p,
        mode,
        first,
        count,
        instancecount,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDrawArraysInstanced");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DrawArraysInstanced_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDrawArraysInstanced\0",
        &self.glDrawArraysInstanced_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawArraysInstanced_is_loaded(&self) -> bool {
      !self.glDrawArraysInstanced_p.load(RELAX).is_null()
    }
    /// [glDrawBuffer](http://docs.gl/gl3/glDrawBuffer)(buf)
    /// * `buf` group: DrawBufferMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawBuffer(&self, buf: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawBuffer({:#X});", buf);
      }
      let out = call_atomic_ptr_1arg("glDrawBuffer", &self.glDrawBuffer_p, buf);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDrawBuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DrawBuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDrawBuffer\0",
        &self.glDrawBuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawBuffer_is_loaded(&self) -> bool {
      !self.glDrawBuffer_p.load(RELAX).is_null()
    }
    /// [glDrawBuffers](http://docs.gl/gl3/glDrawBuffers)(n, bufs)
    /// * `bufs` group: DrawBufferMode
    /// * `bufs` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawBuffers(&self, n: GLsizei, bufs: *const GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawBuffers({:?}, {:p});", n, bufs);
      }
      let out =
        call_atomic_ptr_2arg("glDrawBuffers", &self.glDrawBuffers_p, n, bufs);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDrawBuffers");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DrawBuffers_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDrawBuffers\0",
        &self.glDrawBuffers_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawBuffers_is_loaded(&self) -> bool {
      !self.glDrawBuffers_p.load(RELAX).is_null()
    }
    /// [glDrawElements](http://docs.gl/gl3/glDrawElements)(mode, count, type_, indices)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawElements(
      &self, mode: GLenum, count: GLsizei, type_: GLenum,
      indices: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawElements({:#X}, {:?}, {:#X}, {:p});",
          mode,
          count,
          type_,
          indices
        );
      }
      let out = call_atomic_ptr_4arg(
        "glDrawElements",
        &self.glDrawElements_p,
        mode,
        count,
        type_,
        indices,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDrawElements");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DrawElements_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDrawElements\0",
        &self.glDrawElements_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawElements_is_loaded(&self) -> bool {
      !self.glDrawElements_p.load(RELAX).is_null()
    }
    /// [glDrawElementsBaseVertex](http://docs.gl/gl3/glDrawElementsBaseVertex)(mode, count, type_, indices, basevertex)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawElementsBaseVertex(
      &self, mode: GLenum, count: GLsizei, type_: GLenum,
      indices: *const c_void, basevertex: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawElementsBaseVertex({:#X}, {:?}, {:#X}, {:p}, {:?});",
          mode,
          count,
          type_,
          indices,
          basevertex
        );
      }
      let out = call_atomic_ptr_5arg(
        "glDrawElementsBaseVertex",
        &self.glDrawElementsBaseVertex_p,
        mode,
        count,
        type_,
        indices,
        basevertex,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDrawElementsBaseVertex");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DrawElementsBaseVertex_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDrawElementsBaseVertex\0",
        &self.glDrawElementsBaseVertex_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawElementsBaseVertex_is_loaded(&self) -> bool {
      !self.glDrawElementsBaseVertex_p.load(RELAX).is_null()
    }
    /// [glDrawElementsInstanced](http://docs.gl/gl3/glDrawElementsInstanced)(mode, count, type_, indices, instancecount)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawElementsInstanced(
      &self, mode: GLenum, count: GLsizei, type_: GLenum,
      indices: *const c_void, instancecount: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawElementsInstanced({:#X}, {:?}, {:#X}, {:p}, {:?});",
          mode,
          count,
          type_,
          indices,
          instancecount
        );
      }
      let out = call_atomic_ptr_5arg(
        "glDrawElementsInstanced",
        &self.glDrawElementsInstanced_p,
        mode,
        count,
        type_,
        indices,
        instancecount,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDrawElementsInstanced");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DrawElementsInstanced_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDrawElementsInstanced\0",
        &self.glDrawElementsInstanced_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawElementsInstanced_is_loaded(&self) -> bool {
      !self.glDrawElementsInstanced_p.load(RELAX).is_null()
    }
    /// [glDrawElementsInstancedBaseVertex](http://docs.gl/gl3/glDrawElementsInstancedBaseVertex)(mode, count, type_, indices, instancecount, basevertex)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawElementsInstancedBaseVertex(
      &self, mode: GLenum, count: GLsizei, type_: GLenum,
      indices: *const c_void, instancecount: GLsizei, basevertex: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawElementsInstancedBaseVertex({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?});", mode, count, type_, indices, instancecount, basevertex);
      }
      let out = call_atomic_ptr_6arg(
        "glDrawElementsInstancedBaseVertex",
        &self.glDrawElementsInstancedBaseVertex_p,
        mode,
        count,
        type_,
        indices,
        instancecount,
        basevertex,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDrawElementsInstancedBaseVertex");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DrawElementsInstancedBaseVertex_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDrawElementsInstancedBaseVertex\0",
        &self.glDrawElementsInstancedBaseVertex_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawElementsInstancedBaseVertex_is_loaded(&self) -> bool {
      !self.glDrawElementsInstancedBaseVertex_p.load(RELAX).is_null()
    }
    /// [glDrawRangeElements](http://docs.gl/gl3/glDrawRangeElements)(mode, start, end, count, type_, indices)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawRangeElements(
      &self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei,
      type_: GLenum, indices: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawRangeElements({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p});",
          mode,
          start,
          end,
          count,
          type_,
          indices
        );
      }
      let out = call_atomic_ptr_6arg(
        "glDrawRangeElements",
        &self.glDrawRangeElements_p,
        mode,
        start,
        end,
        count,
        type_,
        indices,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDrawRangeElements");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DrawRangeElements_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDrawRangeElements\0",
        &self.glDrawRangeElements_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawRangeElements_is_loaded(&self) -> bool {
      !self.glDrawRangeElements_p.load(RELAX).is_null()
    }
    /// [glDrawRangeElementsBaseVertex](http://docs.gl/gl3/glDrawRangeElementsBaseVertex)(mode, start, end, count, type_, indices, basevertex)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawRangeElementsBaseVertex(
      &self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei,
      type_: GLenum, indices: *const c_void, basevertex: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawRangeElementsBaseVertex({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p}, {:?});", mode, start, end, count, type_, indices, basevertex);
      }
      let out = call_atomic_ptr_7arg(
        "glDrawRangeElementsBaseVertex",
        &self.glDrawRangeElementsBaseVertex_p,
        mode,
        start,
        end,
        count,
        type_,
        indices,
        basevertex,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glDrawRangeElementsBaseVertex");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn DrawRangeElementsBaseVertex_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glDrawRangeElementsBaseVertex\0",
        &self.glDrawRangeElementsBaseVertex_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawRangeElementsBaseVertex_is_loaded(&self) -> bool {
      !self.glDrawRangeElementsBaseVertex_p.load(RELAX).is_null()
    }
    /// [glEnable](http://docs.gl/gl3/glEnable)(cap)
    /// * `cap` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Enable(&self, cap: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Enable({:#X});", cap);
      }
      let out = call_atomic_ptr_1arg("glEnable", &self.glEnable_p, cap);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glEnable");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Enable_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glEnable\0",
        &self.glEnable_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Enable_is_loaded(&self) -> bool {
      !self.glEnable_p.load(RELAX).is_null()
    }
    /// [glEnableVertexAttribArray](http://docs.gl/gl3/glEnableVertexAttribArray)(index)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn EnableVertexAttribArray(&self, index: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.EnableVertexAttribArray({:?});", index);
      }
      let out = call_atomic_ptr_1arg(
        "glEnableVertexAttribArray",
        &self.glEnableVertexAttribArray_p,
        index,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glEnableVertexAttribArray");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn EnableVertexAttribArray_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glEnableVertexAttribArray\0",
        &self.glEnableVertexAttribArray_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn EnableVertexAttribArray_is_loaded(&self) -> bool {
      !self.glEnableVertexAttribArray_p.load(RELAX).is_null()
    }
    /// [glEnablei](http://docs.gl/gl3/glEnable)(target, index)
    /// * `target` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Enablei(&self, target: GLenum, index: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Enablei({:#X}, {:?});", target, index);
      }
      let out =
        call_atomic_ptr_2arg("glEnablei", &self.glEnablei_p, target, index);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glEnablei");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Enablei_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glEnablei\0",
        &self.glEnablei_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Enablei_is_loaded(&self) -> bool {
      !self.glEnablei_p.load(RELAX).is_null()
    }
    /// [glEndConditionalRender](http://docs.gl/gl3/glEndConditionalRender)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn EndConditionalRender(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.EndConditionalRender();",);
      }
      let out = call_atomic_ptr_0arg(
        "glEndConditionalRender",
        &self.glEndConditionalRender_p,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glEndConditionalRender");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn EndConditionalRender_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glEndConditionalRender\0",
        &self.glEndConditionalRender_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn EndConditionalRender_is_loaded(&self) -> bool {
      !self.glEndConditionalRender_p.load(RELAX).is_null()
    }
    /// [glEndQuery](http://docs.gl/gl3/glEndQuery)(target)
    /// * `target` group: QueryTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn EndQuery(&self, target: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.EndQuery({:#X});", target);
      }
      let out = call_atomic_ptr_1arg("glEndQuery", &self.glEndQuery_p, target);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glEndQuery");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn EndQuery_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glEndQuery\0",
        &self.glEndQuery_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn EndQuery_is_loaded(&self) -> bool {
      !self.glEndQuery_p.load(RELAX).is_null()
    }
    /// [glEndTransformFeedback](http://docs.gl/gl3/glEndTransformFeedback)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn EndTransformFeedback(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.EndTransformFeedback();",);
      }
      let out = call_atomic_ptr_0arg(
        "glEndTransformFeedback",
        &self.glEndTransformFeedback_p,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glEndTransformFeedback");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn EndTransformFeedback_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glEndTransformFeedback\0",
        &self.glEndTransformFeedback_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn EndTransformFeedback_is_loaded(&self) -> bool {
      !self.glEndTransformFeedback_p.load(RELAX).is_null()
    }
    /// [glFenceSync](http://docs.gl/gl3/glFenceSync)(condition, flags)
    /// * `condition` group: SyncCondition
    /// * return value group: sync
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FenceSync(
      &self, condition: GLenum, flags: GLbitfield,
    ) -> GLsync {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.FenceSync({:#X}, {:?});", condition, flags);
      }
      let out = call_atomic_ptr_2arg(
        "glFenceSync",
        &self.glFenceSync_p,
        condition,
        flags,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glFenceSync");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn FenceSync_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glFenceSync\0",
        &self.glFenceSync_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn FenceSync_is_loaded(&self) -> bool {
      !self.glFenceSync_p.load(RELAX).is_null()
    }
    /// [glFinish](http://docs.gl/gl3/glFinish)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Finish(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Finish();",);
      }
      let out = call_atomic_ptr_0arg("glFinish", &self.glFinish_p);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glFinish");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Finish_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glFinish\0",
        &self.glFinish_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Finish_is_loaded(&self) -> bool {
      !self.glFinish_p.load(RELAX).is_null()
    }
    /// [glFlush](http://docs.gl/gl3/glFlush)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Flush(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Flush();",);
      }
      let out = call_atomic_ptr_0arg("glFlush", &self.glFlush_p);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glFlush");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Flush_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(get_proc_address, b"glFlush\0", &self.glFlush_p)
    }
    #[inline]
    #[doc(hidden)]
    pub fn Flush_is_loaded(&self) -> bool {
      !self.glFlush_p.load(RELAX).is_null()
    }
    /// [glFlushMappedBufferRange](http://docs.gl/gl3/glFlushMappedBufferRange)(target, offset, length)
    /// * `target` group: BufferTargetARB
    /// * `offset` group: BufferOffset
    /// * `length` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FlushMappedBufferRange(
      &self, target: GLenum, offset: GLintptr, length: GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FlushMappedBufferRange({:#X}, {:?}, {:?});",
          target,
          offset,
          length
        );
      }
      let out = call_atomic_ptr_3arg(
        "glFlushMappedBufferRange",
        &self.glFlushMappedBufferRange_p,
        target,
        offset,
        length,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glFlushMappedBufferRange");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn FlushMappedBufferRange_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glFlushMappedBufferRange\0",
        &self.glFlushMappedBufferRange_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn FlushMappedBufferRange_is_loaded(&self) -> bool {
      !self.glFlushMappedBufferRange_p.load(RELAX).is_null()
    }
    /// [glFramebufferRenderbuffer](http://docs.gl/gl3/glFramebufferRenderbuffer)(target, attachment, renderbuffertarget, renderbuffer)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    /// * `renderbuffertarget` group: RenderbufferTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferRenderbuffer(
      &self, target: GLenum, attachment: GLenum, renderbuffertarget: GLenum,
      renderbuffer: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FramebufferRenderbuffer({:#X}, {:#X}, {:#X}, {:?});",
          target,
          attachment,
          renderbuffertarget,
          renderbuffer
        );
      }
      let out = call_atomic_ptr_4arg(
        "glFramebufferRenderbuffer",
        &self.glFramebufferRenderbuffer_p,
        target,
        attachment,
        renderbuffertarget,
        renderbuffer,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glFramebufferRenderbuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn FramebufferRenderbuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glFramebufferRenderbuffer\0",
        &self.glFramebufferRenderbuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferRenderbuffer_is_loaded(&self) -> bool {
      !self.glFramebufferRenderbuffer_p.load(RELAX).is_null()
    }
    /// [glFramebufferTexture](http://docs.gl/gl3/glFramebufferTexture)(target, attachment, texture, level)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferTexture(
      &self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FramebufferTexture({:#X}, {:#X}, {:?}, {:?});",
          target,
          attachment,
          texture,
          level
        );
      }
      let out = call_atomic_ptr_4arg(
        "glFramebufferTexture",
        &self.glFramebufferTexture_p,
        target,
        attachment,
        texture,
        level,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glFramebufferTexture");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn FramebufferTexture_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glFramebufferTexture\0",
        &self.glFramebufferTexture_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferTexture_is_loaded(&self) -> bool {
      !self.glFramebufferTexture_p.load(RELAX).is_null()
    }
    /// [glFramebufferTexture1D](http://docs.gl/gl3/glFramebufferTexture1D)(target, attachment, textarget, texture, level)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    /// * `textarget` group: TextureTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferTexture1D(
      &self, target: GLenum, attachment: GLenum, textarget: GLenum,
      texture: GLuint, level: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FramebufferTexture1D({:#X}, {:#X}, {:#X}, {:?}, {:?});",
          target,
          attachment,
          textarget,
          texture,
          level
        );
      }
      let out = call_atomic_ptr_5arg(
        "glFramebufferTexture1D",
        &self.glFramebufferTexture1D_p,
        target,
        attachment,
        textarget,
        texture,
        level,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glFramebufferTexture1D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn FramebufferTexture1D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glFramebufferTexture1D\0",
        &self.glFramebufferTexture1D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferTexture1D_is_loaded(&self) -> bool {
      !self.glFramebufferTexture1D_p.load(RELAX).is_null()
    }
    /// [glFramebufferTexture2D](http://docs.gl/gl3/glFramebufferTexture2D)(target, attachment, textarget, texture, level)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    /// * `textarget` group: TextureTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferTexture2D(
      &self, target: GLenum, attachment: GLenum, textarget: GLenum,
      texture: GLuint, level: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FramebufferTexture2D({:#X}, {:#X}, {:#X}, {:?}, {:?});",
          target,
          attachment,
          textarget,
          texture,
          level
        );
      }
      let out = call_atomic_ptr_5arg(
        "glFramebufferTexture2D",
        &self.glFramebufferTexture2D_p,
        target,
        attachment,
        textarget,
        texture,
        level,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glFramebufferTexture2D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn FramebufferTexture2D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glFramebufferTexture2D\0",
        &self.glFramebufferTexture2D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferTexture2D_is_loaded(&self) -> bool {
      !self.glFramebufferTexture2D_p.load(RELAX).is_null()
    }
    /// [glFramebufferTexture3D](http://docs.gl/gl3/glFramebufferTexture3D)(target, attachment, textarget, texture, level, zoffset)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    /// * `textarget` group: TextureTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferTexture3D(
      &self, target: GLenum, attachment: GLenum, textarget: GLenum,
      texture: GLuint, level: GLint, zoffset: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.FramebufferTexture3D({:#X}, {:#X}, {:#X}, {:?}, {:?}, {:?});", target, attachment, textarget, texture, level, zoffset);
      }
      let out = call_atomic_ptr_6arg(
        "glFramebufferTexture3D",
        &self.glFramebufferTexture3D_p,
        target,
        attachment,
        textarget,
        texture,
        level,
        zoffset,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glFramebufferTexture3D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn FramebufferTexture3D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glFramebufferTexture3D\0",
        &self.glFramebufferTexture3D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferTexture3D_is_loaded(&self) -> bool {
      !self.glFramebufferTexture3D_p.load(RELAX).is_null()
    }
    /// [glFramebufferTextureLayer](http://docs.gl/gl3/glFramebufferTextureLayer)(target, attachment, texture, level, layer)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    /// * `texture` group: Texture
    /// * `level` group: CheckedInt32
    /// * `layer` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferTextureLayer(
      &self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint,
      layer: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FramebufferTextureLayer({:#X}, {:#X}, {:?}, {:?}, {:?});",
          target,
          attachment,
          texture,
          level,
          layer
        );
      }
      let out = call_atomic_ptr_5arg(
        "glFramebufferTextureLayer",
        &self.glFramebufferTextureLayer_p,
        target,
        attachment,
        texture,
        level,
        layer,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glFramebufferTextureLayer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn FramebufferTextureLayer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glFramebufferTextureLayer\0",
        &self.glFramebufferTextureLayer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferTextureLayer_is_loaded(&self) -> bool {
      !self.glFramebufferTextureLayer_p.load(RELAX).is_null()
    }
    /// [glFrontFace](http://docs.gl/gl3/glFrontFace)(mode)
    /// * `mode` group: FrontFaceDirection
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FrontFace(&self, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.FrontFace({:#X});", mode);
      }
      let out = call_atomic_ptr_1arg("glFrontFace", &self.glFrontFace_p, mode);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glFrontFace");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn FrontFace_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glFrontFace\0",
        &self.glFrontFace_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn FrontFace_is_loaded(&self) -> bool {
      !self.glFrontFace_p.load(RELAX).is_null()
    }
    /// [glGenBuffers](http://docs.gl/gl3/glGenBuffers)(n, buffers)
    /// * `buffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenBuffers(&self, n: GLsizei, buffers: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenBuffers({:?}, {:p});", n, buffers);
      }
      let out =
        call_atomic_ptr_2arg("glGenBuffers", &self.glGenBuffers_p, n, buffers);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGenBuffers");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GenBuffers_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGenBuffers\0",
        &self.glGenBuffers_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenBuffers_is_loaded(&self) -> bool {
      !self.glGenBuffers_p.load(RELAX).is_null()
    }
    /// [glGenFramebuffers](http://docs.gl/gl3/glGenFramebuffers)(n, framebuffers)
    /// * `framebuffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenFramebuffers(
      &self, n: GLsizei, framebuffers: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenFramebuffers({:?}, {:p});", n, framebuffers);
      }
      let out = call_atomic_ptr_2arg(
        "glGenFramebuffers",
        &self.glGenFramebuffers_p,
        n,
        framebuffers,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGenFramebuffers");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GenFramebuffers_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGenFramebuffers\0",
        &self.glGenFramebuffers_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenFramebuffers_is_loaded(&self) -> bool {
      !self.glGenFramebuffers_p.load(RELAX).is_null()
    }
    /// [glGenQueries](http://docs.gl/gl3/glGenQueries)(n, ids)
    /// * `ids` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenQueries(&self, n: GLsizei, ids: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenQueries({:?}, {:p});", n, ids);
      }
      let out =
        call_atomic_ptr_2arg("glGenQueries", &self.glGenQueries_p, n, ids);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGenQueries");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GenQueries_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGenQueries\0",
        &self.glGenQueries_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenQueries_is_loaded(&self) -> bool {
      !self.glGenQueries_p.load(RELAX).is_null()
    }
    /// [glGenRenderbuffers](http://docs.gl/gl3/glGenRenderbuffers)(n, renderbuffers)
    /// * `renderbuffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenRenderbuffers(
      &self, n: GLsizei, renderbuffers: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenRenderbuffers({:?}, {:p});", n, renderbuffers);
      }
      let out = call_atomic_ptr_2arg(
        "glGenRenderbuffers",
        &self.glGenRenderbuffers_p,
        n,
        renderbuffers,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGenRenderbuffers");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GenRenderbuffers_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGenRenderbuffers\0",
        &self.glGenRenderbuffers_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenRenderbuffers_is_loaded(&self) -> bool {
      !self.glGenRenderbuffers_p.load(RELAX).is_null()
    }
    /// [glGenSamplers](http://docs.gl/gl3/glGenSamplers)(count, samplers)
    /// * `samplers` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenSamplers(&self, count: GLsizei, samplers: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenSamplers({:?}, {:p});", count, samplers);
      }
      let out = call_atomic_ptr_2arg(
        "glGenSamplers",
        &self.glGenSamplers_p,
        count,
        samplers,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGenSamplers");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GenSamplers_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGenSamplers\0",
        &self.glGenSamplers_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenSamplers_is_loaded(&self) -> bool {
      !self.glGenSamplers_p.load(RELAX).is_null()
    }
    /// [glGenTextures](http://docs.gl/gl3/glGenTextures)(n, textures)
    /// * `textures` group: Texture
    /// * `textures` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenTextures(&self, n: GLsizei, textures: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenTextures({:?}, {:p});", n, textures);
      }
      let out = call_atomic_ptr_2arg(
        "glGenTextures",
        &self.glGenTextures_p,
        n,
        textures,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGenTextures");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GenTextures_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGenTextures\0",
        &self.glGenTextures_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenTextures_is_loaded(&self) -> bool {
      !self.glGenTextures_p.load(RELAX).is_null()
    }
    /// [glGenVertexArrays](http://docs.gl/gl3/glGenVertexArrays)(n, arrays)
    /// * `arrays` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenVertexArrays({:?}, {:p});", n, arrays);
      }
      let out = call_atomic_ptr_2arg(
        "glGenVertexArrays",
        &self.glGenVertexArrays_p,
        n,
        arrays,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGenVertexArrays");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GenVertexArrays_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGenVertexArrays\0",
        &self.glGenVertexArrays_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenVertexArrays_is_loaded(&self) -> bool {
      !self.glGenVertexArrays_p.load(RELAX).is_null()
    }
    /// [glGenerateMipmap](http://docs.gl/gl3/glGenerateMipmap)(target)
    /// * `target` group: TextureTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenerateMipmap(&self, target: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenerateMipmap({:#X});", target);
      }
      let out = call_atomic_ptr_1arg(
        "glGenerateMipmap",
        &self.glGenerateMipmap_p,
        target,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGenerateMipmap");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GenerateMipmap_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGenerateMipmap\0",
        &self.glGenerateMipmap_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenerateMipmap_is_loaded(&self) -> bool {
      !self.glGenerateMipmap_p.load(RELAX).is_null()
    }
    /// [glGetActiveAttrib](http://docs.gl/gl3/glGetActiveAttrib)(program, index, bufSize, length, size, type_, name)
    /// * `length` len: 1
    /// * `size` len: 1
    /// * `type_` group: AttributeType
    /// * `type_` len: 1
    /// * `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveAttrib(
      &self, program: GLuint, index: GLuint, bufSize: GLsizei,
      length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum,
      name: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetActiveAttrib({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});", program, index, bufSize, length, size, type_, name);
      }
      let out = call_atomic_ptr_7arg(
        "glGetActiveAttrib",
        &self.glGetActiveAttrib_p,
        program,
        index,
        bufSize,
        length,
        size,
        type_,
        name,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetActiveAttrib");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetActiveAttrib_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetActiveAttrib\0",
        &self.glGetActiveAttrib_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveAttrib_is_loaded(&self) -> bool {
      !self.glGetActiveAttrib_p.load(RELAX).is_null()
    }
    /// [glGetActiveUniform](http://docs.gl/gl3/glGetActiveUniform)(program, index, bufSize, length, size, type_, name)
    /// * `length` len: 1
    /// * `size` len: 1
    /// * `type_` group: UniformType
    /// * `type_` len: 1
    /// * `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveUniform(
      &self, program: GLuint, index: GLuint, bufSize: GLsizei,
      length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum,
      name: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetActiveUniform({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});", program, index, bufSize, length, size, type_, name);
      }
      let out = call_atomic_ptr_7arg(
        "glGetActiveUniform",
        &self.glGetActiveUniform_p,
        program,
        index,
        bufSize,
        length,
        size,
        type_,
        name,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetActiveUniform");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetActiveUniform_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetActiveUniform\0",
        &self.glGetActiveUniform_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveUniform_is_loaded(&self) -> bool {
      !self.glGetActiveUniform_p.load(RELAX).is_null()
    }
    /// [glGetActiveUniformBlockName](http://docs.gl/gl3/glGetActiveUniformBlockName)(program, uniformBlockIndex, bufSize, length, uniformBlockName)
    /// * `length` len: 1
    /// * `uniformBlockName` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveUniformBlockName(
      &self, program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei,
      length: *mut GLsizei, uniformBlockName: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetActiveUniformBlockName({:?}, {:?}, {:?}, {:p}, {:p});",
          program,
          uniformBlockIndex,
          bufSize,
          length,
          uniformBlockName
        );
      }
      let out = call_atomic_ptr_5arg(
        "glGetActiveUniformBlockName",
        &self.glGetActiveUniformBlockName_p,
        program,
        uniformBlockIndex,
        bufSize,
        length,
        uniformBlockName,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetActiveUniformBlockName");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetActiveUniformBlockName_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetActiveUniformBlockName\0",
        &self.glGetActiveUniformBlockName_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveUniformBlockName_is_loaded(&self) -> bool {
      !self.glGetActiveUniformBlockName_p.load(RELAX).is_null()
    }
    /// [glGetActiveUniformBlockiv](http://docs.gl/gl3/glGetActiveUniformBlockiv)(program, uniformBlockIndex, pname, params)
    /// * `pname` group: UniformBlockPName
    /// * `params` len: COMPSIZE(program,uniformBlockIndex,pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveUniformBlockiv(
      &self, program: GLuint, uniformBlockIndex: GLuint, pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetActiveUniformBlockiv({:?}, {:?}, {:#X}, {:p});",
          program,
          uniformBlockIndex,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_4arg(
        "glGetActiveUniformBlockiv",
        &self.glGetActiveUniformBlockiv_p,
        program,
        uniformBlockIndex,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetActiveUniformBlockiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetActiveUniformBlockiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetActiveUniformBlockiv\0",
        &self.glGetActiveUniformBlockiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveUniformBlockiv_is_loaded(&self) -> bool {
      !self.glGetActiveUniformBlockiv_p.load(RELAX).is_null()
    }
    /// [glGetActiveUniformName](http://docs.gl/gl3/glGetActiveUniformName)(program, uniformIndex, bufSize, length, uniformName)
    /// * `length` len: 1
    /// * `uniformName` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveUniformName(
      &self, program: GLuint, uniformIndex: GLuint, bufSize: GLsizei,
      length: *mut GLsizei, uniformName: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetActiveUniformName({:?}, {:?}, {:?}, {:p}, {:p});",
          program,
          uniformIndex,
          bufSize,
          length,
          uniformName
        );
      }
      let out = call_atomic_ptr_5arg(
        "glGetActiveUniformName",
        &self.glGetActiveUniformName_p,
        program,
        uniformIndex,
        bufSize,
        length,
        uniformName,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetActiveUniformName");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetActiveUniformName_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetActiveUniformName\0",
        &self.glGetActiveUniformName_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveUniformName_is_loaded(&self) -> bool {
      !self.glGetActiveUniformName_p.load(RELAX).is_null()
    }
    /// [glGetActiveUniformsiv](http://docs.gl/gl3/glGetActiveUniformsiv)(program, uniformCount, uniformIndices, pname, params)
    /// * `uniformIndices` len: uniformCount
    /// * `pname` group: UniformPName
    /// * `params` len: COMPSIZE(uniformCount,pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveUniformsiv(
      &self, program: GLuint, uniformCount: GLsizei,
      uniformIndices: *const GLuint, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetActiveUniformsiv({:?}, {:?}, {:p}, {:#X}, {:p});",
          program,
          uniformCount,
          uniformIndices,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_5arg(
        "glGetActiveUniformsiv",
        &self.glGetActiveUniformsiv_p,
        program,
        uniformCount,
        uniformIndices,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetActiveUniformsiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetActiveUniformsiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetActiveUniformsiv\0",
        &self.glGetActiveUniformsiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveUniformsiv_is_loaded(&self) -> bool {
      !self.glGetActiveUniformsiv_p.load(RELAX).is_null()
    }
    /// [glGetAttachedShaders](http://docs.gl/gl3/glGetAttachedShaders)(program, maxCount, count, shaders)
    /// * `count` len: 1
    /// * `shaders` len: maxCount
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetAttachedShaders(
      &self, program: GLuint, maxCount: GLsizei, count: *mut GLsizei,
      shaders: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetAttachedShaders({:?}, {:?}, {:p}, {:p});",
          program,
          maxCount,
          count,
          shaders
        );
      }
      let out = call_atomic_ptr_4arg(
        "glGetAttachedShaders",
        &self.glGetAttachedShaders_p,
        program,
        maxCount,
        count,
        shaders,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetAttachedShaders");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetAttachedShaders_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetAttachedShaders\0",
        &self.glGetAttachedShaders_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetAttachedShaders_is_loaded(&self) -> bool {
      !self.glGetAttachedShaders_p.load(RELAX).is_null()
    }
    /// [glGetAttribLocation](http://docs.gl/gl3/glGetAttribLocation)(program, name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetAttribLocation(
      &self, program: GLuint, name: *const GLchar,
    ) -> GLint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetAttribLocation({:?}, {:p});", program, name);
      }
      let out = call_atomic_ptr_2arg(
        "glGetAttribLocation",
        &self.glGetAttribLocation_p,
        program,
        name,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetAttribLocation");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetAttribLocation_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetAttribLocation\0",
        &self.glGetAttribLocation_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetAttribLocation_is_loaded(&self) -> bool {
      !self.glGetAttribLocation_p.load(RELAX).is_null()
    }
    /// [glGetBooleani_v](http://docs.gl/gl3/glGet)(target, index, data)
    /// * `target` group: BufferTargetARB
    /// * `data` len: COMPSIZE(target)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetBooleani_v(
      &self, target: GLenum, index: GLuint, data: *mut GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetBooleani_v({:#X}, {:?}, {:p});",
          target,
          index,
          data
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetBooleani_v",
        &self.glGetBooleani_v_p,
        target,
        index,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetBooleani_v");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetBooleani_v_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetBooleani_v\0",
        &self.glGetBooleani_v_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetBooleani_v_is_loaded(&self) -> bool {
      !self.glGetBooleani_v_p.load(RELAX).is_null()
    }
    /// [glGetBooleanv](http://docs.gl/gl3/glGet)(pname, data)
    /// * `pname` group: GetPName
    /// * `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetBooleanv(&self, pname: GLenum, data: *mut GLboolean) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetBooleanv({:#X}, {:p});", pname, data);
      }
      let out = call_atomic_ptr_2arg(
        "glGetBooleanv",
        &self.glGetBooleanv_p,
        pname,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetBooleanv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetBooleanv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetBooleanv\0",
        &self.glGetBooleanv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetBooleanv_is_loaded(&self) -> bool {
      !self.glGetBooleanv_p.load(RELAX).is_null()
    }
    /// [glGetBufferParameteri64v](http://docs.gl/gl3/glGetBufferParameter)(target, pname, params)
    /// * `target` group: BufferTargetARB
    /// * `pname` group: BufferPNameARB
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetBufferParameteri64v(
      &self, target: GLenum, pname: GLenum, params: *mut GLint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetBufferParameteri64v({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetBufferParameteri64v",
        &self.glGetBufferParameteri64v_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetBufferParameteri64v");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetBufferParameteri64v_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetBufferParameteri64v\0",
        &self.glGetBufferParameteri64v_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetBufferParameteri64v_is_loaded(&self) -> bool {
      !self.glGetBufferParameteri64v_p.load(RELAX).is_null()
    }
    /// [glGetBufferParameteriv](http://docs.gl/gl3/glGetBufferParameter)(target, pname, params)
    /// * `target` group: BufferTargetARB
    /// * `pname` group: BufferPNameARB
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetBufferParameteriv(
      &self, target: GLenum, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetBufferParameteriv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetBufferParameteriv",
        &self.glGetBufferParameteriv_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetBufferParameteriv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetBufferParameteriv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetBufferParameteriv\0",
        &self.glGetBufferParameteriv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetBufferParameteriv_is_loaded(&self) -> bool {
      !self.glGetBufferParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetBufferPointerv](http://docs.gl/gl3/glGetBufferPointerv)(target, pname, params)
    /// * `target` group: BufferTargetARB
    /// * `pname` group: BufferPointerNameARB
    /// * `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetBufferPointerv(
      &self, target: GLenum, pname: GLenum, params: *mut *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetBufferPointerv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetBufferPointerv",
        &self.glGetBufferPointerv_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetBufferPointerv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetBufferPointerv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetBufferPointerv\0",
        &self.glGetBufferPointerv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetBufferPointerv_is_loaded(&self) -> bool {
      !self.glGetBufferPointerv_p.load(RELAX).is_null()
    }
    /// [glGetBufferSubData](http://docs.gl/gl3/glGetBufferSubData)(target, offset, size, data)
    /// * `target` group: BufferTargetARB
    /// * `offset` group: BufferOffset
    /// * `size` group: BufferSize
    /// * `data` len: size
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetBufferSubData(
      &self, target: GLenum, offset: GLintptr, size: GLsizeiptr,
      data: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetBufferSubData({:#X}, {:?}, {:?}, {:p});",
          target,
          offset,
          size,
          data
        );
      }
      let out = call_atomic_ptr_4arg(
        "glGetBufferSubData",
        &self.glGetBufferSubData_p,
        target,
        offset,
        size,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetBufferSubData");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetBufferSubData_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetBufferSubData\0",
        &self.glGetBufferSubData_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetBufferSubData_is_loaded(&self) -> bool {
      !self.glGetBufferSubData_p.load(RELAX).is_null()
    }
    /// [glGetCompressedTexImage](http://docs.gl/gl3/glGetCompressedTexImage)(target, level, img)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `img` group: CompressedTextureARB
    /// * `img` len: COMPSIZE(target,level)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetCompressedTexImage(
      &self, target: GLenum, level: GLint, img: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetCompressedTexImage({:#X}, {:?}, {:p});",
          target,
          level,
          img
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetCompressedTexImage",
        &self.glGetCompressedTexImage_p,
        target,
        level,
        img,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetCompressedTexImage");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetCompressedTexImage_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetCompressedTexImage\0",
        &self.glGetCompressedTexImage_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetCompressedTexImage_is_loaded(&self) -> bool {
      !self.glGetCompressedTexImage_p.load(RELAX).is_null()
    }
    /// [glGetDebugMessageLog](http://docs.gl/gl3/glGetDebugMessageLog)(count, bufSize, sources, types, ids, severities, lengths, messageLog)
    /// * `sources` group: DebugSource
    /// * `sources` len: count
    /// * `types` group: DebugType
    /// * `types` len: count
    /// * `ids` len: count
    /// * `severities` group: DebugSeverity
    /// * `severities` len: count
    /// * `lengths` len: count
    /// * `messageLog` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn GetDebugMessageLog(
      &self, count: GLuint, bufSize: GLsizei, sources: *mut GLenum,
      types: *mut GLenum, ids: *mut GLuint, severities: *mut GLenum,
      lengths: *mut GLsizei, messageLog: *mut GLchar,
    ) -> GLuint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetDebugMessageLog({:?}, {:?}, {:p}, {:p}, {:p}, {:p}, {:p}, {:p});", count, bufSize, sources, types, ids, severities, lengths, messageLog);
      }
      let out = call_atomic_ptr_8arg(
        "glGetDebugMessageLog",
        &self.glGetDebugMessageLog_p,
        count,
        bufSize,
        sources,
        types,
        ids,
        severities,
        lengths,
        messageLog,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetDebugMessageLog");
      }
      out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    #[doc(hidden)]
    pub unsafe fn GetDebugMessageLog_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetDebugMessageLog\0",
        &self.glGetDebugMessageLog_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn GetDebugMessageLog_is_loaded(&self) -> bool {
      !self.glGetDebugMessageLog_p.load(RELAX).is_null()
    }
    /// [glGetDebugMessageLogARB](http://docs.gl/gl3/glGetDebugMessageLogARB)(count, bufSize, sources, types, ids, severities, lengths, messageLog)
    /// * `sources` group: DebugSource
    /// * `sources` len: count
    /// * `types` group: DebugType
    /// * `types` len: count
    /// * `ids` len: count
    /// * `severities` group: DebugSeverity
    /// * `severities` len: count
    /// * `lengths` len: count
    /// * `messageLog` len: bufSize
    /// * alias of: [`glGetDebugMessageLog`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    pub unsafe fn GetDebugMessageLogARB(
      &self, count: GLuint, bufSize: GLsizei, sources: *mut GLenum,
      types: *mut GLenum, ids: *mut GLuint, severities: *mut GLenum,
      lengths: *mut GLsizei, messageLog: *mut GLchar,
    ) -> GLuint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetDebugMessageLogARB({:?}, {:?}, {:p}, {:p}, {:p}, {:p}, {:p}, {:p});", count, bufSize, sources, types, ids, severities, lengths, messageLog);
      }
      let out = call_atomic_ptr_8arg(
        "glGetDebugMessageLogARB",
        &self.glGetDebugMessageLogARB_p,
        count,
        bufSize,
        sources,
        types,
        ids,
        severities,
        lengths,
        messageLog,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetDebugMessageLogARB");
      }
      out
    }
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    #[doc(hidden)]
    pub unsafe fn GetDebugMessageLogARB_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetDebugMessageLogARB\0",
        &self.glGetDebugMessageLogARB_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    pub fn GetDebugMessageLogARB_is_loaded(&self) -> bool {
      !self.glGetDebugMessageLogARB_p.load(RELAX).is_null()
    }
    /// [glGetDoublev](http://docs.gl/gl3/glGetDoublev)(pname, data)
    /// * `pname` group: GetPName
    /// * `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetDoublev(&self, pname: GLenum, data: *mut GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetDoublev({:#X}, {:p});", pname, data);
      }
      let out =
        call_atomic_ptr_2arg("glGetDoublev", &self.glGetDoublev_p, pname, data);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetDoublev");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetDoublev_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetDoublev\0",
        &self.glGetDoublev_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetDoublev_is_loaded(&self) -> bool {
      !self.glGetDoublev_p.load(RELAX).is_null()
    }
    /// [glGetError](http://docs.gl/gl3/glGetError)()
    /// * return value group: ErrorCode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetError(&self) -> GLenum {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetError();",);
      }
      let out = call_atomic_ptr_0arg("glGetError", &self.glGetError_p);

      out
    }
    #[doc(hidden)]
    pub unsafe fn GetError_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetError\0",
        &self.glGetError_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetError_is_loaded(&self) -> bool {
      !self.glGetError_p.load(RELAX).is_null()
    }
    /// [glGetFloatv](http://docs.gl/gl3/glGet)(pname, data)
    /// * `pname` group: GetPName
    /// * `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetFloatv(&self, pname: GLenum, data: *mut GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetFloatv({:#X}, {:p});", pname, data);
      }
      let out =
        call_atomic_ptr_2arg("glGetFloatv", &self.glGetFloatv_p, pname, data);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetFloatv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetFloatv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetFloatv\0",
        &self.glGetFloatv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetFloatv_is_loaded(&self) -> bool {
      !self.glGetFloatv_p.load(RELAX).is_null()
    }
    /// [glGetFragDataIndex](http://docs.gl/gl3/glGetFragDataIndex)(program, name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetFragDataIndex(
      &self, program: GLuint, name: *const GLchar,
    ) -> GLint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetFragDataIndex({:?}, {:p});", program, name);
      }
      let out = call_atomic_ptr_2arg(
        "glGetFragDataIndex",
        &self.glGetFragDataIndex_p,
        program,
        name,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetFragDataIndex");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetFragDataIndex_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetFragDataIndex\0",
        &self.glGetFragDataIndex_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetFragDataIndex_is_loaded(&self) -> bool {
      !self.glGetFragDataIndex_p.load(RELAX).is_null()
    }
    /// [glGetFragDataLocation](http://docs.gl/gl3/glGetFragDataLocation)(program, name)
    /// * `name` len: COMPSIZE(name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetFragDataLocation(
      &self, program: GLuint, name: *const GLchar,
    ) -> GLint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetFragDataLocation({:?}, {:p});", program, name);
      }
      let out = call_atomic_ptr_2arg(
        "glGetFragDataLocation",
        &self.glGetFragDataLocation_p,
        program,
        name,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetFragDataLocation");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetFragDataLocation_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetFragDataLocation\0",
        &self.glGetFragDataLocation_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetFragDataLocation_is_loaded(&self) -> bool {
      !self.glGetFragDataLocation_p.load(RELAX).is_null()
    }
    /// [glGetFramebufferAttachmentParameteriv](http://docs.gl/gl3/glGetFramebufferAttachmentParameter)(target, attachment, pname, params)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    /// * `pname` group: FramebufferAttachmentParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetFramebufferAttachmentParameteriv(
      &self, target: GLenum, attachment: GLenum, pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetFramebufferAttachmentParameteriv({:#X}, {:#X}, {:#X}, {:p});", target, attachment, pname, params);
      }
      let out = call_atomic_ptr_4arg(
        "glGetFramebufferAttachmentParameteriv",
        &self.glGetFramebufferAttachmentParameteriv_p,
        target,
        attachment,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetFramebufferAttachmentParameteriv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetFramebufferAttachmentParameteriv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetFramebufferAttachmentParameteriv\0",
        &self.glGetFramebufferAttachmentParameteriv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetFramebufferAttachmentParameteriv_is_loaded(&self) -> bool {
      !self.glGetFramebufferAttachmentParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetInteger64i_v](http://docs.gl/gl3/glGet)(target, index, data)
    /// * `data` len: COMPSIZE(target)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetInteger64i_v(
      &self, target: GLenum, index: GLuint, data: *mut GLint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetInteger64i_v({:#X}, {:?}, {:p});",
          target,
          index,
          data
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetInteger64i_v",
        &self.glGetInteger64i_v_p,
        target,
        index,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetInteger64i_v");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetInteger64i_v_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetInteger64i_v\0",
        &self.glGetInteger64i_v_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetInteger64i_v_is_loaded(&self) -> bool {
      !self.glGetInteger64i_v_p.load(RELAX).is_null()
    }
    /// [glGetInteger64v](http://docs.gl/gl3/glGet)(pname, data)
    /// * `pname` group: GetPName
    /// * `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetInteger64v(&self, pname: GLenum, data: *mut GLint64) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetInteger64v({:#X}, {:p});", pname, data);
      }
      let out = call_atomic_ptr_2arg(
        "glGetInteger64v",
        &self.glGetInteger64v_p,
        pname,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetInteger64v");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetInteger64v_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetInteger64v\0",
        &self.glGetInteger64v_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetInteger64v_is_loaded(&self) -> bool {
      !self.glGetInteger64v_p.load(RELAX).is_null()
    }
    /// [glGetIntegeri_v](http://docs.gl/gl3/glGet)(target, index, data)
    /// * `data` len: COMPSIZE(target)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetIntegeri_v(
      &self, target: GLenum, index: GLuint, data: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetIntegeri_v({:#X}, {:?}, {:p});",
          target,
          index,
          data
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetIntegeri_v",
        &self.glGetIntegeri_v_p,
        target,
        index,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetIntegeri_v");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetIntegeri_v_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetIntegeri_v\0",
        &self.glGetIntegeri_v_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetIntegeri_v_is_loaded(&self) -> bool {
      !self.glGetIntegeri_v_p.load(RELAX).is_null()
    }
    /// [glGetIntegerv](http://docs.gl/gl3/glGet)(pname, data)
    /// * `pname` group: GetPName
    /// * `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetIntegerv(&self, pname: GLenum, data: *mut GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetIntegerv({:#X}, {:p});", pname, data);
      }
      let out = call_atomic_ptr_2arg(
        "glGetIntegerv",
        &self.glGetIntegerv_p,
        pname,
        data,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetIntegerv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetIntegerv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetIntegerv\0",
        &self.glGetIntegerv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetIntegerv_is_loaded(&self) -> bool {
      !self.glGetIntegerv_p.load(RELAX).is_null()
    }
    /// [glGetMultisamplefv](http://docs.gl/gl3/glGetMultisample)(pname, index, val)
    /// * `pname` group: GetMultisamplePNameNV
    /// * `val` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetMultisamplefv(
      &self, pname: GLenum, index: GLuint, val: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetMultisamplefv({:#X}, {:?}, {:p});",
          pname,
          index,
          val
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetMultisamplefv",
        &self.glGetMultisamplefv_p,
        pname,
        index,
        val,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetMultisamplefv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetMultisamplefv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetMultisamplefv\0",
        &self.glGetMultisamplefv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetMultisamplefv_is_loaded(&self) -> bool {
      !self.glGetMultisamplefv_p.load(RELAX).is_null()
    }
    /// [glGetObjectLabel](http://docs.gl/gl3/glGetObjectLabel)(identifier, name, bufSize, length, label)
    /// * `identifier` group: ObjectIdentifier
    /// * `length` len: 1
    /// * `label` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn GetObjectLabel(
      &self, identifier: GLenum, name: GLuint, bufSize: GLsizei,
      length: *mut GLsizei, label: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetObjectLabel({:#X}, {:?}, {:?}, {:p}, {:p});",
          identifier,
          name,
          bufSize,
          length,
          label
        );
      }
      let out = call_atomic_ptr_5arg(
        "glGetObjectLabel",
        &self.glGetObjectLabel_p,
        identifier,
        name,
        bufSize,
        length,
        label,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetObjectLabel");
      }
      out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    #[doc(hidden)]
    pub unsafe fn GetObjectLabel_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetObjectLabel\0",
        &self.glGetObjectLabel_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn GetObjectLabel_is_loaded(&self) -> bool {
      !self.glGetObjectLabel_p.load(RELAX).is_null()
    }
    /// [glGetObjectPtrLabel](http://docs.gl/gl3/glGetObjectPtrLabel)(ptr, bufSize, length, label)
    /// * `length` len: 1
    /// * `label` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn GetObjectPtrLabel(
      &self, ptr: *const c_void, bufSize: GLsizei, length: *mut GLsizei,
      label: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetObjectPtrLabel({:p}, {:?}, {:p}, {:p});",
          ptr,
          bufSize,
          length,
          label
        );
      }
      let out = call_atomic_ptr_4arg(
        "glGetObjectPtrLabel",
        &self.glGetObjectPtrLabel_p,
        ptr,
        bufSize,
        length,
        label,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetObjectPtrLabel");
      }
      out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    #[doc(hidden)]
    pub unsafe fn GetObjectPtrLabel_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetObjectPtrLabel\0",
        &self.glGetObjectPtrLabel_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn GetObjectPtrLabel_is_loaded(&self) -> bool {
      !self.glGetObjectPtrLabel_p.load(RELAX).is_null()
    }
    /// [glGetPointerv](http://docs.gl/gl3/glGetPointerv)(pname, params)
    /// * `pname` group: GetPointervPName
    /// * `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn GetPointerv(&self, pname: GLenum, params: *mut *mut c_void) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetPointerv({:#X}, {:p});", pname, params);
      }
      let out = call_atomic_ptr_2arg(
        "glGetPointerv",
        &self.glGetPointerv_p,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetPointerv");
      }
      out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    #[doc(hidden)]
    pub unsafe fn GetPointerv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetPointerv\0",
        &self.glGetPointerv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn GetPointerv_is_loaded(&self) -> bool {
      !self.glGetPointerv_p.load(RELAX).is_null()
    }
    /// [glGetProgramInfoLog](http://docs.gl/gl3/glGetProgramInfoLog)(program, bufSize, length, infoLog)
    /// * `length` len: 1
    /// * `infoLog` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramInfoLog(
      &self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei,
      infoLog: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetProgramInfoLog({:?}, {:?}, {:p}, {:p});",
          program,
          bufSize,
          length,
          infoLog
        );
      }
      let out = call_atomic_ptr_4arg(
        "glGetProgramInfoLog",
        &self.glGetProgramInfoLog_p,
        program,
        bufSize,
        length,
        infoLog,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetProgramInfoLog");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetProgramInfoLog_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetProgramInfoLog\0",
        &self.glGetProgramInfoLog_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramInfoLog_is_loaded(&self) -> bool {
      !self.glGetProgramInfoLog_p.load(RELAX).is_null()
    }
    /// [glGetProgramiv](http://docs.gl/gl3/glGetProgram)(program, pname, params)
    /// * `pname` group: ProgramPropertyARB
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramiv(
      &self, program: GLuint, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetProgramiv({:?}, {:#X}, {:p});",
          program,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetProgramiv",
        &self.glGetProgramiv_p,
        program,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetProgramiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetProgramiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetProgramiv\0",
        &self.glGetProgramiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramiv_is_loaded(&self) -> bool {
      !self.glGetProgramiv_p.load(RELAX).is_null()
    }
    /// [glGetQueryObjecti64v](http://docs.gl/gl3/glGetQueryObject)(id, pname, params)
    /// * `pname` group: QueryObjectParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryObjecti64v(
      &self, id: GLuint, pname: GLenum, params: *mut GLint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryObjecti64v({:?}, {:#X}, {:p});",
          id,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetQueryObjecti64v",
        &self.glGetQueryObjecti64v_p,
        id,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetQueryObjecti64v");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetQueryObjecti64v_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetQueryObjecti64v\0",
        &self.glGetQueryObjecti64v_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryObjecti64v_is_loaded(&self) -> bool {
      !self.glGetQueryObjecti64v_p.load(RELAX).is_null()
    }
    /// [glGetQueryObjectiv](http://docs.gl/gl3/glGetQueryObject)(id, pname, params)
    /// * `pname` group: QueryObjectParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryObjectiv(
      &self, id: GLuint, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryObjectiv({:?}, {:#X}, {:p});",
          id,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetQueryObjectiv",
        &self.glGetQueryObjectiv_p,
        id,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetQueryObjectiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetQueryObjectiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetQueryObjectiv\0",
        &self.glGetQueryObjectiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryObjectiv_is_loaded(&self) -> bool {
      !self.glGetQueryObjectiv_p.load(RELAX).is_null()
    }
    /// [glGetQueryObjectui64v](http://docs.gl/gl3/glGetQueryObjectu)(id, pname, params)
    /// * `pname` group: QueryObjectParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryObjectui64v(
      &self, id: GLuint, pname: GLenum, params: *mut GLuint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryObjectui64v({:?}, {:#X}, {:p});",
          id,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetQueryObjectui64v",
        &self.glGetQueryObjectui64v_p,
        id,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetQueryObjectui64v");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetQueryObjectui64v_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetQueryObjectui64v\0",
        &self.glGetQueryObjectui64v_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryObjectui64v_is_loaded(&self) -> bool {
      !self.glGetQueryObjectui64v_p.load(RELAX).is_null()
    }
    /// [glGetQueryObjectuiv](http://docs.gl/gl3/glGetQueryObject)(id, pname, params)
    /// * `pname` group: QueryObjectParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryObjectuiv(
      &self, id: GLuint, pname: GLenum, params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryObjectuiv({:?}, {:#X}, {:p});",
          id,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetQueryObjectuiv",
        &self.glGetQueryObjectuiv_p,
        id,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetQueryObjectuiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetQueryObjectuiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetQueryObjectuiv\0",
        &self.glGetQueryObjectuiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryObjectuiv_is_loaded(&self) -> bool {
      !self.glGetQueryObjectuiv_p.load(RELAX).is_null()
    }
    /// [glGetQueryiv](http://docs.gl/gl3/glGetQuery)(target, pname, params)
    /// * `target` group: QueryTarget
    /// * `pname` group: QueryParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryiv(
      &self, target: GLenum, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryiv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetQueryiv",
        &self.glGetQueryiv_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetQueryiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetQueryiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetQueryiv\0",
        &self.glGetQueryiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryiv_is_loaded(&self) -> bool {
      !self.glGetQueryiv_p.load(RELAX).is_null()
    }
    /// [glGetRenderbufferParameteriv](http://docs.gl/gl3/glGetRenderbufferParameter)(target, pname, params)
    /// * `target` group: RenderbufferTarget
    /// * `pname` group: RenderbufferParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetRenderbufferParameteriv(
      &self, target: GLenum, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetRenderbufferParameteriv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetRenderbufferParameteriv",
        &self.glGetRenderbufferParameteriv_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetRenderbufferParameteriv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetRenderbufferParameteriv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetRenderbufferParameteriv\0",
        &self.glGetRenderbufferParameteriv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetRenderbufferParameteriv_is_loaded(&self) -> bool {
      !self.glGetRenderbufferParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetSamplerParameterIiv](http://docs.gl/gl3/glGetSamplerParameter)(sampler, pname, params)
    /// * `pname` group: SamplerParameterI
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetSamplerParameterIiv(
      &self, sampler: GLuint, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetSamplerParameterIiv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetSamplerParameterIiv",
        &self.glGetSamplerParameterIiv_p,
        sampler,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetSamplerParameterIiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetSamplerParameterIiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetSamplerParameterIiv\0",
        &self.glGetSamplerParameterIiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetSamplerParameterIiv_is_loaded(&self) -> bool {
      !self.glGetSamplerParameterIiv_p.load(RELAX).is_null()
    }
    /// [glGetSamplerParameterIuiv](http://docs.gl/gl3/glGetSamplerParameter)(sampler, pname, params)
    /// * `pname` group: SamplerParameterI
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetSamplerParameterIuiv(
      &self, sampler: GLuint, pname: GLenum, params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetSamplerParameterIuiv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetSamplerParameterIuiv",
        &self.glGetSamplerParameterIuiv_p,
        sampler,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetSamplerParameterIuiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetSamplerParameterIuiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetSamplerParameterIuiv\0",
        &self.glGetSamplerParameterIuiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetSamplerParameterIuiv_is_loaded(&self) -> bool {
      !self.glGetSamplerParameterIuiv_p.load(RELAX).is_null()
    }
    /// [glGetSamplerParameterfv](http://docs.gl/gl3/glGetSamplerParameter)(sampler, pname, params)
    /// * `pname` group: SamplerParameterF
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetSamplerParameterfv(
      &self, sampler: GLuint, pname: GLenum, params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetSamplerParameterfv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetSamplerParameterfv",
        &self.glGetSamplerParameterfv_p,
        sampler,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetSamplerParameterfv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetSamplerParameterfv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetSamplerParameterfv\0",
        &self.glGetSamplerParameterfv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetSamplerParameterfv_is_loaded(&self) -> bool {
      !self.glGetSamplerParameterfv_p.load(RELAX).is_null()
    }
    /// [glGetSamplerParameteriv](http://docs.gl/gl3/glGetSamplerParameter)(sampler, pname, params)
    /// * `pname` group: SamplerParameterI
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetSamplerParameteriv(
      &self, sampler: GLuint, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetSamplerParameteriv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetSamplerParameteriv",
        &self.glGetSamplerParameteriv_p,
        sampler,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetSamplerParameteriv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetSamplerParameteriv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetSamplerParameteriv\0",
        &self.glGetSamplerParameteriv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetSamplerParameteriv_is_loaded(&self) -> bool {
      !self.glGetSamplerParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetShaderInfoLog](http://docs.gl/gl3/glGetShaderInfoLog)(shader, bufSize, length, infoLog)
    /// * `length` len: 1
    /// * `infoLog` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetShaderInfoLog(
      &self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei,
      infoLog: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetShaderInfoLog({:?}, {:?}, {:p}, {:p});",
          shader,
          bufSize,
          length,
          infoLog
        );
      }
      let out = call_atomic_ptr_4arg(
        "glGetShaderInfoLog",
        &self.glGetShaderInfoLog_p,
        shader,
        bufSize,
        length,
        infoLog,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetShaderInfoLog");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetShaderInfoLog_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetShaderInfoLog\0",
        &self.glGetShaderInfoLog_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetShaderInfoLog_is_loaded(&self) -> bool {
      !self.glGetShaderInfoLog_p.load(RELAX).is_null()
    }
    /// [glGetShaderSource](http://docs.gl/gl3/glGetShaderSource)(shader, bufSize, length, source)
    /// * `length` len: 1
    /// * `source` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetShaderSource(
      &self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei,
      source: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetShaderSource({:?}, {:?}, {:p}, {:p});",
          shader,
          bufSize,
          length,
          source
        );
      }
      let out = call_atomic_ptr_4arg(
        "glGetShaderSource",
        &self.glGetShaderSource_p,
        shader,
        bufSize,
        length,
        source,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetShaderSource");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetShaderSource_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetShaderSource\0",
        &self.glGetShaderSource_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetShaderSource_is_loaded(&self) -> bool {
      !self.glGetShaderSource_p.load(RELAX).is_null()
    }
    /// [glGetShaderiv](http://docs.gl/gl3/glGetShaderiv)(shader, pname, params)
    /// * `pname` group: ShaderParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetShaderiv(
      &self, shader: GLuint, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetShaderiv({:?}, {:#X}, {:p});",
          shader,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetShaderiv",
        &self.glGetShaderiv_p,
        shader,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetShaderiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetShaderiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetShaderiv\0",
        &self.glGetShaderiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetShaderiv_is_loaded(&self) -> bool {
      !self.glGetShaderiv_p.load(RELAX).is_null()
    }
    /// [glGetString](http://docs.gl/gl3/glGetString)(name)
    /// * `name` group: StringName
    /// * return value group: String
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetString(&self, name: GLenum) -> *const GLubyte {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetString({:#X});", name);
      }
      let out = call_atomic_ptr_1arg("glGetString", &self.glGetString_p, name);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetString");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetString_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetString\0",
        &self.glGetString_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetString_is_loaded(&self) -> bool {
      !self.glGetString_p.load(RELAX).is_null()
    }
    /// [glGetStringi](http://docs.gl/gl3/glGetString)(name, index)
    /// * `name` group: StringName
    /// * return value group: String
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetStringi(
      &self, name: GLenum, index: GLuint,
    ) -> *const GLubyte {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetStringi({:#X}, {:?});", name, index);
      }
      let out =
        call_atomic_ptr_2arg("glGetStringi", &self.glGetStringi_p, name, index);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetStringi");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetStringi_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetStringi\0",
        &self.glGetStringi_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetStringi_is_loaded(&self) -> bool {
      !self.glGetStringi_p.load(RELAX).is_null()
    }
    /// [glGetSynciv](http://docs.gl/gl3/glGetSync)(sync, pname, count, length, values)
    /// * `sync` group: sync
    /// * `pname` group: SyncParameterName
    /// * `length` len: 1
    /// * `values` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetSynciv(
      &self, sync: GLsync, pname: GLenum, count: GLsizei, length: *mut GLsizei,
      values: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetSynciv({:p}, {:#X}, {:?}, {:p}, {:p});",
          sync,
          pname,
          count,
          length,
          values
        );
      }
      let out = call_atomic_ptr_5arg(
        "glGetSynciv",
        &self.glGetSynciv_p,
        sync,
        pname,
        count,
        length,
        values,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetSynciv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetSynciv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetSynciv\0",
        &self.glGetSynciv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetSynciv_is_loaded(&self) -> bool {
      !self.glGetSynciv_p.load(RELAX).is_null()
    }
    /// [glGetTexImage](http://docs.gl/gl3/glGetTexImage)(target, level, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(target,level,format,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexImage(
      &self, target: GLenum, level: GLint, format: GLenum, type_: GLenum,
      pixels: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexImage({:#X}, {:?}, {:#X}, {:#X}, {:p});",
          target,
          level,
          format,
          type_,
          pixels
        );
      }
      let out = call_atomic_ptr_5arg(
        "glGetTexImage",
        &self.glGetTexImage_p,
        target,
        level,
        format,
        type_,
        pixels,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetTexImage");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetTexImage_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetTexImage\0",
        &self.glGetTexImage_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexImage_is_loaded(&self) -> bool {
      !self.glGetTexImage_p.load(RELAX).is_null()
    }
    /// [glGetTexLevelParameterfv](http://docs.gl/gl3/glGetTexLevelParameter)(target, level, pname, params)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `pname` group: GetTextureParameter
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexLevelParameterfv(
      &self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexLevelParameterfv({:#X}, {:?}, {:#X}, {:p});",
          target,
          level,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_4arg(
        "glGetTexLevelParameterfv",
        &self.glGetTexLevelParameterfv_p,
        target,
        level,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetTexLevelParameterfv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetTexLevelParameterfv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetTexLevelParameterfv\0",
        &self.glGetTexLevelParameterfv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexLevelParameterfv_is_loaded(&self) -> bool {
      !self.glGetTexLevelParameterfv_p.load(RELAX).is_null()
    }
    /// [glGetTexLevelParameteriv](http://docs.gl/gl3/glGetTexLevelParameter)(target, level, pname, params)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `pname` group: GetTextureParameter
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexLevelParameteriv(
      &self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexLevelParameteriv({:#X}, {:?}, {:#X}, {:p});",
          target,
          level,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_4arg(
        "glGetTexLevelParameteriv",
        &self.glGetTexLevelParameteriv_p,
        target,
        level,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetTexLevelParameteriv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetTexLevelParameteriv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetTexLevelParameteriv\0",
        &self.glGetTexLevelParameteriv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexLevelParameteriv_is_loaded(&self) -> bool {
      !self.glGetTexLevelParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetTexParameterIiv](http://docs.gl/gl3/glGetTexParameter)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: GetTextureParameter
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexParameterIiv(
      &self, target: GLenum, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexParameterIiv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetTexParameterIiv",
        &self.glGetTexParameterIiv_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetTexParameterIiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetTexParameterIiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetTexParameterIiv\0",
        &self.glGetTexParameterIiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexParameterIiv_is_loaded(&self) -> bool {
      !self.glGetTexParameterIiv_p.load(RELAX).is_null()
    }
    /// [glGetTexParameterIuiv](http://docs.gl/gl3/glGetTexParameter)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: GetTextureParameter
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexParameterIuiv(
      &self, target: GLenum, pname: GLenum, params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexParameterIuiv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetTexParameterIuiv",
        &self.glGetTexParameterIuiv_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetTexParameterIuiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetTexParameterIuiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetTexParameterIuiv\0",
        &self.glGetTexParameterIuiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexParameterIuiv_is_loaded(&self) -> bool {
      !self.glGetTexParameterIuiv_p.load(RELAX).is_null()
    }
    /// [glGetTexParameterfv](http://docs.gl/gl3/glGetTexParameter)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: GetTextureParameter
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexParameterfv(
      &self, target: GLenum, pname: GLenum, params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexParameterfv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetTexParameterfv",
        &self.glGetTexParameterfv_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetTexParameterfv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetTexParameterfv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetTexParameterfv\0",
        &self.glGetTexParameterfv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexParameterfv_is_loaded(&self) -> bool {
      !self.glGetTexParameterfv_p.load(RELAX).is_null()
    }
    /// [glGetTexParameteriv](http://docs.gl/gl3/glGetTexParameter)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: GetTextureParameter
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexParameteriv(
      &self, target: GLenum, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexParameteriv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetTexParameteriv",
        &self.glGetTexParameteriv_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetTexParameteriv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetTexParameteriv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetTexParameteriv\0",
        &self.glGetTexParameteriv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexParameteriv_is_loaded(&self) -> bool {
      !self.glGetTexParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetTransformFeedbackVarying](http://docs.gl/gl3/glGetTransformFeedbackVarying)(program, index, bufSize, length, size, type_, name)
    /// * `length` len: 1
    /// * `size` len: 1
    /// * `type_` group: AttributeType
    /// * `type_` len: 1
    /// * `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTransformFeedbackVarying(
      &self, program: GLuint, index: GLuint, bufSize: GLsizei,
      length: *mut GLsizei, size: *mut GLsizei, type_: *mut GLenum,
      name: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetTransformFeedbackVarying({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});", program, index, bufSize, length, size, type_, name);
      }
      let out = call_atomic_ptr_7arg(
        "glGetTransformFeedbackVarying",
        &self.glGetTransformFeedbackVarying_p,
        program,
        index,
        bufSize,
        length,
        size,
        type_,
        name,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetTransformFeedbackVarying");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetTransformFeedbackVarying_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetTransformFeedbackVarying\0",
        &self.glGetTransformFeedbackVarying_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTransformFeedbackVarying_is_loaded(&self) -> bool {
      !self.glGetTransformFeedbackVarying_p.load(RELAX).is_null()
    }
    /// [glGetUniformBlockIndex](http://docs.gl/gl3/glGetUniformBlockIndex)(program, uniformBlockName)
    /// * `uniformBlockName` len: COMPSIZE()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformBlockIndex(
      &self, program: GLuint, uniformBlockName: *const GLchar,
    ) -> GLuint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetUniformBlockIndex({:?}, {:p});",
          program,
          uniformBlockName
        );
      }
      let out = call_atomic_ptr_2arg(
        "glGetUniformBlockIndex",
        &self.glGetUniformBlockIndex_p,
        program,
        uniformBlockName,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetUniformBlockIndex");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetUniformBlockIndex_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetUniformBlockIndex\0",
        &self.glGetUniformBlockIndex_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformBlockIndex_is_loaded(&self) -> bool {
      !self.glGetUniformBlockIndex_p.load(RELAX).is_null()
    }
    /// [glGetUniformIndices](http://docs.gl/gl3/glGetUniformIndices)(program, uniformCount, uniformNames, uniformIndices)
    /// * `uniformNames` len: COMPSIZE(uniformCount)
    /// * `uniformIndices` len: COMPSIZE(uniformCount)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformIndices(
      &self, program: GLuint, uniformCount: GLsizei,
      uniformNames: *const *const GLchar, uniformIndices: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetUniformIndices({:?}, {:?}, {:p}, {:p});",
          program,
          uniformCount,
          uniformNames,
          uniformIndices
        );
      }
      let out = call_atomic_ptr_4arg(
        "glGetUniformIndices",
        &self.glGetUniformIndices_p,
        program,
        uniformCount,
        uniformNames,
        uniformIndices,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetUniformIndices");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetUniformIndices_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetUniformIndices\0",
        &self.glGetUniformIndices_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformIndices_is_loaded(&self) -> bool {
      !self.glGetUniformIndices_p.load(RELAX).is_null()
    }
    /// [glGetUniformLocation](http://docs.gl/gl3/glGetUniformLocation)(program, name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformLocation(
      &self, program: GLuint, name: *const GLchar,
    ) -> GLint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetUniformLocation({:?}, {:p});", program, name);
      }
      let out = call_atomic_ptr_2arg(
        "glGetUniformLocation",
        &self.glGetUniformLocation_p,
        program,
        name,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetUniformLocation");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetUniformLocation_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetUniformLocation\0",
        &self.glGetUniformLocation_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformLocation_is_loaded(&self) -> bool {
      !self.glGetUniformLocation_p.load(RELAX).is_null()
    }
    /// [glGetUniformfv](http://docs.gl/gl3/glGetUniform)(program, location, params)
    /// * `params` len: COMPSIZE(program,location)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformfv(
      &self, program: GLuint, location: GLint, params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetUniformfv({:?}, {:?}, {:p});",
          program,
          location,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetUniformfv",
        &self.glGetUniformfv_p,
        program,
        location,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetUniformfv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetUniformfv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetUniformfv\0",
        &self.glGetUniformfv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformfv_is_loaded(&self) -> bool {
      !self.glGetUniformfv_p.load(RELAX).is_null()
    }
    /// [glGetUniformiv](http://docs.gl/gl3/glGetUniform)(program, location, params)
    /// * `params` len: COMPSIZE(program,location)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformiv(
      &self, program: GLuint, location: GLint, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetUniformiv({:?}, {:?}, {:p});",
          program,
          location,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetUniformiv",
        &self.glGetUniformiv_p,
        program,
        location,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetUniformiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetUniformiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetUniformiv\0",
        &self.glGetUniformiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformiv_is_loaded(&self) -> bool {
      !self.glGetUniformiv_p.load(RELAX).is_null()
    }
    /// [glGetUniformuiv](http://docs.gl/gl3/glGetUniform)(program, location, params)
    /// * `params` len: COMPSIZE(program,location)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformuiv(
      &self, program: GLuint, location: GLint, params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetUniformuiv({:?}, {:?}, {:p});",
          program,
          location,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetUniformuiv",
        &self.glGetUniformuiv_p,
        program,
        location,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetUniformuiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetUniformuiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetUniformuiv\0",
        &self.glGetUniformuiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformuiv_is_loaded(&self) -> bool {
      !self.glGetUniformuiv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribIiv](http://docs.gl/gl3/glGetVertexAttrib)(index, pname, params)
    /// * `pname` group: VertexAttribEnum
    /// * `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribIiv(
      &self, index: GLuint, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribIiv({:?}, {:#X}, {:p});",
          index,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetVertexAttribIiv",
        &self.glGetVertexAttribIiv_p,
        index,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetVertexAttribIiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetVertexAttribIiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetVertexAttribIiv\0",
        &self.glGetVertexAttribIiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribIiv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribIiv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribIuiv](http://docs.gl/gl3/glGetVertexAttrib)(index, pname, params)
    /// * `pname` group: VertexAttribEnum
    /// * `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribIuiv(
      &self, index: GLuint, pname: GLenum, params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribIuiv({:?}, {:#X}, {:p});",
          index,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetVertexAttribIuiv",
        &self.glGetVertexAttribIuiv_p,
        index,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetVertexAttribIuiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetVertexAttribIuiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetVertexAttribIuiv\0",
        &self.glGetVertexAttribIuiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribIuiv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribIuiv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribPointerv](http://docs.gl/gl3/glGetVertexAttribPointerv)(index, pname, pointer)
    /// * `pname` group: VertexAttribPointerPropertyARB
    /// * `pointer` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribPointerv(
      &self, index: GLuint, pname: GLenum, pointer: *mut *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribPointerv({:?}, {:#X}, {:p});",
          index,
          pname,
          pointer
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetVertexAttribPointerv",
        &self.glGetVertexAttribPointerv_p,
        index,
        pname,
        pointer,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetVertexAttribPointerv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetVertexAttribPointerv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetVertexAttribPointerv\0",
        &self.glGetVertexAttribPointerv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribPointerv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribPointerv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribdv](http://docs.gl/gl3/glGetVertexAttribdv)(index, pname, params)
    /// * `pname` group: VertexAttribPropertyARB
    /// * `params` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribdv(
      &self, index: GLuint, pname: GLenum, params: *mut GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribdv({:?}, {:#X}, {:p});",
          index,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetVertexAttribdv",
        &self.glGetVertexAttribdv_p,
        index,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetVertexAttribdv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetVertexAttribdv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetVertexAttribdv\0",
        &self.glGetVertexAttribdv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribdv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribdv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribfv](http://docs.gl/gl3/glGetVertexAttrib)(index, pname, params)
    /// * `pname` group: VertexAttribPropertyARB
    /// * `params` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribfv(
      &self, index: GLuint, pname: GLenum, params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribfv({:?}, {:#X}, {:p});",
          index,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetVertexAttribfv",
        &self.glGetVertexAttribfv_p,
        index,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetVertexAttribfv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetVertexAttribfv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetVertexAttribfv\0",
        &self.glGetVertexAttribfv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribfv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribfv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribiv](http://docs.gl/gl3/glGetVertexAttrib)(index, pname, params)
    /// * `pname` group: VertexAttribPropertyARB
    /// * `params` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribiv(
      &self, index: GLuint, pname: GLenum, params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribiv({:?}, {:#X}, {:p});",
          index,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glGetVertexAttribiv",
        &self.glGetVertexAttribiv_p,
        index,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glGetVertexAttribiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn GetVertexAttribiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glGetVertexAttribiv\0",
        &self.glGetVertexAttribiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribiv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribiv_p.load(RELAX).is_null()
    }
    /// [glHint](http://docs.gl/gl3/glHint)(target, mode)
    /// * `target` group: HintTarget
    /// * `mode` group: HintMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Hint(&self, target: GLenum, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Hint({:#X}, {:#X});", target, mode);
      }
      let out = call_atomic_ptr_2arg("glHint", &self.glHint_p, target, mode);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glHint");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Hint_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(get_proc_address, b"glHint\0", &self.glHint_p)
    }
    #[inline]
    #[doc(hidden)]
    pub fn Hint_is_loaded(&self) -> bool {
      !self.glHint_p.load(RELAX).is_null()
    }
    /// [glIsBuffer](http://docs.gl/gl3/glIsBuffer)(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsBuffer(&self, buffer: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsBuffer({:?});", buffer);
      }
      let out = call_atomic_ptr_1arg("glIsBuffer", &self.glIsBuffer_p, buffer);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glIsBuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn IsBuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glIsBuffer\0",
        &self.glIsBuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsBuffer_is_loaded(&self) -> bool {
      !self.glIsBuffer_p.load(RELAX).is_null()
    }
    /// [glIsEnabled](http://docs.gl/gl3/glIsEnabled)(cap)
    /// * `cap` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsEnabled(&self, cap: GLenum) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsEnabled({:#X});", cap);
      }
      let out = call_atomic_ptr_1arg("glIsEnabled", &self.glIsEnabled_p, cap);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glIsEnabled");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn IsEnabled_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glIsEnabled\0",
        &self.glIsEnabled_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsEnabled_is_loaded(&self) -> bool {
      !self.glIsEnabled_p.load(RELAX).is_null()
    }
    /// [glIsEnabledi](http://docs.gl/gl3/glIsEnabled)(target, index)
    /// * `target` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsEnabledi(
      &self, target: GLenum, index: GLuint,
    ) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsEnabledi({:#X}, {:?});", target, index);
      }
      let out = call_atomic_ptr_2arg(
        "glIsEnabledi",
        &self.glIsEnabledi_p,
        target,
        index,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glIsEnabledi");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn IsEnabledi_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glIsEnabledi\0",
        &self.glIsEnabledi_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsEnabledi_is_loaded(&self) -> bool {
      !self.glIsEnabledi_p.load(RELAX).is_null()
    }
    /// [glIsFramebuffer](http://docs.gl/gl3/glIsFramebuffer)(framebuffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsFramebuffer(&self, framebuffer: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsFramebuffer({:?});", framebuffer);
      }
      let out = call_atomic_ptr_1arg(
        "glIsFramebuffer",
        &self.glIsFramebuffer_p,
        framebuffer,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glIsFramebuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn IsFramebuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glIsFramebuffer\0",
        &self.glIsFramebuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsFramebuffer_is_loaded(&self) -> bool {
      !self.glIsFramebuffer_p.load(RELAX).is_null()
    }
    /// [glIsProgram](http://docs.gl/gl3/glIsProgram)(program)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsProgram(&self, program: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsProgram({:?});", program);
      }
      let out =
        call_atomic_ptr_1arg("glIsProgram", &self.glIsProgram_p, program);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glIsProgram");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn IsProgram_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glIsProgram\0",
        &self.glIsProgram_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsProgram_is_loaded(&self) -> bool {
      !self.glIsProgram_p.load(RELAX).is_null()
    }
    /// [glIsQuery](http://docs.gl/gl3/glIsQuery)(id)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsQuery(&self, id: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsQuery({:?});", id);
      }
      let out = call_atomic_ptr_1arg("glIsQuery", &self.glIsQuery_p, id);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glIsQuery");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn IsQuery_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glIsQuery\0",
        &self.glIsQuery_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsQuery_is_loaded(&self) -> bool {
      !self.glIsQuery_p.load(RELAX).is_null()
    }
    /// [glIsRenderbuffer](http://docs.gl/gl3/glIsRenderbuffer)(renderbuffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsRenderbuffer(&self, renderbuffer: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsRenderbuffer({:?});", renderbuffer);
      }
      let out = call_atomic_ptr_1arg(
        "glIsRenderbuffer",
        &self.glIsRenderbuffer_p,
        renderbuffer,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glIsRenderbuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn IsRenderbuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glIsRenderbuffer\0",
        &self.glIsRenderbuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsRenderbuffer_is_loaded(&self) -> bool {
      !self.glIsRenderbuffer_p.load(RELAX).is_null()
    }
    /// [glIsSampler](http://docs.gl/gl3/glIsSampler)(sampler)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsSampler(&self, sampler: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsSampler({:?});", sampler);
      }
      let out =
        call_atomic_ptr_1arg("glIsSampler", &self.glIsSampler_p, sampler);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glIsSampler");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn IsSampler_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glIsSampler\0",
        &self.glIsSampler_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsSampler_is_loaded(&self) -> bool {
      !self.glIsSampler_p.load(RELAX).is_null()
    }
    /// [glIsShader](http://docs.gl/gl3/glIsShader)(shader)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsShader(&self, shader: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsShader({:?});", shader);
      }
      let out = call_atomic_ptr_1arg("glIsShader", &self.glIsShader_p, shader);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glIsShader");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn IsShader_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glIsShader\0",
        &self.glIsShader_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsShader_is_loaded(&self) -> bool {
      !self.glIsShader_p.load(RELAX).is_null()
    }
    /// [glIsSync](http://docs.gl/gl3/glIsSync)(sync)
    /// * `sync` group: sync
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsSync(&self, sync: GLsync) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsSync({:p});", sync);
      }
      let out = call_atomic_ptr_1arg("glIsSync", &self.glIsSync_p, sync);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glIsSync");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn IsSync_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glIsSync\0",
        &self.glIsSync_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsSync_is_loaded(&self) -> bool {
      !self.glIsSync_p.load(RELAX).is_null()
    }
    /// [glIsTexture](http://docs.gl/gl3/glIsTexture)(texture)
    /// * `texture` group: Texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsTexture(&self, texture: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsTexture({:?});", texture);
      }
      let out =
        call_atomic_ptr_1arg("glIsTexture", &self.glIsTexture_p, texture);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glIsTexture");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn IsTexture_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glIsTexture\0",
        &self.glIsTexture_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsTexture_is_loaded(&self) -> bool {
      !self.glIsTexture_p.load(RELAX).is_null()
    }
    /// [glIsVertexArray](http://docs.gl/gl3/glIsVertexArray)(array)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsVertexArray(&self, array: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsVertexArray({:?});", array);
      }
      let out =
        call_atomic_ptr_1arg("glIsVertexArray", &self.glIsVertexArray_p, array);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glIsVertexArray");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn IsVertexArray_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glIsVertexArray\0",
        &self.glIsVertexArray_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsVertexArray_is_loaded(&self) -> bool {
      !self.glIsVertexArray_p.load(RELAX).is_null()
    }
    /// [glLineWidth](http://docs.gl/gl3/glLineWidth)(width)
    /// * `width` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn LineWidth(&self, width: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.LineWidth({:?});", width);
      }
      let out = call_atomic_ptr_1arg("glLineWidth", &self.glLineWidth_p, width);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glLineWidth");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn LineWidth_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glLineWidth\0",
        &self.glLineWidth_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn LineWidth_is_loaded(&self) -> bool {
      !self.glLineWidth_p.load(RELAX).is_null()
    }
    /// [glLinkProgram](http://docs.gl/gl3/glLinkProgram)(program)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn LinkProgram(&self, program: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.LinkProgram({:?});", program);
      }
      let out =
        call_atomic_ptr_1arg("glLinkProgram", &self.glLinkProgram_p, program);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glLinkProgram");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn LinkProgram_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glLinkProgram\0",
        &self.glLinkProgram_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn LinkProgram_is_loaded(&self) -> bool {
      !self.glLinkProgram_p.load(RELAX).is_null()
    }
    /// [glLogicOp](http://docs.gl/gl3/glLogicOp)(opcode)
    /// * `opcode` group: LogicOp
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn LogicOp(&self, opcode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.LogicOp({:#X});", opcode);
      }
      let out = call_atomic_ptr_1arg("glLogicOp", &self.glLogicOp_p, opcode);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glLogicOp");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn LogicOp_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glLogicOp\0",
        &self.glLogicOp_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn LogicOp_is_loaded(&self) -> bool {
      !self.glLogicOp_p.load(RELAX).is_null()
    }
    /// [glMapBuffer](http://docs.gl/gl3/glMapBuffer)(target, access)
    /// * `target` group: BufferTargetARB
    /// * `access` group: BufferAccessARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MapBuffer(
      &self, target: GLenum, access: GLenum,
    ) -> *mut c_void {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.MapBuffer({:#X}, {:#X});", target, access);
      }
      let out = call_atomic_ptr_2arg(
        "glMapBuffer",
        &self.glMapBuffer_p,
        target,
        access,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glMapBuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn MapBuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glMapBuffer\0",
        &self.glMapBuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn MapBuffer_is_loaded(&self) -> bool {
      !self.glMapBuffer_p.load(RELAX).is_null()
    }
    /// [glMapBufferRange](http://docs.gl/gl3/glMapBufferRange)(target, offset, length, access)
    /// * `target` group: BufferTargetARB
    /// * `offset` group: BufferOffset
    /// * `length` group: BufferSize
    /// * `access` group: MapBufferAccessMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MapBufferRange(
      &self, target: GLenum, offset: GLintptr, length: GLsizeiptr,
      access: GLbitfield,
    ) -> *mut c_void {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.MapBufferRange({:#X}, {:?}, {:?}, {:?});",
          target,
          offset,
          length,
          access
        );
      }
      let out = call_atomic_ptr_4arg(
        "glMapBufferRange",
        &self.glMapBufferRange_p,
        target,
        offset,
        length,
        access,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glMapBufferRange");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn MapBufferRange_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glMapBufferRange\0",
        &self.glMapBufferRange_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn MapBufferRange_is_loaded(&self) -> bool {
      !self.glMapBufferRange_p.load(RELAX).is_null()
    }
    /// [glMultiDrawArrays](http://docs.gl/gl3/glMultiDrawArrays)(mode, first, count, drawcount)
    /// * `mode` group: PrimitiveType
    /// * `first` len: COMPSIZE(drawcount)
    /// * `count` len: COMPSIZE(drawcount)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MultiDrawArrays(
      &self, mode: GLenum, first: *const GLint, count: *const GLsizei,
      drawcount: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.MultiDrawArrays({:#X}, {:p}, {:p}, {:?});",
          mode,
          first,
          count,
          drawcount
        );
      }
      let out = call_atomic_ptr_4arg(
        "glMultiDrawArrays",
        &self.glMultiDrawArrays_p,
        mode,
        first,
        count,
        drawcount,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glMultiDrawArrays");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn MultiDrawArrays_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glMultiDrawArrays\0",
        &self.glMultiDrawArrays_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn MultiDrawArrays_is_loaded(&self) -> bool {
      !self.glMultiDrawArrays_p.load(RELAX).is_null()
    }
    /// [glMultiDrawElements](http://docs.gl/gl3/glMultiDrawElements)(mode, count, type_, indices, drawcount)
    /// * `mode` group: PrimitiveType
    /// * `count` len: COMPSIZE(drawcount)
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(drawcount)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MultiDrawElements(
      &self, mode: GLenum, count: *const GLsizei, type_: GLenum,
      indices: *const *const c_void, drawcount: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.MultiDrawElements({:#X}, {:p}, {:#X}, {:p}, {:?});",
          mode,
          count,
          type_,
          indices,
          drawcount
        );
      }
      let out = call_atomic_ptr_5arg(
        "glMultiDrawElements",
        &self.glMultiDrawElements_p,
        mode,
        count,
        type_,
        indices,
        drawcount,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glMultiDrawElements");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn MultiDrawElements_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glMultiDrawElements\0",
        &self.glMultiDrawElements_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn MultiDrawElements_is_loaded(&self) -> bool {
      !self.glMultiDrawElements_p.load(RELAX).is_null()
    }
    /// [glMultiDrawElementsBaseVertex](http://docs.gl/gl3/glMultiDrawElementsBaseVertex)(mode, count, type_, indices, drawcount, basevertex)
    /// * `mode` group: PrimitiveType
    /// * `count` len: COMPSIZE(drawcount)
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(drawcount)
    /// * `basevertex` len: COMPSIZE(drawcount)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MultiDrawElementsBaseVertex(
      &self, mode: GLenum, count: *const GLsizei, type_: GLenum,
      indices: *const *const c_void, drawcount: GLsizei,
      basevertex: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.MultiDrawElementsBaseVertex({:#X}, {:p}, {:#X}, {:p}, {:?}, {:p});", mode, count, type_, indices, drawcount, basevertex);
      }
      let out = call_atomic_ptr_6arg(
        "glMultiDrawElementsBaseVertex",
        &self.glMultiDrawElementsBaseVertex_p,
        mode,
        count,
        type_,
        indices,
        drawcount,
        basevertex,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glMultiDrawElementsBaseVertex");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn MultiDrawElementsBaseVertex_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glMultiDrawElementsBaseVertex\0",
        &self.glMultiDrawElementsBaseVertex_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn MultiDrawElementsBaseVertex_is_loaded(&self) -> bool {
      !self.glMultiDrawElementsBaseVertex_p.load(RELAX).is_null()
    }
    /// [glObjectLabel](http://docs.gl/gl3/glObjectLabel)(identifier, name, length, label)
    /// * `identifier` group: ObjectIdentifier
    /// * `label` len: COMPSIZE(label,length)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn ObjectLabel(
      &self, identifier: GLenum, name: GLuint, length: GLsizei,
      label: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ObjectLabel({:#X}, {:?}, {:?}, {:p});",
          identifier,
          name,
          length,
          label
        );
      }
      let out = call_atomic_ptr_4arg(
        "glObjectLabel",
        &self.glObjectLabel_p,
        identifier,
        name,
        length,
        label,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glObjectLabel");
      }
      out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    #[doc(hidden)]
    pub unsafe fn ObjectLabel_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glObjectLabel\0",
        &self.glObjectLabel_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn ObjectLabel_is_loaded(&self) -> bool {
      !self.glObjectLabel_p.load(RELAX).is_null()
    }
    /// [glObjectPtrLabel](http://docs.gl/gl3/glObjectPtrLabel)(ptr, length, label)
    /// * `label` len: COMPSIZE(label,length)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn ObjectPtrLabel(
      &self, ptr: *const c_void, length: GLsizei, label: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ObjectPtrLabel({:p}, {:?}, {:p});",
          ptr,
          length,
          label
        );
      }
      let out = call_atomic_ptr_3arg(
        "glObjectPtrLabel",
        &self.glObjectPtrLabel_p,
        ptr,
        length,
        label,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glObjectPtrLabel");
      }
      out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    #[doc(hidden)]
    pub unsafe fn ObjectPtrLabel_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glObjectPtrLabel\0",
        &self.glObjectPtrLabel_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn ObjectPtrLabel_is_loaded(&self) -> bool {
      !self.glObjectPtrLabel_p.load(RELAX).is_null()
    }
    /// [glPixelStoref](http://docs.gl/gl3/glPixelStore)(pname, param)
    /// * `pname` group: PixelStoreParameter
    /// * `param` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PixelStoref(&self, pname: GLenum, param: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PixelStoref({:#X}, {:?});", pname, param);
      }
      let out = call_atomic_ptr_2arg(
        "glPixelStoref",
        &self.glPixelStoref_p,
        pname,
        param,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glPixelStoref");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn PixelStoref_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glPixelStoref\0",
        &self.glPixelStoref_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn PixelStoref_is_loaded(&self) -> bool {
      !self.glPixelStoref_p.load(RELAX).is_null()
    }
    /// [glPixelStorei](http://docs.gl/gl3/glPixelStore)(pname, param)
    /// * `pname` group: PixelStoreParameter
    /// * `param` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PixelStorei(&self, pname: GLenum, param: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PixelStorei({:#X}, {:?});", pname, param);
      }
      let out = call_atomic_ptr_2arg(
        "glPixelStorei",
        &self.glPixelStorei_p,
        pname,
        param,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glPixelStorei");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn PixelStorei_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glPixelStorei\0",
        &self.glPixelStorei_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn PixelStorei_is_loaded(&self) -> bool {
      !self.glPixelStorei_p.load(RELAX).is_null()
    }
    /// [glPointParameterf](http://docs.gl/gl3/glPointParameter)(pname, param)
    /// * `pname` group: PointParameterNameARB
    /// * `param` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PointParameterf(&self, pname: GLenum, param: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PointParameterf({:#X}, {:?});", pname, param);
      }
      let out = call_atomic_ptr_2arg(
        "glPointParameterf",
        &self.glPointParameterf_p,
        pname,
        param,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glPointParameterf");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn PointParameterf_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glPointParameterf\0",
        &self.glPointParameterf_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn PointParameterf_is_loaded(&self) -> bool {
      !self.glPointParameterf_p.load(RELAX).is_null()
    }
    /// [glPointParameterfv](http://docs.gl/gl3/glPointParameter)(pname, params)
    /// * `pname` group: PointParameterNameARB
    /// * `params` group: CheckedFloat32
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PointParameterfv(
      &self, pname: GLenum, params: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PointParameterfv({:#X}, {:p});", pname, params);
      }
      let out = call_atomic_ptr_2arg(
        "glPointParameterfv",
        &self.glPointParameterfv_p,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glPointParameterfv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn PointParameterfv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glPointParameterfv\0",
        &self.glPointParameterfv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn PointParameterfv_is_loaded(&self) -> bool {
      !self.glPointParameterfv_p.load(RELAX).is_null()
    }
    /// [glPointParameteri](http://docs.gl/gl3/glPointParameter)(pname, param)
    /// * `pname` group: PointParameterNameARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PointParameteri(&self, pname: GLenum, param: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PointParameteri({:#X}, {:?});", pname, param);
      }
      let out = call_atomic_ptr_2arg(
        "glPointParameteri",
        &self.glPointParameteri_p,
        pname,
        param,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glPointParameteri");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn PointParameteri_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glPointParameteri\0",
        &self.glPointParameteri_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn PointParameteri_is_loaded(&self) -> bool {
      !self.glPointParameteri_p.load(RELAX).is_null()
    }
    /// [glPointParameteriv](http://docs.gl/gl3/glPointParameter)(pname, params)
    /// * `pname` group: PointParameterNameARB
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PointParameteriv(&self, pname: GLenum, params: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PointParameteriv({:#X}, {:p});", pname, params);
      }
      let out = call_atomic_ptr_2arg(
        "glPointParameteriv",
        &self.glPointParameteriv_p,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glPointParameteriv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn PointParameteriv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glPointParameteriv\0",
        &self.glPointParameteriv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn PointParameteriv_is_loaded(&self) -> bool {
      !self.glPointParameteriv_p.load(RELAX).is_null()
    }
    /// [glPointSize](http://docs.gl/gl3/glPointSize)(size)
    /// * `size` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PointSize(&self, size: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PointSize({:?});", size);
      }
      let out = call_atomic_ptr_1arg("glPointSize", &self.glPointSize_p, size);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glPointSize");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn PointSize_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glPointSize\0",
        &self.glPointSize_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn PointSize_is_loaded(&self) -> bool {
      !self.glPointSize_p.load(RELAX).is_null()
    }
    /// [glPolygonMode](http://docs.gl/gl3/glPolygonMode)(face, mode)
    /// * `face` group: MaterialFace
    /// * `mode` group: PolygonMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PolygonMode(&self, face: GLenum, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PolygonMode({:#X}, {:#X});", face, mode);
      }
      let out = call_atomic_ptr_2arg(
        "glPolygonMode",
        &self.glPolygonMode_p,
        face,
        mode,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glPolygonMode");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn PolygonMode_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glPolygonMode\0",
        &self.glPolygonMode_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn PolygonMode_is_loaded(&self) -> bool {
      !self.glPolygonMode_p.load(RELAX).is_null()
    }
    /// [glPolygonOffset](http://docs.gl/gl3/glPolygonOffset)(factor, units)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PolygonOffset(&self, factor: GLfloat, units: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PolygonOffset({:?}, {:?});", factor, units);
      }
      let out = call_atomic_ptr_2arg(
        "glPolygonOffset",
        &self.glPolygonOffset_p,
        factor,
        units,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glPolygonOffset");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn PolygonOffset_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glPolygonOffset\0",
        &self.glPolygonOffset_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn PolygonOffset_is_loaded(&self) -> bool {
      !self.glPolygonOffset_p.load(RELAX).is_null()
    }
    /// [glPopDebugGroup](http://docs.gl/gl3/glPopDebugGroup)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn PopDebugGroup(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PopDebugGroup();",);
      }
      let out =
        call_atomic_ptr_0arg("glPopDebugGroup", &self.glPopDebugGroup_p);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glPopDebugGroup");
      }
      out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    #[doc(hidden)]
    pub unsafe fn PopDebugGroup_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glPopDebugGroup\0",
        &self.glPopDebugGroup_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn PopDebugGroup_is_loaded(&self) -> bool {
      !self.glPopDebugGroup_p.load(RELAX).is_null()
    }
    /// [glPrimitiveRestartIndex](http://docs.gl/gl3/glPrimitiveRestartIndex)(index)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PrimitiveRestartIndex(&self, index: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PrimitiveRestartIndex({:?});", index);
      }
      let out = call_atomic_ptr_1arg(
        "glPrimitiveRestartIndex",
        &self.glPrimitiveRestartIndex_p,
        index,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glPrimitiveRestartIndex");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn PrimitiveRestartIndex_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glPrimitiveRestartIndex\0",
        &self.glPrimitiveRestartIndex_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn PrimitiveRestartIndex_is_loaded(&self) -> bool {
      !self.glPrimitiveRestartIndex_p.load(RELAX).is_null()
    }
    /// [glProvokingVertex](http://docs.gl/gl3/glProvokingVertex)(mode)
    /// * `mode` group: VertexProvokingMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProvokingVertex(&self, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ProvokingVertex({:#X});", mode);
      }
      let out = call_atomic_ptr_1arg(
        "glProvokingVertex",
        &self.glProvokingVertex_p,
        mode,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glProvokingVertex");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ProvokingVertex_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glProvokingVertex\0",
        &self.glProvokingVertex_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProvokingVertex_is_loaded(&self) -> bool {
      !self.glProvokingVertex_p.load(RELAX).is_null()
    }
    /// [glPushDebugGroup](http://docs.gl/gl3/glPushDebugGroup)(source, id, length, message)
    /// * `source` group: DebugSource
    /// * `message` len: COMPSIZE(message,length)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn PushDebugGroup(
      &self, source: GLenum, id: GLuint, length: GLsizei,
      message: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.PushDebugGroup({:#X}, {:?}, {:?}, {:p});",
          source,
          id,
          length,
          message
        );
      }
      let out = call_atomic_ptr_4arg(
        "glPushDebugGroup",
        &self.glPushDebugGroup_p,
        source,
        id,
        length,
        message,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glPushDebugGroup");
      }
      out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    #[doc(hidden)]
    pub unsafe fn PushDebugGroup_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glPushDebugGroup\0",
        &self.glPushDebugGroup_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn PushDebugGroup_is_loaded(&self) -> bool {
      !self.glPushDebugGroup_p.load(RELAX).is_null()
    }
    /// [glQueryCounter](http://docs.gl/gl3/glQueryCounter)(id, target)
    /// * `target` group: QueryCounterTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn QueryCounter(&self, id: GLuint, target: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.QueryCounter({:?}, {:#X});", id, target);
      }
      let out = call_atomic_ptr_2arg(
        "glQueryCounter",
        &self.glQueryCounter_p,
        id,
        target,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glQueryCounter");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn QueryCounter_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glQueryCounter\0",
        &self.glQueryCounter_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn QueryCounter_is_loaded(&self) -> bool {
      !self.glQueryCounter_p.load(RELAX).is_null()
    }
    /// [glReadBuffer](http://docs.gl/gl3/glReadBuffer)(src)
    /// * `src` group: ReadBufferMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ReadBuffer(&self, src: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ReadBuffer({:#X});", src);
      }
      let out = call_atomic_ptr_1arg("glReadBuffer", &self.glReadBuffer_p, src);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glReadBuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ReadBuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glReadBuffer\0",
        &self.glReadBuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ReadBuffer_is_loaded(&self) -> bool {
      !self.glReadBuffer_p.load(RELAX).is_null()
    }
    /// [glReadPixels](http://docs.gl/gl3/glReadPixels)(x, y, width, height, format, type_, pixels)
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width,height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ReadPixels(
      &self, x: GLint, y: GLint, width: GLsizei, height: GLsizei,
      format: GLenum, type_: GLenum, pixels: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ReadPixels({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
          x,
          y,
          width,
          height,
          format,
          type_,
          pixels
        );
      }
      let out = call_atomic_ptr_7arg(
        "glReadPixels",
        &self.glReadPixels_p,
        x,
        y,
        width,
        height,
        format,
        type_,
        pixels,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glReadPixels");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ReadPixels_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glReadPixels\0",
        &self.glReadPixels_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ReadPixels_is_loaded(&self) -> bool {
      !self.glReadPixels_p.load(RELAX).is_null()
    }
    /// [glRenderbufferStorage](http://docs.gl/gl3/glRenderbufferStorage)(target, internalformat, width, height)
    /// * `target` group: RenderbufferTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn RenderbufferStorage(
      &self, target: GLenum, internalformat: GLenum, width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.RenderbufferStorage({:#X}, {:#X}, {:?}, {:?});",
          target,
          internalformat,
          width,
          height
        );
      }
      let out = call_atomic_ptr_4arg(
        "glRenderbufferStorage",
        &self.glRenderbufferStorage_p,
        target,
        internalformat,
        width,
        height,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glRenderbufferStorage");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn RenderbufferStorage_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glRenderbufferStorage\0",
        &self.glRenderbufferStorage_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn RenderbufferStorage_is_loaded(&self) -> bool {
      !self.glRenderbufferStorage_p.load(RELAX).is_null()
    }
    /// [glRenderbufferStorageMultisample](http://docs.gl/gl3/glRenderbufferStorageMultisample)(target, samples, internalformat, width, height)
    /// * `target` group: RenderbufferTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn RenderbufferStorageMultisample(
      &self, target: GLenum, samples: GLsizei, internalformat: GLenum,
      width: GLsizei, height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.RenderbufferStorageMultisample({:#X}, {:?}, {:#X}, {:?}, {:?});", target, samples, internalformat, width, height);
      }
      let out = call_atomic_ptr_5arg(
        "glRenderbufferStorageMultisample",
        &self.glRenderbufferStorageMultisample_p,
        target,
        samples,
        internalformat,
        width,
        height,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glRenderbufferStorageMultisample");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn RenderbufferStorageMultisample_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glRenderbufferStorageMultisample\0",
        &self.glRenderbufferStorageMultisample_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn RenderbufferStorageMultisample_is_loaded(&self) -> bool {
      !self.glRenderbufferStorageMultisample_p.load(RELAX).is_null()
    }
    /// [glSampleCoverage](http://docs.gl/gl3/glSampleCoverage)(value, invert)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SampleCoverage(&self, value: GLfloat, invert: GLboolean) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.SampleCoverage({:?}, {:?});", value, invert);
      }
      let out = call_atomic_ptr_2arg(
        "glSampleCoverage",
        &self.glSampleCoverage_p,
        value,
        invert,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glSampleCoverage");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn SampleCoverage_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glSampleCoverage\0",
        &self.glSampleCoverage_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn SampleCoverage_is_loaded(&self) -> bool {
      !self.glSampleCoverage_p.load(RELAX).is_null()
    }
    /// [glSampleMaski](http://docs.gl/gl3/glSampleMask)(maskNumber, mask)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SampleMaski(&self, maskNumber: GLuint, mask: GLbitfield) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.SampleMaski({:?}, {:?});", maskNumber, mask);
      }
      let out = call_atomic_ptr_2arg(
        "glSampleMaski",
        &self.glSampleMaski_p,
        maskNumber,
        mask,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glSampleMaski");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn SampleMaski_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glSampleMaski\0",
        &self.glSampleMaski_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn SampleMaski_is_loaded(&self) -> bool {
      !self.glSampleMaski_p.load(RELAX).is_null()
    }
    /// [glSamplerParameterIiv](http://docs.gl/gl3/glSamplerParameter)(sampler, pname, param)
    /// * `pname` group: SamplerParameterI
    /// * `param` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SamplerParameterIiv(
      &self, sampler: GLuint, pname: GLenum, param: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SamplerParameterIiv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          param
        );
      }
      let out = call_atomic_ptr_3arg(
        "glSamplerParameterIiv",
        &self.glSamplerParameterIiv_p,
        sampler,
        pname,
        param,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glSamplerParameterIiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn SamplerParameterIiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glSamplerParameterIiv\0",
        &self.glSamplerParameterIiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn SamplerParameterIiv_is_loaded(&self) -> bool {
      !self.glSamplerParameterIiv_p.load(RELAX).is_null()
    }
    /// [glSamplerParameterIuiv](http://docs.gl/gl3/glSamplerParameter)(sampler, pname, param)
    /// * `pname` group: SamplerParameterI
    /// * `param` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SamplerParameterIuiv(
      &self, sampler: GLuint, pname: GLenum, param: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SamplerParameterIuiv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          param
        );
      }
      let out = call_atomic_ptr_3arg(
        "glSamplerParameterIuiv",
        &self.glSamplerParameterIuiv_p,
        sampler,
        pname,
        param,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glSamplerParameterIuiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn SamplerParameterIuiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glSamplerParameterIuiv\0",
        &self.glSamplerParameterIuiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn SamplerParameterIuiv_is_loaded(&self) -> bool {
      !self.glSamplerParameterIuiv_p.load(RELAX).is_null()
    }
    /// [glSamplerParameterf](http://docs.gl/gl3/glSamplerParameter)(sampler, pname, param)
    /// * `pname` group: SamplerParameterF
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SamplerParameterf(
      &self, sampler: GLuint, pname: GLenum, param: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SamplerParameterf({:?}, {:#X}, {:?});",
          sampler,
          pname,
          param
        );
      }
      let out = call_atomic_ptr_3arg(
        "glSamplerParameterf",
        &self.glSamplerParameterf_p,
        sampler,
        pname,
        param,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glSamplerParameterf");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn SamplerParameterf_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glSamplerParameterf\0",
        &self.glSamplerParameterf_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn SamplerParameterf_is_loaded(&self) -> bool {
      !self.glSamplerParameterf_p.load(RELAX).is_null()
    }
    /// [glSamplerParameterfv](http://docs.gl/gl3/glSamplerParameter)(sampler, pname, param)
    /// * `pname` group: SamplerParameterF
    /// * `param` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SamplerParameterfv(
      &self, sampler: GLuint, pname: GLenum, param: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SamplerParameterfv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          param
        );
      }
      let out = call_atomic_ptr_3arg(
        "glSamplerParameterfv",
        &self.glSamplerParameterfv_p,
        sampler,
        pname,
        param,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glSamplerParameterfv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn SamplerParameterfv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glSamplerParameterfv\0",
        &self.glSamplerParameterfv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn SamplerParameterfv_is_loaded(&self) -> bool {
      !self.glSamplerParameterfv_p.load(RELAX).is_null()
    }
    /// [glSamplerParameteri](http://docs.gl/gl3/glSamplerParameter)(sampler, pname, param)
    /// * `pname` group: SamplerParameterI
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SamplerParameteri(
      &self, sampler: GLuint, pname: GLenum, param: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SamplerParameteri({:?}, {:#X}, {:?});",
          sampler,
          pname,
          param
        );
      }
      let out = call_atomic_ptr_3arg(
        "glSamplerParameteri",
        &self.glSamplerParameteri_p,
        sampler,
        pname,
        param,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glSamplerParameteri");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn SamplerParameteri_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glSamplerParameteri\0",
        &self.glSamplerParameteri_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn SamplerParameteri_is_loaded(&self) -> bool {
      !self.glSamplerParameteri_p.load(RELAX).is_null()
    }
    /// [glSamplerParameteriv](http://docs.gl/gl3/glSamplerParameter)(sampler, pname, param)
    /// * `pname` group: SamplerParameterI
    /// * `param` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SamplerParameteriv(
      &self, sampler: GLuint, pname: GLenum, param: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SamplerParameteriv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          param
        );
      }
      let out = call_atomic_ptr_3arg(
        "glSamplerParameteriv",
        &self.glSamplerParameteriv_p,
        sampler,
        pname,
        param,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glSamplerParameteriv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn SamplerParameteriv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glSamplerParameteriv\0",
        &self.glSamplerParameteriv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn SamplerParameteriv_is_loaded(&self) -> bool {
      !self.glSamplerParameteriv_p.load(RELAX).is_null()
    }
    /// [glScissor](http://docs.gl/gl3/glScissor)(x, y, width, height)
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Scissor(
      &self, x: GLint, y: GLint, width: GLsizei, height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Scissor({:?}, {:?}, {:?}, {:?});",
          x,
          y,
          width,
          height
        );
      }
      let out = call_atomic_ptr_4arg(
        "glScissor",
        &self.glScissor_p,
        x,
        y,
        width,
        height,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glScissor");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Scissor_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glScissor\0",
        &self.glScissor_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Scissor_is_loaded(&self) -> bool {
      !self.glScissor_p.load(RELAX).is_null()
    }
    /// [glShaderSource](http://docs.gl/gl3/glShaderSource)(shader, count, string, length)
    /// * `string` len: count
    /// * `length` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ShaderSource(
      &self, shader: GLuint, count: GLsizei, string: *const *const GLchar,
      length: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ShaderSource({:?}, {:?}, {:p}, {:p});",
          shader,
          count,
          string,
          length
        );
      }
      let out = call_atomic_ptr_4arg(
        "glShaderSource",
        &self.glShaderSource_p,
        shader,
        count,
        string,
        length,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glShaderSource");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ShaderSource_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glShaderSource\0",
        &self.glShaderSource_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ShaderSource_is_loaded(&self) -> bool {
      !self.glShaderSource_p.load(RELAX).is_null()
    }
    /// [glStencilFunc](http://docs.gl/gl3/glStencilFunc)(func, ref_, mask)
    /// * `func` group: StencilFunction
    /// * `ref_` group: StencilValue
    /// * `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn StencilFunc(&self, func: GLenum, ref_: GLint, mask: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.StencilFunc({:#X}, {:?}, {:?});", func, ref_, mask);
      }
      let out = call_atomic_ptr_3arg(
        "glStencilFunc",
        &self.glStencilFunc_p,
        func,
        ref_,
        mask,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glStencilFunc");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn StencilFunc_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glStencilFunc\0",
        &self.glStencilFunc_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn StencilFunc_is_loaded(&self) -> bool {
      !self.glStencilFunc_p.load(RELAX).is_null()
    }
    /// [glStencilFuncSeparate](http://docs.gl/gl3/glStencilFuncSeparate)(face, func, ref_, mask)
    /// * `face` group: StencilFaceDirection
    /// * `func` group: StencilFunction
    /// * `ref_` group: StencilValue
    /// * `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn StencilFuncSeparate(
      &self, face: GLenum, func: GLenum, ref_: GLint, mask: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.StencilFuncSeparate({:#X}, {:#X}, {:?}, {:?});",
          face,
          func,
          ref_,
          mask
        );
      }
      let out = call_atomic_ptr_4arg(
        "glStencilFuncSeparate",
        &self.glStencilFuncSeparate_p,
        face,
        func,
        ref_,
        mask,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glStencilFuncSeparate");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn StencilFuncSeparate_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glStencilFuncSeparate\0",
        &self.glStencilFuncSeparate_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn StencilFuncSeparate_is_loaded(&self) -> bool {
      !self.glStencilFuncSeparate_p.load(RELAX).is_null()
    }
    /// [glStencilMask](http://docs.gl/gl3/glStencilMask)(mask)
    /// * `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn StencilMask(&self, mask: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.StencilMask({:?});", mask);
      }
      let out =
        call_atomic_ptr_1arg("glStencilMask", &self.glStencilMask_p, mask);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glStencilMask");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn StencilMask_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glStencilMask\0",
        &self.glStencilMask_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn StencilMask_is_loaded(&self) -> bool {
      !self.glStencilMask_p.load(RELAX).is_null()
    }
    /// [glStencilMaskSeparate](http://docs.gl/gl3/glStencilMaskSeparate)(face, mask)
    /// * `face` group: StencilFaceDirection
    /// * `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn StencilMaskSeparate(&self, face: GLenum, mask: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.StencilMaskSeparate({:#X}, {:?});", face, mask);
      }
      let out = call_atomic_ptr_2arg(
        "glStencilMaskSeparate",
        &self.glStencilMaskSeparate_p,
        face,
        mask,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glStencilMaskSeparate");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn StencilMaskSeparate_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glStencilMaskSeparate\0",
        &self.glStencilMaskSeparate_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn StencilMaskSeparate_is_loaded(&self) -> bool {
      !self.glStencilMaskSeparate_p.load(RELAX).is_null()
    }
    /// [glStencilOp](http://docs.gl/gl3/glStencilOp)(fail, zfail, zpass)
    /// * `fail` group: StencilOp
    /// * `zfail` group: StencilOp
    /// * `zpass` group: StencilOp
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn StencilOp(&self, fail: GLenum, zfail: GLenum, zpass: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.StencilOp({:#X}, {:#X}, {:#X});",
          fail,
          zfail,
          zpass
        );
      }
      let out = call_atomic_ptr_3arg(
        "glStencilOp",
        &self.glStencilOp_p,
        fail,
        zfail,
        zpass,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glStencilOp");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn StencilOp_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glStencilOp\0",
        &self.glStencilOp_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn StencilOp_is_loaded(&self) -> bool {
      !self.glStencilOp_p.load(RELAX).is_null()
    }
    /// [glStencilOpSeparate](http://docs.gl/gl3/glStencilOpSeparate)(face, sfail, dpfail, dppass)
    /// * `face` group: StencilFaceDirection
    /// * `sfail` group: StencilOp
    /// * `dpfail` group: StencilOp
    /// * `dppass` group: StencilOp
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn StencilOpSeparate(
      &self, face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.StencilOpSeparate({:#X}, {:#X}, {:#X}, {:#X});",
          face,
          sfail,
          dpfail,
          dppass
        );
      }
      let out = call_atomic_ptr_4arg(
        "glStencilOpSeparate",
        &self.glStencilOpSeparate_p,
        face,
        sfail,
        dpfail,
        dppass,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glStencilOpSeparate");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn StencilOpSeparate_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glStencilOpSeparate\0",
        &self.glStencilOpSeparate_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn StencilOpSeparate_is_loaded(&self) -> bool {
      !self.glStencilOpSeparate_p.load(RELAX).is_null()
    }
    /// [glTexBuffer](http://docs.gl/gl3/glTexBuffer)(target, internalformat, buffer)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexBuffer(
      &self, target: GLenum, internalformat: GLenum, buffer: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexBuffer({:#X}, {:#X}, {:?});",
          target,
          internalformat,
          buffer
        );
      }
      let out = call_atomic_ptr_3arg(
        "glTexBuffer",
        &self.glTexBuffer_p,
        target,
        internalformat,
        buffer,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexBuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexBuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexBuffer\0",
        &self.glTexBuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexBuffer_is_loaded(&self) -> bool {
      !self.glTexBuffer_p.load(RELAX).is_null()
    }
    /// [glTexImage1D](http://docs.gl/gl3/glTexImage1D)(target, level, internalformat, width, border, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `border` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexImage1D(
      &self, target: GLenum, level: GLint, internalformat: GLint,
      width: GLsizei, border: GLint, format: GLenum, type_: GLenum,
      pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexImage1D({:#X}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, border, format, type_, pixels);
      }
      let out = call_atomic_ptr_8arg(
        "glTexImage1D",
        &self.glTexImage1D_p,
        target,
        level,
        internalformat,
        width,
        border,
        format,
        type_,
        pixels,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexImage1D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexImage1D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexImage1D\0",
        &self.glTexImage1D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexImage1D_is_loaded(&self) -> bool {
      !self.glTexImage1D_p.load(RELAX).is_null()
    }
    /// [glTexImage2D](http://docs.gl/gl3/glTexImage2D)(target, level, internalformat, width, height, border, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `border` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width,height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexImage2D(
      &self, target: GLenum, level: GLint, internalformat: GLint,
      width: GLsizei, height: GLsizei, border: GLint, format: GLenum,
      type_: GLenum, pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, height, border, format, type_, pixels);
      }
      let out = call_atomic_ptr_9arg(
        "glTexImage2D",
        &self.glTexImage2D_p,
        target,
        level,
        internalformat,
        width,
        height,
        border,
        format,
        type_,
        pixels,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexImage2D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexImage2D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexImage2D\0",
        &self.glTexImage2D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexImage2D_is_loaded(&self) -> bool {
      !self.glTexImage2D_p.load(RELAX).is_null()
    }
    /// [glTexImage2DMultisample](http://docs.gl/gl3/glTexImage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexImage2DMultisample(
      &self, target: GLenum, samples: GLsizei, internalformat: GLenum,
      width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexImage2DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, fixedsamplelocations);
      }
      let out = call_atomic_ptr_6arg(
        "glTexImage2DMultisample",
        &self.glTexImage2DMultisample_p,
        target,
        samples,
        internalformat,
        width,
        height,
        fixedsamplelocations,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexImage2DMultisample");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexImage2DMultisample_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexImage2DMultisample\0",
        &self.glTexImage2DMultisample_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexImage2DMultisample_is_loaded(&self) -> bool {
      !self.glTexImage2DMultisample_p.load(RELAX).is_null()
    }
    /// [glTexImage3D](http://docs.gl/gl3/glTexImage3D)(target, level, internalformat, width, height, depth, border, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `border` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width,height,depth)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexImage3D(
      &self, target: GLenum, level: GLint, internalformat: GLint,
      width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint,
      format: GLenum, type_: GLenum, pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, height, depth, border, format, type_, pixels);
      }
      let out = call_atomic_ptr_10arg(
        "glTexImage3D",
        &self.glTexImage3D_p,
        target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        format,
        type_,
        pixels,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexImage3D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexImage3D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexImage3D\0",
        &self.glTexImage3D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexImage3D_is_loaded(&self) -> bool {
      !self.glTexImage3D_p.load(RELAX).is_null()
    }
    /// [glTexImage3DMultisample](http://docs.gl/gl3/glTexImage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexImage3DMultisample(
      &self, target: GLenum, samples: GLsizei, internalformat: GLenum,
      width: GLsizei, height: GLsizei, depth: GLsizei,
      fixedsamplelocations: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexImage3DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, depth, fixedsamplelocations);
      }
      let out = call_atomic_ptr_7arg(
        "glTexImage3DMultisample",
        &self.glTexImage3DMultisample_p,
        target,
        samples,
        internalformat,
        width,
        height,
        depth,
        fixedsamplelocations,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexImage3DMultisample");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexImage3DMultisample_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexImage3DMultisample\0",
        &self.glTexImage3DMultisample_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexImage3DMultisample_is_loaded(&self) -> bool {
      !self.glTexImage3DMultisample_p.load(RELAX).is_null()
    }
    /// [glTexParameterIiv](http://docs.gl/gl3/glTexParameter)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: TextureParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexParameterIiv(
      &self, target: GLenum, pname: GLenum, params: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexParameterIiv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glTexParameterIiv",
        &self.glTexParameterIiv_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexParameterIiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexParameterIiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexParameterIiv\0",
        &self.glTexParameterIiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexParameterIiv_is_loaded(&self) -> bool {
      !self.glTexParameterIiv_p.load(RELAX).is_null()
    }
    /// [glTexParameterIuiv](http://docs.gl/gl3/glTexParameter)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: TextureParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexParameterIuiv(
      &self, target: GLenum, pname: GLenum, params: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexParameterIuiv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glTexParameterIuiv",
        &self.glTexParameterIuiv_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexParameterIuiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexParameterIuiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexParameterIuiv\0",
        &self.glTexParameterIuiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexParameterIuiv_is_loaded(&self) -> bool {
      !self.glTexParameterIuiv_p.load(RELAX).is_null()
    }
    /// [glTexParameterf](http://docs.gl/gl3/glTexParameter)(target, pname, param)
    /// * `target` group: TextureTarget
    /// * `pname` group: TextureParameterName
    /// * `param` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexParameterf(
      &self, target: GLenum, pname: GLenum, param: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexParameterf({:#X}, {:#X}, {:?});",
          target,
          pname,
          param
        );
      }
      let out = call_atomic_ptr_3arg(
        "glTexParameterf",
        &self.glTexParameterf_p,
        target,
        pname,
        param,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexParameterf");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexParameterf_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexParameterf\0",
        &self.glTexParameterf_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexParameterf_is_loaded(&self) -> bool {
      !self.glTexParameterf_p.load(RELAX).is_null()
    }
    /// [glTexParameterfv](http://docs.gl/gl3/glTexParameter)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: TextureParameterName
    /// * `params` group: CheckedFloat32
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexParameterfv(
      &self, target: GLenum, pname: GLenum, params: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexParameterfv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glTexParameterfv",
        &self.glTexParameterfv_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexParameterfv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexParameterfv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexParameterfv\0",
        &self.glTexParameterfv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexParameterfv_is_loaded(&self) -> bool {
      !self.glTexParameterfv_p.load(RELAX).is_null()
    }
    /// [glTexParameteri](http://docs.gl/gl3/glTexParameter)(target, pname, param)
    /// * `target` group: TextureTarget
    /// * `pname` group: TextureParameterName
    /// * `param` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexParameteri(
      &self, target: GLenum, pname: GLenum, param: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexParameteri({:#X}, {:#X}, {:?});",
          target,
          pname,
          param
        );
      }
      let out = call_atomic_ptr_3arg(
        "glTexParameteri",
        &self.glTexParameteri_p,
        target,
        pname,
        param,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexParameteri");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexParameteri_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexParameteri\0",
        &self.glTexParameteri_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexParameteri_is_loaded(&self) -> bool {
      !self.glTexParameteri_p.load(RELAX).is_null()
    }
    /// [glTexParameteriv](http://docs.gl/gl3/glTexParameter)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: TextureParameterName
    /// * `params` group: CheckedInt32
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexParameteriv(
      &self, target: GLenum, pname: GLenum, params: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexParameteriv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let out = call_atomic_ptr_3arg(
        "glTexParameteriv",
        &self.glTexParameteriv_p,
        target,
        pname,
        params,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexParameteriv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexParameteriv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexParameteriv\0",
        &self.glTexParameteriv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexParameteriv_is_loaded(&self) -> bool {
      !self.glTexParameteriv_p.load(RELAX).is_null()
    }
    /// [glTexSubImage1D](http://docs.gl/gl3/glTexSubImage1D)(target, level, xoffset, width, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexSubImage1D(
      &self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei,
      format: GLenum, type_: GLenum, pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, xoffset, width, format, type_, pixels);
      }
      let out = call_atomic_ptr_7arg(
        "glTexSubImage1D",
        &self.glTexSubImage1D_p,
        target,
        level,
        xoffset,
        width,
        format,
        type_,
        pixels,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexSubImage1D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexSubImage1D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexSubImage1D\0",
        &self.glTexSubImage1D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexSubImage1D_is_loaded(&self) -> bool {
      !self.glTexSubImage1D_p.load(RELAX).is_null()
    }
    /// [glTexSubImage2D](http://docs.gl/gl3/glTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `yoffset` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width,height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexSubImage2D(
      &self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,
      width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum,
      pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, xoffset, yoffset, width, height, format, type_, pixels);
      }
      let out = call_atomic_ptr_9arg(
        "glTexSubImage2D",
        &self.glTexSubImage2D_p,
        target,
        level,
        xoffset,
        yoffset,
        width,
        height,
        format,
        type_,
        pixels,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexSubImage2D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexSubImage2D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexSubImage2D\0",
        &self.glTexSubImage2D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexSubImage2D_is_loaded(&self) -> bool {
      !self.glTexSubImage2D_p.load(RELAX).is_null()
    }
    /// [glTexSubImage3D](http://docs.gl/gl3/glTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `yoffset` group: CheckedInt32
    /// * `zoffset` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width,height,depth)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexSubImage3D(
      &self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,
      zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei,
      format: GLenum, type_: GLenum, pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels);
      }
      let out = call_atomic_ptr_11arg(
        "glTexSubImage3D",
        &self.glTexSubImage3D_p,
        target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        type_,
        pixels,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTexSubImage3D");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TexSubImage3D_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTexSubImage3D\0",
        &self.glTexSubImage3D_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexSubImage3D_is_loaded(&self) -> bool {
      !self.glTexSubImage3D_p.load(RELAX).is_null()
    }
    /// [glTransformFeedbackVaryings](http://docs.gl/gl3/glTransformFeedbackVaryings)(program, count, varyings, bufferMode)
    /// * `varyings` len: count
    /// * `bufferMode` group: TransformFeedbackBufferMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TransformFeedbackVaryings(
      &self, program: GLuint, count: GLsizei, varyings: *const *const GLchar,
      bufferMode: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TransformFeedbackVaryings({:?}, {:?}, {:p}, {:#X});",
          program,
          count,
          varyings,
          bufferMode
        );
      }
      let out = call_atomic_ptr_4arg(
        "glTransformFeedbackVaryings",
        &self.glTransformFeedbackVaryings_p,
        program,
        count,
        varyings,
        bufferMode,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glTransformFeedbackVaryings");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn TransformFeedbackVaryings_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glTransformFeedbackVaryings\0",
        &self.glTransformFeedbackVaryings_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn TransformFeedbackVaryings_is_loaded(&self) -> bool {
      !self.glTransformFeedbackVaryings_p.load(RELAX).is_null()
    }
    /// [glUniform1f](http://docs.gl/gl3/glUniform)(location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1f(&self, location: GLint, v0: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform1f({:?}, {:?});", location, v0);
      }
      let out =
        call_atomic_ptr_2arg("glUniform1f", &self.glUniform1f_p, location, v0);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform1f");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform1f_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform1f\0",
        &self.glUniform1f_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1f_is_loaded(&self) -> bool {
      !self.glUniform1f_p.load(RELAX).is_null()
    }
    /// [glUniform1fv](http://docs.gl/gl3/glUniform)(location, count, value)
    /// * `value` len: count*1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1fv(
      &self, location: GLint, count: GLsizei, value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform1fv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniform1fv",
        &self.glUniform1fv_p,
        location,
        count,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform1fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform1fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform1fv\0",
        &self.glUniform1fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1fv_is_loaded(&self) -> bool {
      !self.glUniform1fv_p.load(RELAX).is_null()
    }
    /// [glUniform1i](http://docs.gl/gl3/glUniform)(location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1i(&self, location: GLint, v0: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform1i({:?}, {:?});", location, v0);
      }
      let out =
        call_atomic_ptr_2arg("glUniform1i", &self.glUniform1i_p, location, v0);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform1i");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform1i_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform1i\0",
        &self.glUniform1i_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1i_is_loaded(&self) -> bool {
      !self.glUniform1i_p.load(RELAX).is_null()
    }
    /// [glUniform1iv](http://docs.gl/gl3/glUniform)(location, count, value)
    /// * `value` len: count*1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1iv(
      &self, location: GLint, count: GLsizei, value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform1iv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniform1iv",
        &self.glUniform1iv_p,
        location,
        count,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform1iv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform1iv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform1iv\0",
        &self.glUniform1iv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1iv_is_loaded(&self) -> bool {
      !self.glUniform1iv_p.load(RELAX).is_null()
    }
    /// [glUniform1ui](http://docs.gl/gl3/glUniform)(location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1ui(&self, location: GLint, v0: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform1ui({:?}, {:?});", location, v0);
      }
      let out = call_atomic_ptr_2arg(
        "glUniform1ui",
        &self.glUniform1ui_p,
        location,
        v0,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform1ui");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform1ui_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform1ui\0",
        &self.glUniform1ui_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1ui_is_loaded(&self) -> bool {
      !self.glUniform1ui_p.load(RELAX).is_null()
    }
    /// [glUniform1uiv](http://docs.gl/gl3/glUniform)(location, count, value)
    /// * `value` len: count*1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1uiv(
      &self, location: GLint, count: GLsizei, value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform1uiv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniform1uiv",
        &self.glUniform1uiv_p,
        location,
        count,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform1uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform1uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform1uiv\0",
        &self.glUniform1uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1uiv_is_loaded(&self) -> bool {
      !self.glUniform1uiv_p.load(RELAX).is_null()
    }
    /// [glUniform2f](http://docs.gl/gl3/glUniform)(location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2f(&self, location: GLint, v0: GLfloat, v1: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform2f({:?}, {:?}, {:?});", location, v0, v1);
      }
      let out = call_atomic_ptr_3arg(
        "glUniform2f",
        &self.glUniform2f_p,
        location,
        v0,
        v1,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform2f");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform2f_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform2f\0",
        &self.glUniform2f_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2f_is_loaded(&self) -> bool {
      !self.glUniform2f_p.load(RELAX).is_null()
    }
    /// [glUniform2fv](http://docs.gl/gl3/glUniform)(location, count, value)
    /// * `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2fv(
      &self, location: GLint, count: GLsizei, value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform2fv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniform2fv",
        &self.glUniform2fv_p,
        location,
        count,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform2fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform2fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform2fv\0",
        &self.glUniform2fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2fv_is_loaded(&self) -> bool {
      !self.glUniform2fv_p.load(RELAX).is_null()
    }
    /// [glUniform2i](http://docs.gl/gl3/glUniform)(location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2i(&self, location: GLint, v0: GLint, v1: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform2i({:?}, {:?}, {:?});", location, v0, v1);
      }
      let out = call_atomic_ptr_3arg(
        "glUniform2i",
        &self.glUniform2i_p,
        location,
        v0,
        v1,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform2i");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform2i_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform2i\0",
        &self.glUniform2i_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2i_is_loaded(&self) -> bool {
      !self.glUniform2i_p.load(RELAX).is_null()
    }
    /// [glUniform2iv](http://docs.gl/gl3/glUniform)(location, count, value)
    /// * `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2iv(
      &self, location: GLint, count: GLsizei, value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform2iv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniform2iv",
        &self.glUniform2iv_p,
        location,
        count,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform2iv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform2iv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform2iv\0",
        &self.glUniform2iv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2iv_is_loaded(&self) -> bool {
      !self.glUniform2iv_p.load(RELAX).is_null()
    }
    /// [glUniform2ui](http://docs.gl/gl3/glUniform)(location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2ui(&self, location: GLint, v0: GLuint, v1: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform2ui({:?}, {:?}, {:?});", location, v0, v1);
      }
      let out = call_atomic_ptr_3arg(
        "glUniform2ui",
        &self.glUniform2ui_p,
        location,
        v0,
        v1,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform2ui");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform2ui_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform2ui\0",
        &self.glUniform2ui_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2ui_is_loaded(&self) -> bool {
      !self.glUniform2ui_p.load(RELAX).is_null()
    }
    /// [glUniform2uiv](http://docs.gl/gl3/glUniform)(location, count, value)
    /// * `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2uiv(
      &self, location: GLint, count: GLsizei, value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform2uiv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniform2uiv",
        &self.glUniform2uiv_p,
        location,
        count,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform2uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform2uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform2uiv\0",
        &self.glUniform2uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2uiv_is_loaded(&self) -> bool {
      !self.glUniform2uiv_p.load(RELAX).is_null()
    }
    /// [glUniform3f](http://docs.gl/gl3/glUniform)(location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3f(
      &self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3f({:?}, {:?}, {:?}, {:?});",
          location,
          v0,
          v1,
          v2
        );
      }
      let out = call_atomic_ptr_4arg(
        "glUniform3f",
        &self.glUniform3f_p,
        location,
        v0,
        v1,
        v2,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform3f");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform3f_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform3f\0",
        &self.glUniform3f_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3f_is_loaded(&self) -> bool {
      !self.glUniform3f_p.load(RELAX).is_null()
    }
    /// [glUniform3fv](http://docs.gl/gl3/glUniform)(location, count, value)
    /// * `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3fv(
      &self, location: GLint, count: GLsizei, value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3fv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniform3fv",
        &self.glUniform3fv_p,
        location,
        count,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform3fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform3fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform3fv\0",
        &self.glUniform3fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3fv_is_loaded(&self) -> bool {
      !self.glUniform3fv_p.load(RELAX).is_null()
    }
    /// [glUniform3i](http://docs.gl/gl3/glUniform)(location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3i(
      &self, location: GLint, v0: GLint, v1: GLint, v2: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3i({:?}, {:?}, {:?}, {:?});",
          location,
          v0,
          v1,
          v2
        );
      }
      let out = call_atomic_ptr_4arg(
        "glUniform3i",
        &self.glUniform3i_p,
        location,
        v0,
        v1,
        v2,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform3i");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform3i_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform3i\0",
        &self.glUniform3i_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3i_is_loaded(&self) -> bool {
      !self.glUniform3i_p.load(RELAX).is_null()
    }
    /// [glUniform3iv](http://docs.gl/gl3/glUniform)(location, count, value)
    /// * `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3iv(
      &self, location: GLint, count: GLsizei, value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3iv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniform3iv",
        &self.glUniform3iv_p,
        location,
        count,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform3iv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform3iv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform3iv\0",
        &self.glUniform3iv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3iv_is_loaded(&self) -> bool {
      !self.glUniform3iv_p.load(RELAX).is_null()
    }
    /// [glUniform3ui](http://docs.gl/gl3/glUniform)(location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3ui(
      &self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3ui({:?}, {:?}, {:?}, {:?});",
          location,
          v0,
          v1,
          v2
        );
      }
      let out = call_atomic_ptr_4arg(
        "glUniform3ui",
        &self.glUniform3ui_p,
        location,
        v0,
        v1,
        v2,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform3ui");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform3ui_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform3ui\0",
        &self.glUniform3ui_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3ui_is_loaded(&self) -> bool {
      !self.glUniform3ui_p.load(RELAX).is_null()
    }
    /// [glUniform3uiv](http://docs.gl/gl3/glUniform)(location, count, value)
    /// * `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3uiv(
      &self, location: GLint, count: GLsizei, value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3uiv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniform3uiv",
        &self.glUniform3uiv_p,
        location,
        count,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform3uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform3uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform3uiv\0",
        &self.glUniform3uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3uiv_is_loaded(&self) -> bool {
      !self.glUniform3uiv_p.load(RELAX).is_null()
    }
    /// [glUniform4f](http://docs.gl/gl3/glUniform)(location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4f(
      &self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat,
      v3: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4f({:?}, {:?}, {:?}, {:?}, {:?});",
          location,
          v0,
          v1,
          v2,
          v3
        );
      }
      let out = call_atomic_ptr_5arg(
        "glUniform4f",
        &self.glUniform4f_p,
        location,
        v0,
        v1,
        v2,
        v3,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform4f");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform4f_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform4f\0",
        &self.glUniform4f_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4f_is_loaded(&self) -> bool {
      !self.glUniform4f_p.load(RELAX).is_null()
    }
    /// [glUniform4fv](http://docs.gl/gl3/glUniform)(location, count, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4fv(
      &self, location: GLint, count: GLsizei, value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4fv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniform4fv",
        &self.glUniform4fv_p,
        location,
        count,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform4fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform4fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform4fv\0",
        &self.glUniform4fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4fv_is_loaded(&self) -> bool {
      !self.glUniform4fv_p.load(RELAX).is_null()
    }
    /// [glUniform4i](http://docs.gl/gl3/glUniform)(location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4i(
      &self, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4i({:?}, {:?}, {:?}, {:?}, {:?});",
          location,
          v0,
          v1,
          v2,
          v3
        );
      }
      let out = call_atomic_ptr_5arg(
        "glUniform4i",
        &self.glUniform4i_p,
        location,
        v0,
        v1,
        v2,
        v3,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform4i");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform4i_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform4i\0",
        &self.glUniform4i_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4i_is_loaded(&self) -> bool {
      !self.glUniform4i_p.load(RELAX).is_null()
    }
    /// [glUniform4iv](http://docs.gl/gl3/glUniform)(location, count, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4iv(
      &self, location: GLint, count: GLsizei, value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4iv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniform4iv",
        &self.glUniform4iv_p,
        location,
        count,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform4iv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform4iv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform4iv\0",
        &self.glUniform4iv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4iv_is_loaded(&self) -> bool {
      !self.glUniform4iv_p.load(RELAX).is_null()
    }
    /// [glUniform4ui](http://docs.gl/gl3/glUniform)(location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4ui(
      &self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4ui({:?}, {:?}, {:?}, {:?}, {:?});",
          location,
          v0,
          v1,
          v2,
          v3
        );
      }
      let out = call_atomic_ptr_5arg(
        "glUniform4ui",
        &self.glUniform4ui_p,
        location,
        v0,
        v1,
        v2,
        v3,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform4ui");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform4ui_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform4ui\0",
        &self.glUniform4ui_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4ui_is_loaded(&self) -> bool {
      !self.glUniform4ui_p.load(RELAX).is_null()
    }
    /// [glUniform4uiv](http://docs.gl/gl3/glUniform)(location, count, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4uiv(
      &self, location: GLint, count: GLsizei, value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4uiv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniform4uiv",
        &self.glUniform4uiv_p,
        location,
        count,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniform4uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Uniform4uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniform4uiv\0",
        &self.glUniform4uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4uiv_is_loaded(&self) -> bool {
      !self.glUniform4uiv_p.load(RELAX).is_null()
    }
    /// [glUniformBlockBinding](http://docs.gl/gl3/glUniformBlockBinding)(program, uniformBlockIndex, uniformBlockBinding)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformBlockBinding(
      &self, program: GLuint, uniformBlockIndex: GLuint,
      uniformBlockBinding: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformBlockBinding({:?}, {:?}, {:?});",
          program,
          uniformBlockIndex,
          uniformBlockBinding
        );
      }
      let out = call_atomic_ptr_3arg(
        "glUniformBlockBinding",
        &self.glUniformBlockBinding_p,
        program,
        uniformBlockIndex,
        uniformBlockBinding,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniformBlockBinding");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn UniformBlockBinding_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniformBlockBinding\0",
        &self.glUniformBlockBinding_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformBlockBinding_is_loaded(&self) -> bool {
      !self.glUniformBlockBinding_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix2fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix2fv(
      &self, location: GLint, count: GLsizei, transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix2fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glUniformMatrix2fv",
        &self.glUniformMatrix2fv_p,
        location,
        count,
        transpose,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniformMatrix2fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn UniformMatrix2fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniformMatrix2fv\0",
        &self.glUniformMatrix2fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix2fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix2fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix2x3fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
    /// * `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix2x3fv(
      &self, location: GLint, count: GLsizei, transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix2x3fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glUniformMatrix2x3fv",
        &self.glUniformMatrix2x3fv_p,
        location,
        count,
        transpose,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniformMatrix2x3fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn UniformMatrix2x3fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniformMatrix2x3fv\0",
        &self.glUniformMatrix2x3fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix2x3fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix2x3fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix2x4fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
    /// * `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix2x4fv(
      &self, location: GLint, count: GLsizei, transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix2x4fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glUniformMatrix2x4fv",
        &self.glUniformMatrix2x4fv_p,
        location,
        count,
        transpose,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniformMatrix2x4fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn UniformMatrix2x4fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniformMatrix2x4fv\0",
        &self.glUniformMatrix2x4fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix2x4fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix2x4fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix3fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
    /// * `value` len: count*9
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix3fv(
      &self, location: GLint, count: GLsizei, transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix3fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glUniformMatrix3fv",
        &self.glUniformMatrix3fv_p,
        location,
        count,
        transpose,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniformMatrix3fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn UniformMatrix3fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniformMatrix3fv\0",
        &self.glUniformMatrix3fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix3fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix3fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix3x2fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
    /// * `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix3x2fv(
      &self, location: GLint, count: GLsizei, transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix3x2fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glUniformMatrix3x2fv",
        &self.glUniformMatrix3x2fv_p,
        location,
        count,
        transpose,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniformMatrix3x2fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn UniformMatrix3x2fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniformMatrix3x2fv\0",
        &self.glUniformMatrix3x2fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix3x2fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix3x2fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix3x4fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
    /// * `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix3x4fv(
      &self, location: GLint, count: GLsizei, transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix3x4fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glUniformMatrix3x4fv",
        &self.glUniformMatrix3x4fv_p,
        location,
        count,
        transpose,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniformMatrix3x4fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn UniformMatrix3x4fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniformMatrix3x4fv\0",
        &self.glUniformMatrix3x4fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix3x4fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix3x4fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix4fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
    /// * `value` len: count*16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix4fv(
      &self, location: GLint, count: GLsizei, transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix4fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glUniformMatrix4fv",
        &self.glUniformMatrix4fv_p,
        location,
        count,
        transpose,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniformMatrix4fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn UniformMatrix4fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniformMatrix4fv\0",
        &self.glUniformMatrix4fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix4fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix4fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix4x2fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
    /// * `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix4x2fv(
      &self, location: GLint, count: GLsizei, transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix4x2fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glUniformMatrix4x2fv",
        &self.glUniformMatrix4x2fv_p,
        location,
        count,
        transpose,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniformMatrix4x2fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn UniformMatrix4x2fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniformMatrix4x2fv\0",
        &self.glUniformMatrix4x2fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix4x2fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix4x2fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix4x3fv](http://docs.gl/gl3/glUniform)(location, count, transpose, value)
    /// * `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix4x3fv(
      &self, location: GLint, count: GLsizei, transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix4x3fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glUniformMatrix4x3fv",
        &self.glUniformMatrix4x3fv_p,
        location,
        count,
        transpose,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUniformMatrix4x3fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn UniformMatrix4x3fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUniformMatrix4x3fv\0",
        &self.glUniformMatrix4x3fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix4x3fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix4x3fv_p.load(RELAX).is_null()
    }
    /// [glUnmapBuffer](http://docs.gl/gl3/glUnmapBuffer)(target)
    /// * `target` group: BufferTargetARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UnmapBuffer(&self, target: GLenum) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.UnmapBuffer({:#X});", target);
      }
      let out =
        call_atomic_ptr_1arg("glUnmapBuffer", &self.glUnmapBuffer_p, target);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUnmapBuffer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn UnmapBuffer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUnmapBuffer\0",
        &self.glUnmapBuffer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn UnmapBuffer_is_loaded(&self) -> bool {
      !self.glUnmapBuffer_p.load(RELAX).is_null()
    }
    /// [glUseProgram](http://docs.gl/gl3/glUseProgram)(program)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UseProgram(&self, program: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.UseProgram({:?});", program);
      }
      let out =
        call_atomic_ptr_1arg("glUseProgram", &self.glUseProgram_p, program);
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glUseProgram");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn UseProgram_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glUseProgram\0",
        &self.glUseProgram_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn UseProgram_is_loaded(&self) -> bool {
      !self.glUseProgram_p.load(RELAX).is_null()
    }
    /// [glValidateProgram](http://docs.gl/gl3/glValidateProgram)(program)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ValidateProgram(&self, program: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ValidateProgram({:?});", program);
      }
      let out = call_atomic_ptr_1arg(
        "glValidateProgram",
        &self.glValidateProgram_p,
        program,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glValidateProgram");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn ValidateProgram_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glValidateProgram\0",
        &self.glValidateProgram_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn ValidateProgram_is_loaded(&self) -> bool {
      !self.glValidateProgram_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib1d](http://docs.gl/gl3/glVertexAttrib1d)(index, x)
    /// * vector equivalent: [`glVertexAttrib1dv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib1d(&self, index: GLuint, x: GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib1d({:?}, {:?});", index, x);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib1d",
        &self.glVertexAttrib1d_p,
        index,
        x,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib1d");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib1d_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib1d\0",
        &self.glVertexAttrib1d_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib1d_is_loaded(&self) -> bool {
      !self.glVertexAttrib1d_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib1dv](http://docs.gl/gl3/glVertexAttrib1dv)(index, v)
    /// * `v` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib1dv(&self, index: GLuint, v: *const GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib1dv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib1dv",
        &self.glVertexAttrib1dv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib1dv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib1dv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib1dv\0",
        &self.glVertexAttrib1dv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib1dv_is_loaded(&self) -> bool {
      !self.glVertexAttrib1dv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib1f](http://docs.gl/gl3/glVertexAttrib)(index, x)
    /// * vector equivalent: [`glVertexAttrib1fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib1f(&self, index: GLuint, x: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib1f({:?}, {:?});", index, x);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib1f",
        &self.glVertexAttrib1f_p,
        index,
        x,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib1f");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib1f_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib1f\0",
        &self.glVertexAttrib1f_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib1f_is_loaded(&self) -> bool {
      !self.glVertexAttrib1f_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib1fv](http://docs.gl/gl3/glVertexAttrib)(index, v)
    /// * `v` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib1fv(&self, index: GLuint, v: *const GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib1fv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib1fv",
        &self.glVertexAttrib1fv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib1fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib1fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib1fv\0",
        &self.glVertexAttrib1fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib1fv_is_loaded(&self) -> bool {
      !self.glVertexAttrib1fv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib1s](http://docs.gl/gl3/glVertexAttrib1s)(index, x)
    /// * vector equivalent: [`glVertexAttrib1sv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib1s(&self, index: GLuint, x: GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib1s({:?}, {:?});", index, x);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib1s",
        &self.glVertexAttrib1s_p,
        index,
        x,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib1s");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib1s_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib1s\0",
        &self.glVertexAttrib1s_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib1s_is_loaded(&self) -> bool {
      !self.glVertexAttrib1s_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib1sv](http://docs.gl/gl3/glVertexAttrib1sv)(index, v)
    /// * `v` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib1sv(&self, index: GLuint, v: *const GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib1sv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib1sv",
        &self.glVertexAttrib1sv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib1sv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib1sv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib1sv\0",
        &self.glVertexAttrib1sv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib1sv_is_loaded(&self) -> bool {
      !self.glVertexAttrib1sv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib2d](http://docs.gl/gl3/glVertexAttrib2d)(index, x, y)
    /// * vector equivalent: [`glVertexAttrib2dv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib2d(
      &self, index: GLuint, x: GLdouble, y: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib2d({:?}, {:?}, {:?});", index, x, y);
      }
      let out = call_atomic_ptr_3arg(
        "glVertexAttrib2d",
        &self.glVertexAttrib2d_p,
        index,
        x,
        y,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib2d");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib2d_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib2d\0",
        &self.glVertexAttrib2d_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib2d_is_loaded(&self) -> bool {
      !self.glVertexAttrib2d_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib2dv](http://docs.gl/gl3/glVertexAttrib2dv)(index, v)
    /// * `v` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib2dv(&self, index: GLuint, v: *const GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib2dv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib2dv",
        &self.glVertexAttrib2dv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib2dv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib2dv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib2dv\0",
        &self.glVertexAttrib2dv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib2dv_is_loaded(&self) -> bool {
      !self.glVertexAttrib2dv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib2f](http://docs.gl/gl3/glVertexAttrib)(index, x, y)
    /// * vector equivalent: [`glVertexAttrib2fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib2f(&self, index: GLuint, x: GLfloat, y: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib2f({:?}, {:?}, {:?});", index, x, y);
      }
      let out = call_atomic_ptr_3arg(
        "glVertexAttrib2f",
        &self.glVertexAttrib2f_p,
        index,
        x,
        y,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib2f");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib2f_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib2f\0",
        &self.glVertexAttrib2f_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib2f_is_loaded(&self) -> bool {
      !self.glVertexAttrib2f_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib2fv](http://docs.gl/gl3/glVertexAttrib)(index, v)
    /// * `v` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib2fv(&self, index: GLuint, v: *const GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib2fv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib2fv",
        &self.glVertexAttrib2fv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib2fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib2fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib2fv\0",
        &self.glVertexAttrib2fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib2fv_is_loaded(&self) -> bool {
      !self.glVertexAttrib2fv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib2s](http://docs.gl/gl3/glVertexAttrib2s)(index, x, y)
    /// * vector equivalent: [`glVertexAttrib2sv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib2s(&self, index: GLuint, x: GLshort, y: GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib2s({:?}, {:?}, {:?});", index, x, y);
      }
      let out = call_atomic_ptr_3arg(
        "glVertexAttrib2s",
        &self.glVertexAttrib2s_p,
        index,
        x,
        y,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib2s");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib2s_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib2s\0",
        &self.glVertexAttrib2s_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib2s_is_loaded(&self) -> bool {
      !self.glVertexAttrib2s_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib2sv](http://docs.gl/gl3/glVertexAttrib2sv)(index, v)
    /// * `v` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib2sv(&self, index: GLuint, v: *const GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib2sv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib2sv",
        &self.glVertexAttrib2sv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib2sv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib2sv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib2sv\0",
        &self.glVertexAttrib2sv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib2sv_is_loaded(&self) -> bool {
      !self.glVertexAttrib2sv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib3d](http://docs.gl/gl3/glVertexAttrib3d)(index, x, y, z)
    /// * vector equivalent: [`glVertexAttrib3dv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib3d(
      &self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib3d({:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttrib3d",
        &self.glVertexAttrib3d_p,
        index,
        x,
        y,
        z,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib3d");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib3d_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib3d\0",
        &self.glVertexAttrib3d_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib3d_is_loaded(&self) -> bool {
      !self.glVertexAttrib3d_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib3dv](http://docs.gl/gl3/glVertexAttrib3dv)(index, v)
    /// * `v` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib3dv(&self, index: GLuint, v: *const GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib3dv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib3dv",
        &self.glVertexAttrib3dv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib3dv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib3dv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib3dv\0",
        &self.glVertexAttrib3dv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib3dv_is_loaded(&self) -> bool {
      !self.glVertexAttrib3dv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib3f](http://docs.gl/gl3/glVertexAttrib)(index, x, y, z)
    /// * vector equivalent: [`glVertexAttrib3fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib3f(
      &self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib3f({:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttrib3f",
        &self.glVertexAttrib3f_p,
        index,
        x,
        y,
        z,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib3f");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib3f_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib3f\0",
        &self.glVertexAttrib3f_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib3f_is_loaded(&self) -> bool {
      !self.glVertexAttrib3f_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib3fv](http://docs.gl/gl3/glVertexAttrib)(index, v)
    /// * `v` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib3fv(&self, index: GLuint, v: *const GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib3fv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib3fv",
        &self.glVertexAttrib3fv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib3fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib3fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib3fv\0",
        &self.glVertexAttrib3fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib3fv_is_loaded(&self) -> bool {
      !self.glVertexAttrib3fv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib3s](http://docs.gl/gl3/glVertexAttrib3s)(index, x, y, z)
    /// * vector equivalent: [`glVertexAttrib3sv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib3s(
      &self, index: GLuint, x: GLshort, y: GLshort, z: GLshort,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib3s({:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttrib3s",
        &self.glVertexAttrib3s_p,
        index,
        x,
        y,
        z,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib3s");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib3s_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib3s\0",
        &self.glVertexAttrib3s_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib3s_is_loaded(&self) -> bool {
      !self.glVertexAttrib3s_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib3sv](http://docs.gl/gl3/glVertexAttrib3sv)(index, v)
    /// * `v` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib3sv(&self, index: GLuint, v: *const GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib3sv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib3sv",
        &self.glVertexAttrib3sv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib3sv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib3sv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib3sv\0",
        &self.glVertexAttrib3sv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib3sv_is_loaded(&self) -> bool {
      !self.glVertexAttrib3sv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Nbv](http://docs.gl/gl3/glVertexAttrib4Nbv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Nbv(&self, index: GLuint, v: *const GLbyte) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4Nbv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4Nbv",
        &self.glVertexAttrib4Nbv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4Nbv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4Nbv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4Nbv\0",
        &self.glVertexAttrib4Nbv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Nbv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Nbv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Niv](http://docs.gl/gl3/glVertexAttrib4N)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Niv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4Niv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4Niv",
        &self.glVertexAttrib4Niv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4Niv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4Niv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4Niv\0",
        &self.glVertexAttrib4Niv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Niv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Niv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Nsv](http://docs.gl/gl3/glVertexAttrib4Nsv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Nsv(&self, index: GLuint, v: *const GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4Nsv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4Nsv",
        &self.glVertexAttrib4Nsv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4Nsv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4Nsv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4Nsv\0",
        &self.glVertexAttrib4Nsv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Nsv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Nsv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Nub](http://docs.gl/gl3/glVertexAttrib4Nub)(index, x, y, z, w)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Nub(
      &self, index: GLuint, x: GLubyte, y: GLubyte, z: GLubyte, w: GLubyte,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib4Nub({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let out = call_atomic_ptr_5arg(
        "glVertexAttrib4Nub",
        &self.glVertexAttrib4Nub_p,
        index,
        x,
        y,
        z,
        w,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4Nub");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4Nub_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4Nub\0",
        &self.glVertexAttrib4Nub_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Nub_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Nub_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Nubv](http://docs.gl/gl3/glVertexAttrib4Nubv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Nubv(&self, index: GLuint, v: *const GLubyte) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4Nubv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4Nubv",
        &self.glVertexAttrib4Nubv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4Nubv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4Nubv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4Nubv\0",
        &self.glVertexAttrib4Nubv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Nubv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Nubv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Nuiv](http://docs.gl/gl3/glVertexAttrib4N)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Nuiv(&self, index: GLuint, v: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4Nuiv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4Nuiv",
        &self.glVertexAttrib4Nuiv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4Nuiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4Nuiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4Nuiv\0",
        &self.glVertexAttrib4Nuiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Nuiv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Nuiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Nusv](http://docs.gl/gl3/glVertexAttrib4Nusv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Nusv(&self, index: GLuint, v: *const GLushort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4Nusv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4Nusv",
        &self.glVertexAttrib4Nusv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4Nusv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4Nusv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4Nusv\0",
        &self.glVertexAttrib4Nusv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Nusv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Nusv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4bv](http://docs.gl/gl3/glVertexAttrib4bv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4bv(&self, index: GLuint, v: *const GLbyte) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4bv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4bv",
        &self.glVertexAttrib4bv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4bv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4bv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4bv\0",
        &self.glVertexAttrib4bv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4bv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4bv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4d](http://docs.gl/gl3/glVertexAttrib4d)(index, x, y, z, w)
    /// * vector equivalent: [`glVertexAttrib4dv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4d(
      &self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib4d({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let out = call_atomic_ptr_5arg(
        "glVertexAttrib4d",
        &self.glVertexAttrib4d_p,
        index,
        x,
        y,
        z,
        w,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4d");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4d_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4d\0",
        &self.glVertexAttrib4d_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4d_is_loaded(&self) -> bool {
      !self.glVertexAttrib4d_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4dv](http://docs.gl/gl3/glVertexAttrib4dv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4dv(&self, index: GLuint, v: *const GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4dv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4dv",
        &self.glVertexAttrib4dv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4dv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4dv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4dv\0",
        &self.glVertexAttrib4dv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4dv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4dv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4f](http://docs.gl/gl3/glVertexAttrib)(index, x, y, z, w)
    /// * vector equivalent: [`glVertexAttrib4fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4f(
      &self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib4f({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let out = call_atomic_ptr_5arg(
        "glVertexAttrib4f",
        &self.glVertexAttrib4f_p,
        index,
        x,
        y,
        z,
        w,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4f");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4f_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4f\0",
        &self.glVertexAttrib4f_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4f_is_loaded(&self) -> bool {
      !self.glVertexAttrib4f_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4fv](http://docs.gl/gl3/glVertexAttrib)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4fv(&self, index: GLuint, v: *const GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4fv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4fv",
        &self.glVertexAttrib4fv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4fv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4fv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4fv\0",
        &self.glVertexAttrib4fv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4fv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4fv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4iv](http://docs.gl/gl3/glVertexAttrib)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4iv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4iv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4iv",
        &self.glVertexAttrib4iv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4iv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4iv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4iv\0",
        &self.glVertexAttrib4iv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4iv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4iv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4s](http://docs.gl/gl3/glVertexAttrib4s)(index, x, y, z, w)
    /// * vector equivalent: [`glVertexAttrib4sv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4s(
      &self, index: GLuint, x: GLshort, y: GLshort, z: GLshort, w: GLshort,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib4s({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let out = call_atomic_ptr_5arg(
        "glVertexAttrib4s",
        &self.glVertexAttrib4s_p,
        index,
        x,
        y,
        z,
        w,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4s");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4s_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4s\0",
        &self.glVertexAttrib4s_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4s_is_loaded(&self) -> bool {
      !self.glVertexAttrib4s_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4sv](http://docs.gl/gl3/glVertexAttrib4sv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4sv(&self, index: GLuint, v: *const GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4sv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4sv",
        &self.glVertexAttrib4sv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4sv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4sv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4sv\0",
        &self.glVertexAttrib4sv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4sv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4sv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4ubv](http://docs.gl/gl3/glVertexAttrib4ubv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4ubv(&self, index: GLuint, v: *const GLubyte) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4ubv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4ubv",
        &self.glVertexAttrib4ubv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4ubv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4ubv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4ubv\0",
        &self.glVertexAttrib4ubv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4ubv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4ubv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4uiv](http://docs.gl/gl3/glVertexAttrib)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4uiv(&self, index: GLuint, v: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4uiv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4uiv",
        &self.glVertexAttrib4uiv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4uiv\0",
        &self.glVertexAttrib4uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4uiv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4usv](http://docs.gl/gl3/glVertexAttrib4usv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4usv(&self, index: GLuint, v: *const GLushort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4usv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttrib4usv",
        &self.glVertexAttrib4usv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttrib4usv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttrib4usv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttrib4usv\0",
        &self.glVertexAttrib4usv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4usv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4usv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribDivisor](http://docs.gl/gl3/glVertexAttribDivisor)(index, divisor)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribDivisor(&self, index: GLuint, divisor: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribDivisor({:?}, {:?});", index, divisor);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribDivisor",
        &self.glVertexAttribDivisor_p,
        index,
        divisor,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribDivisor");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribDivisor_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribDivisor\0",
        &self.glVertexAttribDivisor_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribDivisor_is_loaded(&self) -> bool {
      !self.glVertexAttribDivisor_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI1i](http://docs.gl/gl3/glVertexAttribI)(index, x)
    /// * vector equivalent: [`glVertexAttribI1iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI1i(&self, index: GLuint, x: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI1i({:?}, {:?});", index, x);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI1i",
        &self.glVertexAttribI1i_p,
        index,
        x,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI1i");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI1i_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI1i\0",
        &self.glVertexAttribI1i_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI1i_is_loaded(&self) -> bool {
      !self.glVertexAttribI1i_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI1iv](http://docs.gl/gl3/glVertexAttribI)(index, v)
    /// * `v` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI1iv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI1iv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI1iv",
        &self.glVertexAttribI1iv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI1iv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI1iv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI1iv\0",
        &self.glVertexAttribI1iv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI1iv_is_loaded(&self) -> bool {
      !self.glVertexAttribI1iv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI1ui](http://docs.gl/gl3/glVertexAttribI)(index, x)
    /// * vector equivalent: [`glVertexAttribI1uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI1ui(&self, index: GLuint, x: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI1ui({:?}, {:?});", index, x);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI1ui",
        &self.glVertexAttribI1ui_p,
        index,
        x,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI1ui");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI1ui_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI1ui\0",
        &self.glVertexAttribI1ui_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI1ui_is_loaded(&self) -> bool {
      !self.glVertexAttribI1ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI1uiv](http://docs.gl/gl3/glVertexAttribI)(index, v)
    /// * `v` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI1uiv(&self, index: GLuint, v: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI1uiv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI1uiv",
        &self.glVertexAttribI1uiv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI1uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI1uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI1uiv\0",
        &self.glVertexAttribI1uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI1uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribI1uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI2i](http://docs.gl/gl3/glVertexAttribI)(index, x, y)
    /// * vector equivalent: [`glVertexAttribI2iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI2i(&self, index: GLuint, x: GLint, y: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI2i({:?}, {:?}, {:?});", index, x, y);
      }
      let out = call_atomic_ptr_3arg(
        "glVertexAttribI2i",
        &self.glVertexAttribI2i_p,
        index,
        x,
        y,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI2i");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI2i_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI2i\0",
        &self.glVertexAttribI2i_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI2i_is_loaded(&self) -> bool {
      !self.glVertexAttribI2i_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI2iv](http://docs.gl/gl3/glVertexAttribI)(index, v)
    /// * `v` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI2iv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI2iv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI2iv",
        &self.glVertexAttribI2iv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI2iv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI2iv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI2iv\0",
        &self.glVertexAttribI2iv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI2iv_is_loaded(&self) -> bool {
      !self.glVertexAttribI2iv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI2ui](http://docs.gl/gl3/glVertexAttribI)(index, x, y)
    /// * vector equivalent: [`glVertexAttribI2uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI2ui(&self, index: GLuint, x: GLuint, y: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI2ui({:?}, {:?}, {:?});", index, x, y);
      }
      let out = call_atomic_ptr_3arg(
        "glVertexAttribI2ui",
        &self.glVertexAttribI2ui_p,
        index,
        x,
        y,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI2ui");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI2ui_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI2ui\0",
        &self.glVertexAttribI2ui_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI2ui_is_loaded(&self) -> bool {
      !self.glVertexAttribI2ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI2uiv](http://docs.gl/gl3/glVertexAttribI)(index, v)
    /// * `v` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI2uiv(&self, index: GLuint, v: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI2uiv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI2uiv",
        &self.glVertexAttribI2uiv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI2uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI2uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI2uiv\0",
        &self.glVertexAttribI2uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI2uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribI2uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI3i](http://docs.gl/gl3/glVertexAttribI)(index, x, y, z)
    /// * vector equivalent: [`glVertexAttribI3iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI3i(
      &self, index: GLuint, x: GLint, y: GLint, z: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribI3i({:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttribI3i",
        &self.glVertexAttribI3i_p,
        index,
        x,
        y,
        z,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI3i");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI3i_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI3i\0",
        &self.glVertexAttribI3i_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI3i_is_loaded(&self) -> bool {
      !self.glVertexAttribI3i_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI3iv](http://docs.gl/gl3/glVertexAttribI)(index, v)
    /// * `v` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI3iv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI3iv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI3iv",
        &self.glVertexAttribI3iv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI3iv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI3iv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI3iv\0",
        &self.glVertexAttribI3iv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI3iv_is_loaded(&self) -> bool {
      !self.glVertexAttribI3iv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI3ui](http://docs.gl/gl3/glVertexAttribI)(index, x, y, z)
    /// * vector equivalent: [`glVertexAttribI3uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI3ui(
      &self, index: GLuint, x: GLuint, y: GLuint, z: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribI3ui({:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttribI3ui",
        &self.glVertexAttribI3ui_p,
        index,
        x,
        y,
        z,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI3ui");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI3ui_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI3ui\0",
        &self.glVertexAttribI3ui_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI3ui_is_loaded(&self) -> bool {
      !self.glVertexAttribI3ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI3uiv](http://docs.gl/gl3/glVertexAttribI)(index, v)
    /// * `v` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI3uiv(&self, index: GLuint, v: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI3uiv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI3uiv",
        &self.glVertexAttribI3uiv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI3uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI3uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI3uiv\0",
        &self.glVertexAttribI3uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI3uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribI3uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4bv](http://docs.gl/gl3/glVertexAttribI4bv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4bv(&self, index: GLuint, v: *const GLbyte) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI4bv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI4bv",
        &self.glVertexAttribI4bv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI4bv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI4bv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI4bv\0",
        &self.glVertexAttribI4bv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4bv_is_loaded(&self) -> bool {
      !self.glVertexAttribI4bv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4i](http://docs.gl/gl3/glVertexAttribI)(index, x, y, z, w)
    /// * vector equivalent: [`glVertexAttribI4iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4i(
      &self, index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribI4i({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let out = call_atomic_ptr_5arg(
        "glVertexAttribI4i",
        &self.glVertexAttribI4i_p,
        index,
        x,
        y,
        z,
        w,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI4i");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI4i_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI4i\0",
        &self.glVertexAttribI4i_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4i_is_loaded(&self) -> bool {
      !self.glVertexAttribI4i_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4iv](http://docs.gl/gl3/glVertexAttrib)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4iv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI4iv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI4iv",
        &self.glVertexAttribI4iv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI4iv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI4iv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI4iv\0",
        &self.glVertexAttribI4iv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4iv_is_loaded(&self) -> bool {
      !self.glVertexAttribI4iv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4sv](http://docs.gl/gl3/glVertexAttribI4sv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4sv(&self, index: GLuint, v: *const GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI4sv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI4sv",
        &self.glVertexAttribI4sv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI4sv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI4sv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI4sv\0",
        &self.glVertexAttribI4sv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4sv_is_loaded(&self) -> bool {
      !self.glVertexAttribI4sv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4ubv](http://docs.gl/gl3/glVertexAttribI4ubv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4ubv(&self, index: GLuint, v: *const GLubyte) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI4ubv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI4ubv",
        &self.glVertexAttribI4ubv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI4ubv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI4ubv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI4ubv\0",
        &self.glVertexAttribI4ubv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4ubv_is_loaded(&self) -> bool {
      !self.glVertexAttribI4ubv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4ui](http://docs.gl/gl3/glVertexAttrib)(index, x, y, z, w)
    /// * vector equivalent: [`glVertexAttribI4uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4ui(
      &self, index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribI4ui({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let out = call_atomic_ptr_5arg(
        "glVertexAttribI4ui",
        &self.glVertexAttribI4ui_p,
        index,
        x,
        y,
        z,
        w,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI4ui");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI4ui_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI4ui\0",
        &self.glVertexAttribI4ui_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4ui_is_loaded(&self) -> bool {
      !self.glVertexAttribI4ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4uiv](http://docs.gl/gl3/glVertexAttrib)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4uiv(&self, index: GLuint, v: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI4uiv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI4uiv",
        &self.glVertexAttribI4uiv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI4uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI4uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI4uiv\0",
        &self.glVertexAttribI4uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribI4uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4usv](http://docs.gl/gl3/glVertexAttribI4usv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4usv(&self, index: GLuint, v: *const GLushort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI4usv({:?}, {:p});", index, v);
      }
      let out = call_atomic_ptr_2arg(
        "glVertexAttribI4usv",
        &self.glVertexAttribI4usv_p,
        index,
        v,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribI4usv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribI4usv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribI4usv\0",
        &self.glVertexAttribI4usv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4usv_is_loaded(&self) -> bool {
      !self.glVertexAttribI4usv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribIPointer](http://docs.gl/gl3/glVertexAttribPointer)(index, size, type_, stride, pointer)
    /// * `type_` group: VertexAttribIType
    /// * `pointer` len: COMPSIZE(size,type,stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribIPointer(
      &self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei,
      pointer: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribIPointer({:?}, {:?}, {:#X}, {:?}, {:p});",
          index,
          size,
          type_,
          stride,
          pointer
        );
      }
      let out = call_atomic_ptr_5arg(
        "glVertexAttribIPointer",
        &self.glVertexAttribIPointer_p,
        index,
        size,
        type_,
        stride,
        pointer,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribIPointer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribIPointer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribIPointer\0",
        &self.glVertexAttribIPointer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribIPointer_is_loaded(&self) -> bool {
      !self.glVertexAttribIPointer_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP1ui](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP1ui(
      &self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP1ui({:?}, {:#X}, {:?}, {:?});",
          index,
          type_,
          normalized,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttribP1ui",
        &self.glVertexAttribP1ui_p,
        index,
        type_,
        normalized,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribP1ui");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribP1ui_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribP1ui\0",
        &self.glVertexAttribP1ui_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP1ui_is_loaded(&self) -> bool {
      !self.glVertexAttribP1ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP1uiv](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    /// * `value` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP1uiv(
      &self, index: GLuint, type_: GLenum, normalized: GLboolean,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP1uiv({:?}, {:#X}, {:?}, {:p});",
          index,
          type_,
          normalized,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttribP1uiv",
        &self.glVertexAttribP1uiv_p,
        index,
        type_,
        normalized,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribP1uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribP1uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribP1uiv\0",
        &self.glVertexAttribP1uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP1uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribP1uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP2ui](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP2ui(
      &self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP2ui({:?}, {:#X}, {:?}, {:?});",
          index,
          type_,
          normalized,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttribP2ui",
        &self.glVertexAttribP2ui_p,
        index,
        type_,
        normalized,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribP2ui");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribP2ui_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribP2ui\0",
        &self.glVertexAttribP2ui_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP2ui_is_loaded(&self) -> bool {
      !self.glVertexAttribP2ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP2uiv](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    /// * `value` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP2uiv(
      &self, index: GLuint, type_: GLenum, normalized: GLboolean,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP2uiv({:?}, {:#X}, {:?}, {:p});",
          index,
          type_,
          normalized,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttribP2uiv",
        &self.glVertexAttribP2uiv_p,
        index,
        type_,
        normalized,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribP2uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribP2uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribP2uiv\0",
        &self.glVertexAttribP2uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP2uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribP2uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP3ui](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP3ui(
      &self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP3ui({:?}, {:#X}, {:?}, {:?});",
          index,
          type_,
          normalized,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttribP3ui",
        &self.glVertexAttribP3ui_p,
        index,
        type_,
        normalized,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribP3ui");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribP3ui_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribP3ui\0",
        &self.glVertexAttribP3ui_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP3ui_is_loaded(&self) -> bool {
      !self.glVertexAttribP3ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP3uiv](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    /// * `value` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP3uiv(
      &self, index: GLuint, type_: GLenum, normalized: GLboolean,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP3uiv({:?}, {:#X}, {:?}, {:p});",
          index,
          type_,
          normalized,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttribP3uiv",
        &self.glVertexAttribP3uiv_p,
        index,
        type_,
        normalized,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribP3uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribP3uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribP3uiv\0",
        &self.glVertexAttribP3uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP3uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribP3uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP4ui](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP4ui(
      &self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP4ui({:?}, {:#X}, {:?}, {:?});",
          index,
          type_,
          normalized,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttribP4ui",
        &self.glVertexAttribP4ui_p,
        index,
        type_,
        normalized,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribP4ui");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribP4ui_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribP4ui\0",
        &self.glVertexAttribP4ui_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP4ui_is_loaded(&self) -> bool {
      !self.glVertexAttribP4ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP4uiv](http://docs.gl/gl3/glVertexAttribP)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    /// * `value` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP4uiv(
      &self, index: GLuint, type_: GLenum, normalized: GLboolean,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP4uiv({:?}, {:#X}, {:?}, {:p});",
          index,
          type_,
          normalized,
          value
        );
      }
      let out = call_atomic_ptr_4arg(
        "glVertexAttribP4uiv",
        &self.glVertexAttribP4uiv_p,
        index,
        type_,
        normalized,
        value,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribP4uiv");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribP4uiv_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribP4uiv\0",
        &self.glVertexAttribP4uiv_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP4uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribP4uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribPointer](http://docs.gl/gl3/glVertexAttribPointer)(index, size, type_, normalized, stride, pointer)
    /// * `type_` group: VertexAttribPointerType
    /// * `pointer` len: COMPSIZE(size,type,stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribPointer(
      &self, index: GLuint, size: GLint, type_: GLenum, normalized: GLboolean,
      stride: GLsizei, pointer: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribPointer({:?}, {:?}, {:#X}, {:?}, {:?}, {:p});", index, size, type_, normalized, stride, pointer);
      }
      let out = call_atomic_ptr_6arg(
        "glVertexAttribPointer",
        &self.glVertexAttribPointer_p,
        index,
        size,
        type_,
        normalized,
        stride,
        pointer,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glVertexAttribPointer");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn VertexAttribPointer_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glVertexAttribPointer\0",
        &self.glVertexAttribPointer_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribPointer_is_loaded(&self) -> bool {
      !self.glVertexAttribPointer_p.load(RELAX).is_null()
    }
    /// [glViewport](http://docs.gl/gl3/glViewport)(x, y, width, height)
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Viewport(
      &self, x: GLint, y: GLint, width: GLsizei, height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Viewport({:?}, {:?}, {:?}, {:?});",
          x,
          y,
          width,
          height
        );
      }
      let out = call_atomic_ptr_4arg(
        "glViewport",
        &self.glViewport_p,
        x,
        y,
        width,
        height,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glViewport");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn Viewport_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glViewport\0",
        &self.glViewport_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn Viewport_is_loaded(&self) -> bool {
      !self.glViewport_p.load(RELAX).is_null()
    }
    /// [glWaitSync](http://docs.gl/gl3/glWaitSync)(sync, flags, timeout)
    /// * `sync` group: sync
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn WaitSync(
      &self, sync: GLsync, flags: GLbitfield, timeout: GLuint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.WaitSync({:p}, {:?}, {:?});", sync, flags, timeout);
      }
      let out = call_atomic_ptr_3arg(
        "glWaitSync",
        &self.glWaitSync_p,
        sync,
        flags,
        timeout,
      );
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        self.automatic_glGetError("glWaitSync");
      }
      out
    }
    #[doc(hidden)]
    pub unsafe fn WaitSync_load_with_dyn(
      &self, get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
      load_dyn_name_atomic_ptr(
        get_proc_address,
        b"glWaitSync\0",
        &self.glWaitSync_p,
      )
    }
    #[inline]
    #[doc(hidden)]
    pub fn WaitSync_is_loaded(&self) -> bool {
      !self.glWaitSync_p.load(RELAX).is_null()
    }
  }
  /// This holds the many, many function pointers for GL.
  ///
  /// It's typically quite large (hundreds of pointers), depending on what API
  /// level and extensions you selected during the generation.
  #[repr(C)]
  pub struct GlFns {
    glActiveTexture_p: APcv,
    glAttachShader_p: APcv,
    glBeginConditionalRender_p: APcv,
    glBeginQuery_p: APcv,
    glBeginTransformFeedback_p: APcv,
    glBindAttribLocation_p: APcv,
    glBindBuffer_p: APcv,
    glBindBufferBase_p: APcv,
    glBindBufferRange_p: APcv,
    glBindFragDataLocation_p: APcv,
    glBindFragDataLocationIndexed_p: APcv,
    glBindFramebuffer_p: APcv,
    glBindRenderbuffer_p: APcv,
    glBindSampler_p: APcv,
    glBindTexture_p: APcv,
    glBindVertexArray_p: APcv,
    glBlendColor_p: APcv,
    glBlendEquation_p: APcv,
    glBlendEquationSeparate_p: APcv,
    glBlendFunc_p: APcv,
    glBlendFuncSeparate_p: APcv,
    glBlitFramebuffer_p: APcv,
    glBufferData_p: APcv,
    glBufferSubData_p: APcv,
    glCheckFramebufferStatus_p: APcv,
    glClampColor_p: APcv,
    glClear_p: APcv,
    glClearBufferfi_p: APcv,
    glClearBufferfv_p: APcv,
    glClearBufferiv_p: APcv,
    glClearBufferuiv_p: APcv,
    glClearColor_p: APcv,
    glClearDepth_p: APcv,
    glClearStencil_p: APcv,
    glClientWaitSync_p: APcv,
    glColorMask_p: APcv,
    glColorMaski_p: APcv,
    glCompileShader_p: APcv,
    glCompressedTexImage1D_p: APcv,
    glCompressedTexImage2D_p: APcv,
    glCompressedTexImage3D_p: APcv,
    glCompressedTexSubImage1D_p: APcv,
    glCompressedTexSubImage2D_p: APcv,
    glCompressedTexSubImage3D_p: APcv,
    glCopyBufferSubData_p: APcv,
    glCopyTexImage1D_p: APcv,
    glCopyTexImage2D_p: APcv,
    glCopyTexSubImage1D_p: APcv,
    glCopyTexSubImage2D_p: APcv,
    glCopyTexSubImage3D_p: APcv,
    glCreateProgram_p: APcv,
    glCreateShader_p: APcv,
    glCullFace_p: APcv,
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    glDebugMessageCallback_p: APcv,
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    glDebugMessageCallbackARB_p: APcv,
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    glDebugMessageControl_p: APcv,
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    glDebugMessageControlARB_p: APcv,
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    glDebugMessageInsert_p: APcv,
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    glDebugMessageInsertARB_p: APcv,
    glDeleteBuffers_p: APcv,
    glDeleteFramebuffers_p: APcv,
    glDeleteProgram_p: APcv,
    glDeleteQueries_p: APcv,
    glDeleteRenderbuffers_p: APcv,
    glDeleteSamplers_p: APcv,
    glDeleteShader_p: APcv,
    glDeleteSync_p: APcv,
    glDeleteTextures_p: APcv,
    glDeleteVertexArrays_p: APcv,
    glDepthFunc_p: APcv,
    glDepthMask_p: APcv,
    glDepthRange_p: APcv,
    glDetachShader_p: APcv,
    glDisable_p: APcv,
    glDisableVertexAttribArray_p: APcv,
    glDisablei_p: APcv,
    glDrawArrays_p: APcv,
    glDrawArraysInstanced_p: APcv,
    glDrawBuffer_p: APcv,
    glDrawBuffers_p: APcv,
    glDrawElements_p: APcv,
    glDrawElementsBaseVertex_p: APcv,
    glDrawElementsInstanced_p: APcv,
    glDrawElementsInstancedBaseVertex_p: APcv,
    glDrawRangeElements_p: APcv,
    glDrawRangeElementsBaseVertex_p: APcv,
    glEnable_p: APcv,
    glEnableVertexAttribArray_p: APcv,
    glEnablei_p: APcv,
    glEndConditionalRender_p: APcv,
    glEndQuery_p: APcv,
    glEndTransformFeedback_p: APcv,
    glFenceSync_p: APcv,
    glFinish_p: APcv,
    glFlush_p: APcv,
    glFlushMappedBufferRange_p: APcv,
    glFramebufferRenderbuffer_p: APcv,
    glFramebufferTexture_p: APcv,
    glFramebufferTexture1D_p: APcv,
    glFramebufferTexture2D_p: APcv,
    glFramebufferTexture3D_p: APcv,
    glFramebufferTextureLayer_p: APcv,
    glFrontFace_p: APcv,
    glGenBuffers_p: APcv,
    glGenFramebuffers_p: APcv,
    glGenQueries_p: APcv,
    glGenRenderbuffers_p: APcv,
    glGenSamplers_p: APcv,
    glGenTextures_p: APcv,
    glGenVertexArrays_p: APcv,
    glGenerateMipmap_p: APcv,
    glGetActiveAttrib_p: APcv,
    glGetActiveUniform_p: APcv,
    glGetActiveUniformBlockName_p: APcv,
    glGetActiveUniformBlockiv_p: APcv,
    glGetActiveUniformName_p: APcv,
    glGetActiveUniformsiv_p: APcv,
    glGetAttachedShaders_p: APcv,
    glGetAttribLocation_p: APcv,
    glGetBooleani_v_p: APcv,
    glGetBooleanv_p: APcv,
    glGetBufferParameteri64v_p: APcv,
    glGetBufferParameteriv_p: APcv,
    glGetBufferPointerv_p: APcv,
    glGetBufferSubData_p: APcv,
    glGetCompressedTexImage_p: APcv,
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    glGetDebugMessageLog_p: APcv,
    #[cfg(any(feature = "GL_ARB_debug_output"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ARB_debug_output"))))]
    glGetDebugMessageLogARB_p: APcv,
    glGetDoublev_p: APcv,
    glGetError_p: APcv,
    glGetFloatv_p: APcv,
    glGetFragDataIndex_p: APcv,
    glGetFragDataLocation_p: APcv,
    glGetFramebufferAttachmentParameteriv_p: APcv,
    glGetInteger64i_v_p: APcv,
    glGetInteger64v_p: APcv,
    glGetIntegeri_v_p: APcv,
    glGetIntegerv_p: APcv,
    glGetMultisamplefv_p: APcv,
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    glGetObjectLabel_p: APcv,
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    glGetObjectPtrLabel_p: APcv,
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    glGetPointerv_p: APcv,
    glGetProgramInfoLog_p: APcv,
    glGetProgramiv_p: APcv,
    glGetQueryObjecti64v_p: APcv,
    glGetQueryObjectiv_p: APcv,
    glGetQueryObjectui64v_p: APcv,
    glGetQueryObjectuiv_p: APcv,
    glGetQueryiv_p: APcv,
    glGetRenderbufferParameteriv_p: APcv,
    glGetSamplerParameterIiv_p: APcv,
    glGetSamplerParameterIuiv_p: APcv,
    glGetSamplerParameterfv_p: APcv,
    glGetSamplerParameteriv_p: APcv,
    glGetShaderInfoLog_p: APcv,
    glGetShaderSource_p: APcv,
    glGetShaderiv_p: APcv,
    glGetString_p: APcv,
    glGetStringi_p: APcv,
    glGetSynciv_p: APcv,
    glGetTexImage_p: APcv,
    glGetTexLevelParameterfv_p: APcv,
    glGetTexLevelParameteriv_p: APcv,
    glGetTexParameterIiv_p: APcv,
    glGetTexParameterIuiv_p: APcv,
    glGetTexParameterfv_p: APcv,
    glGetTexParameteriv_p: APcv,
    glGetTransformFeedbackVarying_p: APcv,
    glGetUniformBlockIndex_p: APcv,
    glGetUniformIndices_p: APcv,
    glGetUniformLocation_p: APcv,
    glGetUniformfv_p: APcv,
    glGetUniformiv_p: APcv,
    glGetUniformuiv_p: APcv,
    glGetVertexAttribIiv_p: APcv,
    glGetVertexAttribIuiv_p: APcv,
    glGetVertexAttribPointerv_p: APcv,
    glGetVertexAttribdv_p: APcv,
    glGetVertexAttribfv_p: APcv,
    glGetVertexAttribiv_p: APcv,
    glHint_p: APcv,
    glIsBuffer_p: APcv,
    glIsEnabled_p: APcv,
    glIsEnabledi_p: APcv,
    glIsFramebuffer_p: APcv,
    glIsProgram_p: APcv,
    glIsQuery_p: APcv,
    glIsRenderbuffer_p: APcv,
    glIsSampler_p: APcv,
    glIsShader_p: APcv,
    glIsSync_p: APcv,
    glIsTexture_p: APcv,
    glIsVertexArray_p: APcv,
    glLineWidth_p: APcv,
    glLinkProgram_p: APcv,
    glLogicOp_p: APcv,
    glMapBuffer_p: APcv,
    glMapBufferRange_p: APcv,
    glMultiDrawArrays_p: APcv,
    glMultiDrawElements_p: APcv,
    glMultiDrawElementsBaseVertex_p: APcv,
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    glObjectLabel_p: APcv,
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    glObjectPtrLabel_p: APcv,
    glPixelStoref_p: APcv,
    glPixelStorei_p: APcv,
    glPointParameterf_p: APcv,
    glPointParameterfv_p: APcv,
    glPointParameteri_p: APcv,
    glPointParameteriv_p: APcv,
    glPointSize_p: APcv,
    glPolygonMode_p: APcv,
    glPolygonOffset_p: APcv,
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    glPopDebugGroup_p: APcv,
    glPrimitiveRestartIndex_p: APcv,
    glProvokingVertex_p: APcv,
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    glPushDebugGroup_p: APcv,
    glQueryCounter_p: APcv,
    glReadBuffer_p: APcv,
    glReadPixels_p: APcv,
    glRenderbufferStorage_p: APcv,
    glRenderbufferStorageMultisample_p: APcv,
    glSampleCoverage_p: APcv,
    glSampleMaski_p: APcv,
    glSamplerParameterIiv_p: APcv,
    glSamplerParameterIuiv_p: APcv,
    glSamplerParameterf_p: APcv,
    glSamplerParameterfv_p: APcv,
    glSamplerParameteri_p: APcv,
    glSamplerParameteriv_p: APcv,
    glScissor_p: APcv,
    glShaderSource_p: APcv,
    glStencilFunc_p: APcv,
    glStencilFuncSeparate_p: APcv,
    glStencilMask_p: APcv,
    glStencilMaskSeparate_p: APcv,
    glStencilOp_p: APcv,
    glStencilOpSeparate_p: APcv,
    glTexBuffer_p: APcv,
    glTexImage1D_p: APcv,
    glTexImage2D_p: APcv,
    glTexImage2DMultisample_p: APcv,
    glTexImage3D_p: APcv,
    glTexImage3DMultisample_p: APcv,
    glTexParameterIiv_p: APcv,
    glTexParameterIuiv_p: APcv,
    glTexParameterf_p: APcv,
    glTexParameterfv_p: APcv,
    glTexParameteri_p: APcv,
    glTexParameteriv_p: APcv,
    glTexSubImage1D_p: APcv,
    glTexSubImage2D_p: APcv,
    glTexSubImage3D_p: APcv,
    glTransformFeedbackVaryings_p: APcv,
    glUniform1f_p: APcv,
    glUniform1fv_p: APcv,
    glUniform1i_p: APcv,
    glUniform1iv_p: APcv,
    glUniform1ui_p: APcv,
    glUniform1uiv_p: APcv,
    glUniform2f_p: APcv,
    glUniform2fv_p: APcv,
    glUniform2i_p: APcv,
    glUniform2iv_p: APcv,
    glUniform2ui_p: APcv,
    glUniform2uiv_p: APcv,
    glUniform3f_p: APcv,
    glUniform3fv_p: APcv,
    glUniform3i_p: APcv,
    glUniform3iv_p: APcv,
    glUniform3ui_p: APcv,
    glUniform3uiv_p: APcv,
    glUniform4f_p: APcv,
    glUniform4fv_p: APcv,
    glUniform4i_p: APcv,
    glUniform4iv_p: APcv,
    glUniform4ui_p: APcv,
    glUniform4uiv_p: APcv,
    glUniformBlockBinding_p: APcv,
    glUniformMatrix2fv_p: APcv,
    glUniformMatrix2x3fv_p: APcv,
    glUniformMatrix2x4fv_p: APcv,
    glUniformMatrix3fv_p: APcv,
    glUniformMatrix3x2fv_p: APcv,
    glUniformMatrix3x4fv_p: APcv,
    glUniformMatrix4fv_p: APcv,
    glUniformMatrix4x2fv_p: APcv,
    glUniformMatrix4x3fv_p: APcv,
    glUnmapBuffer_p: APcv,
    glUseProgram_p: APcv,
    glValidateProgram_p: APcv,
    glVertexAttrib1d_p: APcv,
    glVertexAttrib1dv_p: APcv,
    glVertexAttrib1f_p: APcv,
    glVertexAttrib1fv_p: APcv,
    glVertexAttrib1s_p: APcv,
    glVertexAttrib1sv_p: APcv,
    glVertexAttrib2d_p: APcv,
    glVertexAttrib2dv_p: APcv,
    glVertexAttrib2f_p: APcv,
    glVertexAttrib2fv_p: APcv,
    glVertexAttrib2s_p: APcv,
    glVertexAttrib2sv_p: APcv,
    glVertexAttrib3d_p: APcv,
    glVertexAttrib3dv_p: APcv,
    glVertexAttrib3f_p: APcv,
    glVertexAttrib3fv_p: APcv,
    glVertexAttrib3s_p: APcv,
    glVertexAttrib3sv_p: APcv,
    glVertexAttrib4Nbv_p: APcv,
    glVertexAttrib4Niv_p: APcv,
    glVertexAttrib4Nsv_p: APcv,
    glVertexAttrib4Nub_p: APcv,
    glVertexAttrib4Nubv_p: APcv,
    glVertexAttrib4Nuiv_p: APcv,
    glVertexAttrib4Nusv_p: APcv,
    glVertexAttrib4bv_p: APcv,
    glVertexAttrib4d_p: APcv,
    glVertexAttrib4dv_p: APcv,
    glVertexAttrib4f_p: APcv,
    glVertexAttrib4fv_p: APcv,
    glVertexAttrib4iv_p: APcv,
    glVertexAttrib4s_p: APcv,
    glVertexAttrib4sv_p: APcv,
    glVertexAttrib4ubv_p: APcv,
    glVertexAttrib4uiv_p: APcv,
    glVertexAttrib4usv_p: APcv,
    glVertexAttribDivisor_p: APcv,
    glVertexAttribI1i_p: APcv,
    glVertexAttribI1iv_p: APcv,
    glVertexAttribI1ui_p: APcv,
    glVertexAttribI1uiv_p: APcv,
    glVertexAttribI2i_p: APcv,
    glVertexAttribI2iv_p: APcv,
    glVertexAttribI2ui_p: APcv,
    glVertexAttribI2uiv_p: APcv,
    glVertexAttribI3i_p: APcv,
    glVertexAttribI3iv_p: APcv,
    glVertexAttribI3ui_p: APcv,
    glVertexAttribI3uiv_p: APcv,
    glVertexAttribI4bv_p: APcv,
    glVertexAttribI4i_p: APcv,
    glVertexAttribI4iv_p: APcv,
    glVertexAttribI4sv_p: APcv,
    glVertexAttribI4ubv_p: APcv,
    glVertexAttribI4ui_p: APcv,
    glVertexAttribI4uiv_p: APcv,
    glVertexAttribI4usv_p: APcv,
    glVertexAttribIPointer_p: APcv,
    glVertexAttribP1ui_p: APcv,
    glVertexAttribP1uiv_p: APcv,
    glVertexAttribP2ui_p: APcv,
    glVertexAttribP2uiv_p: APcv,
    glVertexAttribP3ui_p: APcv,
    glVertexAttribP3uiv_p: APcv,
    glVertexAttribP4ui_p: APcv,
    glVertexAttribP4uiv_p: APcv,
    glVertexAttribPointer_p: APcv,
    glViewport_p: APcv,
    glWaitSync_p: APcv,
  }
  #[cfg(feature = "bytemuck")]
  unsafe impl bytemuck::Zeroable for GlFns {}
  impl core::fmt::Debug for GlFns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      write!(f, "GlFns")
    }
  }
}
// end of module
